/* valatyperegisterfunction.c generated by valac, the Vala compiler
 * generated from valatyperegisterfunction.vala, do not modify */

/* valatyperegisterfunction.vala
 *
 * Copyright (C) 2006-2010  Jürg Billeter
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 */

#include <glib.h>
#include <glib-object.h>
#include <vala.h>
#include <stdlib.h>
#include <string.h>
#include <valaccode.h>
#include <valagee.h>
#include <gobject/gvaluecollector.h>


#define VALA_TYPE_TYPEREGISTER_FUNCTION (vala_typeregister_function_get_type ())
#define VALA_TYPEREGISTER_FUNCTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPEREGISTER_FUNCTION, ValaTypeRegisterFunction))
#define VALA_TYPEREGISTER_FUNCTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPEREGISTER_FUNCTION, ValaTypeRegisterFunctionClass))
#define VALA_IS_TYPEREGISTER_FUNCTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPEREGISTER_FUNCTION))
#define VALA_IS_TYPEREGISTER_FUNCTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPEREGISTER_FUNCTION))
#define VALA_TYPEREGISTER_FUNCTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPEREGISTER_FUNCTION, ValaTypeRegisterFunctionClass))

typedef struct _ValaTypeRegisterFunction ValaTypeRegisterFunction;
typedef struct _ValaTypeRegisterFunctionClass ValaTypeRegisterFunctionClass;
typedef struct _ValaTypeRegisterFunctionPrivate ValaTypeRegisterFunctionPrivate;
#define _vala_ccode_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_ccode_node_unref (var), NULL)))
#define _vala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_context_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_node_unref (var), NULL)))
#define _vala_collection_object_unref0(var) ((var == NULL) ? NULL : (var = (vala_collection_object_unref (var), NULL)))
typedef struct _ValaParamSpecTypeRegisterFunction ValaParamSpecTypeRegisterFunction;

struct _ValaTypeRegisterFunction {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ValaTypeRegisterFunctionPrivate * priv;
};

struct _ValaTypeRegisterFunctionClass {
	GTypeClass parent_class;
	void (*finalize) (ValaTypeRegisterFunction *self);
	ValaTypeSymbol* (*get_type_declaration) (ValaTypeRegisterFunction* self);
	char* (*get_type_struct_name) (ValaTypeRegisterFunction* self);
	char* (*get_base_init_func_name) (ValaTypeRegisterFunction* self);
	char* (*get_class_finalize_func_name) (ValaTypeRegisterFunction* self);
	char* (*get_base_finalize_func_name) (ValaTypeRegisterFunction* self);
	char* (*get_class_init_func_name) (ValaTypeRegisterFunction* self);
	char* (*get_instance_struct_size) (ValaTypeRegisterFunction* self);
	char* (*get_instance_init_func_name) (ValaTypeRegisterFunction* self);
	char* (*get_parent_type_name) (ValaTypeRegisterFunction* self);
	char* (*get_gtype_value_table_init_function_name) (ValaTypeRegisterFunction* self);
	char* (*get_gtype_value_table_peek_pointer_function_name) (ValaTypeRegisterFunction* self);
	char* (*get_gtype_value_table_free_function_name) (ValaTypeRegisterFunction* self);
	char* (*get_gtype_value_table_copy_function_name) (ValaTypeRegisterFunction* self);
	char* (*get_gtype_value_table_lcopy_value_function_name) (ValaTypeRegisterFunction* self);
	char* (*get_gtype_value_table_collect_value_function_name) (ValaTypeRegisterFunction* self);
	char* (*get_type_flags) (ValaTypeRegisterFunction* self);
	ValaCCodeFragment* (*get_type_interface_init_declaration) (ValaTypeRegisterFunction* self);
	ValaCCodeFragment* (*get_type_interface_init_statements) (ValaTypeRegisterFunction* self, gboolean plugin);
	ValaSymbolAccessibility (*get_accessibility) (ValaTypeRegisterFunction* self);
};

struct _ValaTypeRegisterFunctionPrivate {
	ValaCCodeFragment* source_declaration_fragment;
	ValaCCodeFragment* declaration_fragment;
	ValaCCodeFragment* definition_fragment;
	ValaCodeContext* _context;
};

struct _ValaParamSpecTypeRegisterFunction {
	GParamSpec parent_instance;
};


static gpointer vala_typeregister_function_parent_class = NULL;

gpointer vala_typeregister_function_ref (gpointer instance);
void vala_typeregister_function_unref (gpointer instance);
GParamSpec* vala_param_spec_typeregister_function (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_typeregister_function (GValue* value, gpointer v_object);
void vala_value_take_typeregister_function (GValue* value, gpointer v_object);
gpointer vala_value_get_typeregister_function (const GValue* value);
GType vala_typeregister_function_get_type (void) G_GNUC_CONST;
#define VALA_TYPEREGISTER_FUNCTION_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), VALA_TYPE_TYPEREGISTER_FUNCTION, ValaTypeRegisterFunctionPrivate))
enum  {
	VALA_TYPEREGISTER_FUNCTION_DUMMY_PROPERTY
};
void vala_typeregister_function_init_from_type (ValaTypeRegisterFunction* self, gboolean plugin);
ValaCodeContext* vala_typeregister_function_get_context (ValaTypeRegisterFunction* self);
ValaTypeSymbol* vala_typeregister_function_get_type_declaration (ValaTypeRegisterFunction* self);
ValaSymbolAccessibility vala_typeregister_function_get_accessibility (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_gtype_value_table_init_function_name (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_gtype_value_table_free_function_name (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_gtype_value_table_copy_function_name (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_gtype_value_table_peek_pointer_function_name (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_gtype_value_table_collect_value_function_name (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_gtype_value_table_lcopy_value_function_name (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_base_finalize_func_name (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_type_struct_name (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_base_init_func_name (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_class_init_func_name (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_class_finalize_func_name (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_instance_struct_size (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_instance_init_func_name (ValaTypeRegisterFunction* self);
ValaCCodeFragment* vala_typeregister_function_get_type_interface_init_declaration (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_parent_type_name (ValaTypeRegisterFunction* self);
char* vala_typeregister_function_get_type_flags (ValaTypeRegisterFunction* self);
ValaCCodeFragment* vala_typeregister_function_get_type_interface_init_statements (ValaTypeRegisterFunction* self, gboolean plugin);
static ValaTypeSymbol* vala_typeregister_function_real_get_type_declaration (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_type_struct_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_base_init_func_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_class_finalize_func_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_base_finalize_func_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_class_init_func_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_instance_struct_size (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_instance_init_func_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_parent_type_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_gtype_value_table_init_function_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_gtype_value_table_peek_pointer_function_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_gtype_value_table_free_function_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_gtype_value_table_copy_function_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_gtype_value_table_lcopy_value_function_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_gtype_value_table_collect_value_function_name (ValaTypeRegisterFunction* self);
static char* vala_typeregister_function_real_get_type_flags (ValaTypeRegisterFunction* self);
static ValaCCodeFragment* vala_typeregister_function_real_get_type_interface_init_declaration (ValaTypeRegisterFunction* self);
static ValaCCodeFragment* vala_typeregister_function_real_get_type_interface_init_statements (ValaTypeRegisterFunction* self, gboolean plugin);
ValaCCodeFragment* vala_typeregister_function_get_source_declaration (ValaTypeRegisterFunction* self);
ValaCCodeFragment* vala_typeregister_function_get_declaration (ValaTypeRegisterFunction* self);
ValaCCodeFragment* vala_typeregister_function_get_definition (ValaTypeRegisterFunction* self);
static ValaSymbolAccessibility vala_typeregister_function_real_get_accessibility (ValaTypeRegisterFunction* self);
ValaTypeRegisterFunction* vala_typeregister_function_construct (GType object_type);
void vala_typeregister_function_set_context (ValaTypeRegisterFunction* self, ValaCodeContext* value);
static void vala_typeregister_function_finalize (ValaTypeRegisterFunction* obj);



/**
 * Constructs the C function from the specified type.
 */
static gpointer _vala_ccode_node_ref0 (gpointer self) {
	return self ? vala_ccode_node_ref (self) : NULL;
}


void vala_typeregister_function_init_from_type (ValaTypeRegisterFunction* self, gboolean plugin) {
	gboolean _tmp0_ = FALSE;
	gboolean use_thread_safe;
	gboolean fundamental;
	ValaTypeSymbol* _tmp1_;
	ValaClass* cl;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_ = FALSE;
	ValaTypeSymbol* _tmp4_;
	char* _tmp5_;
	char* _tmp6_;
	char* type_id_name;
	ValaCCodeBlock* type_block;
	ValaCCodeDeclaration* _cdecl_;
	ValaCCodeFunction* fun;
	char* type_value_table_decl_name;
	ValaCCodeBlock* type_init;
	ValaTypeSymbol* _tmp43_;
	gboolean _tmp44_;
	ValaCCodeFragment* _tmp59_;
	gboolean _tmp60_ = FALSE;
	gboolean _tmp61_ = FALSE;
	ValaCCodeFunctionCall* reg_call;
	ValaTypeSymbol* _tmp76_;
	gboolean _tmp77_;
	ValaTypeSymbol* _tmp100_;
	char* _tmp101_;
	char* _tmp102_;
	ValaCCodeConstant* _tmp103_;
	ValaTypeSymbol* _tmp104_;
	gboolean _tmp105_;
	gboolean _tmp135_ = FALSE;
	gboolean _tmp140_ = FALSE;
	gboolean _tmp141_ = FALSE;
	ValaCCodeFragment* _tmp150_;
	ValaCCodeFunction* _tmp175_;
	g_return_if_fail (self != NULL);
	if (vala_code_context_require_glib_version (self->priv->_context, 2, 14)) {
		_tmp0_ = !plugin;
	} else {
		_tmp0_ = FALSE;
	}
	use_thread_safe = _tmp0_;
	fundamental = FALSE;
	cl = (_tmp1_ = vala_typeregister_function_get_type_declaration (self), VALA_IS_CLASS (_tmp1_) ? ((ValaClass*) _tmp1_) : NULL);
	if (cl != NULL) {
		_tmp3_ = !vala_class_get_is_compact (cl);
	} else {
		_tmp3_ = FALSE;
	}
	if (_tmp3_) {
		_tmp2_ = vala_class_get_base_class (cl) == NULL;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		fundamental = TRUE;
	}
	type_id_name = (_tmp6_ = g_strdup_printf ("%s_type_id", _tmp5_ = vala_symbol_get_lower_case_cname ((ValaSymbol*) (_tmp4_ = vala_typeregister_function_get_type_declaration (self)), NULL)), _g_free0 (_tmp5_), _vala_code_node_unref0 (_tmp4_), _tmp6_);
	type_block = vala_ccode_block_new ();
	_cdecl_ = NULL;
	if (use_thread_safe) {
		ValaCCodeDeclaration* _tmp7_;
		char* _tmp8_;
		ValaCCodeConstant* _tmp9_;
		ValaCCodeVariableDeclarator* _tmp10_;
		_cdecl_ = (_tmp7_ = vala_ccode_declaration_new ("gsize"), _vala_ccode_node_unref0 (_cdecl_), _tmp7_);
		vala_ccode_declaration_add_declarator (_cdecl_, (ValaCCodeDeclarator*) (_tmp10_ = vala_ccode_variable_declarator_new (_tmp8_ = g_strconcat (type_id_name, "__volatile", NULL), (ValaCCodeExpression*) (_tmp9_ = vala_ccode_constant_new ("0")), NULL)));
		_vala_ccode_node_unref0 (_tmp10_);
		_vala_ccode_node_unref0 (_tmp9_);
		_g_free0 (_tmp8_);
	} else {
		ValaCCodeDeclaration* _tmp11_;
		ValaCCodeConstant* _tmp12_;
		ValaCCodeVariableDeclarator* _tmp13_;
		_cdecl_ = (_tmp11_ = vala_ccode_declaration_new ("GType"), _vala_ccode_node_unref0 (_cdecl_), _tmp11_);
		vala_ccode_declaration_add_declarator (_cdecl_, (ValaCCodeDeclarator*) (_tmp13_ = vala_ccode_variable_declarator_new (type_id_name, (ValaCCodeExpression*) (_tmp12_ = vala_ccode_constant_new ("0")), NULL)));
		_vala_ccode_node_unref0 (_tmp13_);
		_vala_ccode_node_unref0 (_tmp12_);
	}
	vala_ccode_declaration_set_modifiers (_cdecl_, VALA_CCODE_MODIFIERS_STATIC);
	if (use_thread_safe) {
		vala_ccode_declaration_set_modifiers (_cdecl_, vala_ccode_declaration_get_modifiers (_cdecl_) | VALA_CCODE_MODIFIERS_VOLATILE);
	}
	if (!plugin) {
		vala_ccode_block_add_statement (type_block, (ValaCCodeNode*) _cdecl_);
	} else {
		vala_ccode_fragment_append (self->priv->source_declaration_fragment, (ValaCCodeNode*) _cdecl_);
	}
	fun = NULL;
	if (!plugin) {
		ValaTypeSymbol* _tmp14_;
		char* _tmp15_;
		char* _tmp16_;
		ValaCCodeFunction* _tmp17_;
		fun = (_tmp17_ = vala_ccode_function_new (_tmp16_ = g_strdup_printf ("%s_get_type", _tmp15_ = vala_symbol_get_lower_case_cname ((ValaSymbol*) (_tmp14_ = vala_typeregister_function_get_type_declaration (self)), NULL)), "GType"), _vala_ccode_node_unref0 (fun), _tmp17_);
		_g_free0 (_tmp16_);
		_g_free0 (_tmp15_);
		_vala_code_node_unref0 (_tmp14_);
		vala_ccode_function_set_attributes (fun, "G_GNUC_CONST");
		if (vala_typeregister_function_get_accessibility (self) == VALA_SYMBOL_ACCESSIBILITY_PRIVATE) {
			char* _tmp18_;
			vala_ccode_function_set_modifiers (fun, VALA_CCODE_MODIFIERS_STATIC);
			vala_ccode_function_set_attributes (fun, _tmp18_ = g_strconcat (vala_ccode_function_get_attributes (fun), " G_GNUC_UNUSED", NULL));
			_g_free0 (_tmp18_);
		}
	} else {
		ValaTypeSymbol* _tmp19_;
		char* _tmp20_;
		char* _tmp21_;
		ValaCCodeFunction* _tmp22_;
		ValaCCodeFormalParameter* _tmp23_;
		ValaTypeSymbol* _tmp24_;
		char* _tmp25_;
		char* _tmp26_;
		ValaCCodeFunction* _tmp27_;
		ValaCCodeFunction* get_fun;
		ValaCCodeFunction* _tmp28_;
		ValaCCodeBlock* _tmp29_;
		ValaCCodeIdentifier* _tmp30_;
		ValaCCodeReturnStatement* _tmp31_;
		fun = (_tmp22_ = vala_ccode_function_new (_tmp21_ = g_strdup_printf ("%s_register_type", _tmp20_ = vala_symbol_get_lower_case_cname ((ValaSymbol*) (_tmp19_ = vala_typeregister_function_get_type_declaration (self)), NULL)), "GType"), _vala_ccode_node_unref0 (fun), _tmp22_);
		_g_free0 (_tmp21_);
		_g_free0 (_tmp20_);
		_vala_code_node_unref0 (_tmp19_);
		vala_ccode_function_add_parameter (fun, _tmp23_ = vala_ccode_formal_parameter_new ("module", "GTypeModule *"));
		_vala_ccode_node_unref0 (_tmp23_);
		get_fun = (_tmp27_ = vala_ccode_function_new (_tmp26_ = g_strdup_printf ("%s_get_type", _tmp25_ = vala_symbol_get_lower_case_cname ((ValaSymbol*) (_tmp24_ = vala_typeregister_function_get_type_declaration (self)), NULL)), "GType"), _g_free0 (_tmp26_), _g_free0 (_tmp25_), _vala_code_node_unref0 (_tmp24_), _tmp27_);
		vala_ccode_function_set_attributes (get_fun, "G_GNUC_CONST");
		vala_ccode_fragment_append (self->priv->declaration_fragment, (ValaCCodeNode*) (_tmp28_ = vala_ccode_function_copy (get_fun)));
		_vala_ccode_node_unref0 (_tmp28_);
		vala_ccode_function_set_block (get_fun, _tmp29_ = vala_ccode_block_new ());
		_vala_ccode_node_unref0 (_tmp29_);
		vala_ccode_block_add_statement (vala_ccode_function_get_block (get_fun), (ValaCCodeNode*) (_tmp31_ = vala_ccode_return_statement_new ((ValaCCodeExpression*) (_tmp30_ = vala_ccode_identifier_new (type_id_name)))));
		_vala_ccode_node_unref0 (_tmp31_);
		_vala_ccode_node_unref0 (_tmp30_);
		vala_ccode_fragment_append (self->priv->definition_fragment, (ValaCCodeNode*) get_fun);
		_vala_ccode_node_unref0 (get_fun);
	}
	type_value_table_decl_name = NULL;
	type_init = vala_ccode_block_new ();
	if (fundamental) {
		ValaCCodeDeclaration* cgtypetabledecl;
		char* _tmp32_;
		char* _tmp33_;
		char* _tmp34_;
		char* _tmp35_;
		char* _tmp36_;
		char* _tmp37_;
		char* _tmp38_;
		ValaCCodeConstant* _tmp39_;
		ValaCCodeVariableDeclarator* _tmp40_;
		char* _tmp41_;
		cgtypetabledecl = vala_ccode_declaration_new ("const GTypeValueTable");
		vala_ccode_declaration_set_modifiers (cgtypetabledecl, VALA_CCODE_MODIFIERS_STATIC);
		vala_ccode_declaration_add_declarator (cgtypetabledecl, (ValaCCodeDeclarator*) (_tmp40_ = vala_ccode_variable_declarator_new ("g_define_type_value_table", (ValaCCodeExpression*) (_tmp39_ = vala_ccode_constant_new (_tmp38_ = g_strdup_printf ("{ %s, %s, %s, %s, \"p\", %s, \"p\", %s }", _tmp32_ = vala_typeregister_function_get_gtype_value_table_init_function_name (self), _tmp33_ = vala_typeregister_function_get_gtype_value_table_free_function_name (self), _tmp34_ = vala_typeregister_function_get_gtype_value_table_copy_function_name (self), _tmp35_ = vala_typeregister_function_get_gtype_value_table_peek_pointer_function_name (self), _tmp36_ = vala_typeregister_function_get_gtype_value_table_collect_value_function_name (self), _tmp37_ = vala_typeregister_function_get_gtype_value_table_lcopy_value_function_name (self)))), NULL)));
		_vala_ccode_node_unref0 (_tmp40_);
		_vala_ccode_node_unref0 (_tmp39_);
		_g_free0 (_tmp38_);
		_g_free0 (_tmp37_);
		_g_free0 (_tmp36_);
		_g_free0 (_tmp35_);
		_g_free0 (_tmp34_);
		_g_free0 (_tmp33_);
		_g_free0 (_tmp32_);
		type_value_table_decl_name = (_tmp41_ = g_strdup ("&g_define_type_value_table"), _g_free0 (type_value_table_decl_name), _tmp41_);
		vala_ccode_block_add_statement (type_init, (ValaCCodeNode*) cgtypetabledecl);
		_vala_ccode_node_unref0 (cgtypetabledecl);
	} else {
		char* _tmp42_;
		type_value_table_decl_name = (_tmp42_ = g_strdup ("NULL"), _g_free0 (type_value_table_decl_name), _tmp42_);
	}
	if ((_tmp44_ = VALA_IS_OBJECT_TYPE_SYMBOL (_tmp43_ = vala_typeregister_function_get_type_declaration (self)), _vala_code_node_unref0 (_tmp43_), _tmp44_)) {
		ValaCCodeDeclaration* ctypedecl;
		char* _tmp45_;
		char* _tmp48_;
		char* _tmp49_;
		char* _tmp50_;
		char* _tmp51_;
		char* _tmp52_;
		char* _tmp53_;
		char* _tmp54_;
		ValaCCodeConstant* _tmp55_;
		ValaCCodeVariableDeclarator* _tmp56_;
		ctypedecl = vala_ccode_declaration_new ("const GTypeInfo");
		vala_ccode_declaration_set_modifiers (ctypedecl, VALA_CCODE_MODIFIERS_STATIC);
		_tmp45_ = NULL;
		if (plugin) {
			char* _tmp46_;
			_tmp45_ = (_tmp46_ = vala_typeregister_function_get_base_finalize_func_name (self), _g_free0 (_tmp45_), _tmp46_);
		} else {
			char* _tmp47_;
			_tmp45_ = (_tmp47_ = g_strdup ("NULL"), _g_free0 (_tmp45_), _tmp47_);
		}
		vala_ccode_declaration_add_declarator (ctypedecl, (ValaCCodeDeclarator*) (_tmp56_ = vala_ccode_variable_declarator_new ("g_define_type_info", (ValaCCodeExpression*) (_tmp55_ = vala_ccode_constant_new (_tmp54_ = g_strdup_printf ("{ sizeof (%s), (GBaseInitFunc) %s, (GBaseFinalizeFunc) %s, (GClassInit" \
"Func) %s, (GClassFinalizeFunc) %s, NULL, %s, 0, (GInstanceInitFunc) %s" \
", %s }", _tmp48_ = vala_typeregister_function_get_type_struct_name (self), _tmp49_ = vala_typeregister_function_get_base_init_func_name (self), _tmp45_, _tmp50_ = vala_typeregister_function_get_class_init_func_name (self), _tmp51_ = vala_typeregister_function_get_class_finalize_func_name (self), _tmp52_ = vala_typeregister_function_get_instance_struct_size (self), _tmp53_ = vala_typeregister_function_get_instance_init_func_name (self), type_value_table_decl_name))), NULL)));
		_vala_ccode_node_unref0 (_tmp56_);
		_vala_ccode_node_unref0 (_tmp55_);
		_g_free0 (_tmp54_);
		_g_free0 (_tmp53_);
		_g_free0 (_tmp52_);
		_g_free0 (_tmp51_);
		_g_free0 (_tmp50_);
		_g_free0 (_tmp49_);
		_g_free0 (_tmp48_);
		vala_ccode_block_add_statement (type_init, (ValaCCodeNode*) ctypedecl);
		if (fundamental) {
			ValaCCodeDeclaration* ctypefundamentaldecl;
			ValaCCodeConstant* _tmp57_;
			ValaCCodeVariableDeclarator* _tmp58_;
			ctypefundamentaldecl = vala_ccode_declaration_new ("const GTypeFundamentalInfo");
			vala_ccode_declaration_set_modifiers (ctypefundamentaldecl, VALA_CCODE_MODIFIERS_STATIC);
			vala_ccode_declaration_add_declarator (ctypefundamentaldecl, (ValaCCodeDeclarator*) (_tmp58_ = vala_ccode_variable_declarator_new ("g_define_type_fundamental_info", (ValaCCodeExpression*) (_tmp57_ = vala_ccode_constant_new ("{ (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERI" \
"VABLE | G_TYPE_FLAG_DEEP_DERIVABLE) }")), NULL)));
			_vala_ccode_node_unref0 (_tmp58_);
			_vala_ccode_node_unref0 (_tmp57_);
			vala_ccode_block_add_statement (type_init, (ValaCCodeNode*) ctypefundamentaldecl);
			_vala_ccode_node_unref0 (ctypefundamentaldecl);
		}
		_g_free0 (_tmp45_);
		_vala_ccode_node_unref0 (ctypedecl);
	}
	vala_ccode_block_add_statement (type_init, (ValaCCodeNode*) (_tmp59_ = vala_typeregister_function_get_type_interface_init_declaration (self)));
	_vala_ccode_node_unref0 (_tmp59_);
	if (cl != NULL) {
		_tmp61_ = vala_class_get_has_class_private_fields (cl);
	} else {
		_tmp61_ = FALSE;
	}
	if (_tmp61_) {
		_tmp60_ = !vala_code_context_require_glib_version (self->priv->_context, 2, 24);
	} else {
		_tmp60_ = FALSE;
	}
	if (_tmp60_) {
		ValaCCodeFunctionCall* quark_reg_call;
		ValaTypeSymbol* _tmp66_;
		char* _tmp67_;
		char* _tmp68_;
		ValaCCodeConstant* _tmp69_;
		ValaTypeSymbol* _tmp70_;
		char* _tmp71_;
		char* _tmp72_;
		ValaCCodeIdentifier* _tmp73_;
		ValaCCodeAssignment* _tmp74_;
		ValaCCodeExpressionStatement* _tmp75_;
		quark_reg_call = NULL;
		if (plugin) {
			ValaCCodeIdentifier* _tmp62_;
			ValaCCodeFunctionCall* _tmp63_;
			quark_reg_call = (_tmp63_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp62_ = vala_ccode_identifier_new ("g_quark_from_string"))), _vala_ccode_node_unref0 (quark_reg_call), _tmp63_);
			_vala_ccode_node_unref0 (_tmp62_);
		} else {
			ValaCCodeIdentifier* _tmp64_;
			ValaCCodeFunctionCall* _tmp65_;
			quark_reg_call = (_tmp65_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp64_ = vala_ccode_identifier_new ("g_quark_from_static_string"))), _vala_ccode_node_unref0 (quark_reg_call), _tmp65_);
			_vala_ccode_node_unref0 (_tmp64_);
		}
		vala_ccode_function_call_add_argument (quark_reg_call, (ValaCCodeExpression*) (_tmp69_ = vala_ccode_constant_new (_tmp68_ = g_strdup_printf ("\"Vala%sClassPrivate\"", _tmp67_ = vala_typesymbol_get_cname (_tmp66_ = vala_typeregister_function_get_type_declaration (self), FALSE)))));
		_vala_ccode_node_unref0 (_tmp69_);
		_g_free0 (_tmp68_);
		_g_free0 (_tmp67_);
		_vala_code_node_unref0 (_tmp66_);
		vala_ccode_block_add_statement (type_init, (ValaCCodeNode*) (_tmp75_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) (_tmp74_ = vala_ccode_assignment_new ((ValaCCodeExpression*) (_tmp73_ = vala_ccode_identifier_new (_tmp72_ = g_strdup_printf ("_vala_%s_class_private_quark", _tmp71_ = vala_symbol_get_lower_case_cname ((ValaSymbol*) (_tmp70_ = vala_typeregister_function_get_type_declaration (self)), NULL)))), (ValaCCodeExpression*) quark_reg_call, VALA_CCODE_ASSIGNMENT_OPERATOR_SIMPLE)))));
		_vala_ccode_node_unref0 (_tmp75_);
		_vala_ccode_node_unref0 (_tmp74_);
		_vala_ccode_node_unref0 (_tmp73_);
		_g_free0 (_tmp72_);
		_g_free0 (_tmp71_);
		_vala_code_node_unref0 (_tmp70_);
		_vala_ccode_node_unref0 (quark_reg_call);
	}
	reg_call = NULL;
	if ((_tmp77_ = VALA_IS_STRUCT (_tmp76_ = vala_typeregister_function_get_type_declaration (self)), _vala_code_node_unref0 (_tmp76_), _tmp77_)) {
		ValaCCodeIdentifier* _tmp78_;
		ValaCCodeFunctionCall* _tmp79_;
		reg_call = (_tmp79_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp78_ = vala_ccode_identifier_new ("g_boxed_type_register_static"))), _vala_ccode_node_unref0 (reg_call), _tmp79_);
		_vala_ccode_node_unref0 (_tmp78_);
	} else {
		ValaTypeSymbol* _tmp80_;
		gboolean _tmp81_;
		if ((_tmp81_ = VALA_IS_ENUM (_tmp80_ = vala_typeregister_function_get_type_declaration (self)), _vala_code_node_unref0 (_tmp80_), _tmp81_)) {
			ValaTypeSymbol* _tmp82_;
			ValaEnum* en;
			en = (_tmp82_ = vala_typeregister_function_get_type_declaration (self), VALA_IS_ENUM (_tmp82_) ? ((ValaEnum*) _tmp82_) : NULL);
			if (vala_enum_get_is_flags (en)) {
				ValaCCodeIdentifier* _tmp83_;
				ValaCCodeFunctionCall* _tmp84_;
				reg_call = (_tmp84_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp83_ = vala_ccode_identifier_new ("g_flags_register_static"))), _vala_ccode_node_unref0 (reg_call), _tmp84_);
				_vala_ccode_node_unref0 (_tmp83_);
			} else {
				ValaCCodeIdentifier* _tmp85_;
				ValaCCodeFunctionCall* _tmp86_;
				reg_call = (_tmp86_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp85_ = vala_ccode_identifier_new ("g_enum_register_static"))), _vala_ccode_node_unref0 (reg_call), _tmp86_);
				_vala_ccode_node_unref0 (_tmp85_);
			}
			_vala_code_node_unref0 (en);
		} else {
			if (fundamental) {
				ValaCCodeIdentifier* _tmp87_;
				ValaCCodeFunctionCall* _tmp88_;
				ValaCCodeIdentifier* _tmp89_;
				ValaCCodeFunctionCall* _tmp90_;
				reg_call = (_tmp88_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp87_ = vala_ccode_identifier_new ("g_type_register_fundamental"))), _vala_ccode_node_unref0 (reg_call), _tmp88_);
				_vala_ccode_node_unref0 (_tmp87_);
				vala_ccode_function_call_add_argument (reg_call, (ValaCCodeExpression*) (_tmp90_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp89_ = vala_ccode_identifier_new ("g_type_fundamental_next")))));
				_vala_ccode_node_unref0 (_tmp90_);
				_vala_ccode_node_unref0 (_tmp89_);
			} else {
				if (!plugin) {
					ValaCCodeIdentifier* _tmp91_;
					ValaCCodeFunctionCall* _tmp92_;
					char* _tmp93_;
					ValaCCodeIdentifier* _tmp94_;
					reg_call = (_tmp92_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp91_ = vala_ccode_identifier_new ("g_type_register_static"))), _vala_ccode_node_unref0 (reg_call), _tmp92_);
					_vala_ccode_node_unref0 (_tmp91_);
					vala_ccode_function_call_add_argument (reg_call, (ValaCCodeExpression*) (_tmp94_ = vala_ccode_identifier_new (_tmp93_ = vala_typeregister_function_get_parent_type_name (self))));
					_vala_ccode_node_unref0 (_tmp94_);
					_g_free0 (_tmp93_);
				} else {
					ValaCCodeIdentifier* _tmp95_;
					ValaCCodeFunctionCall* _tmp96_;
					ValaCCodeIdentifier* _tmp97_;
					char* _tmp98_;
					ValaCCodeIdentifier* _tmp99_;
					reg_call = (_tmp96_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp95_ = vala_ccode_identifier_new ("g_type_module_register_type"))), _vala_ccode_node_unref0 (reg_call), _tmp96_);
					_vala_ccode_node_unref0 (_tmp95_);
					vala_ccode_function_call_add_argument (reg_call, (ValaCCodeExpression*) (_tmp97_ = vala_ccode_identifier_new ("module")));
					_vala_ccode_node_unref0 (_tmp97_);
					vala_ccode_function_call_add_argument (reg_call, (ValaCCodeExpression*) (_tmp99_ = vala_ccode_identifier_new (_tmp98_ = vala_typeregister_function_get_parent_type_name (self))));
					_vala_ccode_node_unref0 (_tmp99_);
					_g_free0 (_tmp98_);
				}
			}
		}
	}
	vala_ccode_function_call_add_argument (reg_call, (ValaCCodeExpression*) (_tmp103_ = vala_ccode_constant_new (_tmp102_ = g_strdup_printf ("\"%s\"", _tmp101_ = vala_typesymbol_get_cname (_tmp100_ = vala_typeregister_function_get_type_declaration (self), FALSE)))));
	_vala_ccode_node_unref0 (_tmp103_);
	_g_free0 (_tmp102_);
	_g_free0 (_tmp101_);
	_vala_code_node_unref0 (_tmp100_);
	if ((_tmp105_ = VALA_IS_STRUCT (_tmp104_ = vala_typeregister_function_get_type_declaration (self)), _vala_code_node_unref0 (_tmp104_), _tmp105_)) {
		ValaStruct* st;
		char* _tmp106_;
		ValaCCodeIdentifier* _tmp107_;
		ValaCCodeCastExpression* _tmp108_;
		char* _tmp109_;
		ValaCCodeIdentifier* _tmp110_;
		ValaCCodeCastExpression* _tmp111_;
		st = VALA_STRUCT (vala_typeregister_function_get_type_declaration (self));
		vala_ccode_function_call_add_argument (reg_call, (ValaCCodeExpression*) (_tmp108_ = vala_ccode_cast_expression_new ((ValaCCodeExpression*) (_tmp107_ = vala_ccode_identifier_new (_tmp106_ = vala_typesymbol_get_dup_function ((ValaTypeSymbol*) st))), "GBoxedCopyFunc")));
		_vala_ccode_node_unref0 (_tmp108_);
		_vala_ccode_node_unref0 (_tmp107_);
		_g_free0 (_tmp106_);
		vala_ccode_function_call_add_argument (reg_call, (ValaCCodeExpression*) (_tmp111_ = vala_ccode_cast_expression_new ((ValaCCodeExpression*) (_tmp110_ = vala_ccode_identifier_new (_tmp109_ = vala_typesymbol_get_free_function ((ValaTypeSymbol*) st))), "GBoxedFreeFunc")));
		_vala_ccode_node_unref0 (_tmp111_);
		_vala_ccode_node_unref0 (_tmp110_);
		_g_free0 (_tmp109_);
		_vala_code_node_unref0 (st);
	} else {
		ValaTypeSymbol* _tmp112_;
		gboolean _tmp113_;
		if ((_tmp113_ = VALA_IS_ENUM (_tmp112_ = vala_typeregister_function_get_type_declaration (self)), _vala_code_node_unref0 (_tmp112_), _tmp113_)) {
			ValaTypeSymbol* _tmp114_;
			ValaEnum* en;
			ValaCCodeInitializerList* clist;
			ValaCCodeInitializerList* clist_ev;
			ValaCCodeInitializerList* _tmp124_;
			ValaCCodeConstant* _tmp125_;
			ValaCCodeConstant* _tmp126_;
			ValaCCodeConstant* _tmp127_;
			ValaCCodeVariableDeclarator* enum_decl;
			ValaCCodeIdentifier* _tmp130_;
			en = (_tmp114_ = vala_typeregister_function_get_type_declaration (self), VALA_IS_ENUM (_tmp114_) ? ((ValaEnum*) _tmp114_) : NULL);
			clist = vala_ccode_initializer_list_new ();
			clist_ev = NULL;
			{
				ValaList* _tmp115_;
				ValaIterator* _tmp116_;
				ValaIterator* _ev_it;
				_ev_it = (_tmp116_ = vala_iterable_iterator ((ValaIterable*) (_tmp115_ = vala_enum_get_values (en))), _vala_collection_object_unref0 (_tmp115_), _tmp116_);
				while (TRUE) {
					ValaEnumValue* ev;
					ValaCCodeInitializerList* _tmp117_;
					char* _tmp118_;
					ValaCCodeConstant* _tmp119_;
					char* _tmp120_;
					char* _tmp121_;
					ValaCCodeIdentifier* _tmp122_;
					ValaCCodeConstant* _tmp123_;
					if (!vala_iterator_next (_ev_it)) {
						break;
					}
					ev = (ValaEnumValue*) vala_iterator_get (_ev_it);
					clist_ev = (_tmp117_ = vala_ccode_initializer_list_new (), _vala_ccode_node_unref0 (clist_ev), _tmp117_);
					vala_ccode_initializer_list_append (clist_ev, (ValaCCodeExpression*) (_tmp119_ = vala_ccode_constant_new (_tmp118_ = vala_constant_get_cname ((ValaConstant*) ev))));
					_vala_ccode_node_unref0 (_tmp119_);
					_g_free0 (_tmp118_);
					vala_ccode_initializer_list_append (clist_ev, (ValaCCodeExpression*) (_tmp122_ = vala_ccode_identifier_new (_tmp121_ = g_strdup_printf ("\"%s\"", _tmp120_ = vala_constant_get_cname ((ValaConstant*) ev)))));
					_vala_ccode_node_unref0 (_tmp122_);
					_g_free0 (_tmp121_);
					_g_free0 (_tmp120_);
					vala_ccode_initializer_list_append (clist_ev, (ValaCCodeExpression*) (_tmp123_ = vala_enum_value_get_canonical_cconstant (ev)));
					_vala_ccode_node_unref0 (_tmp123_);
					vala_ccode_initializer_list_append (clist, (ValaCCodeExpression*) clist_ev);
					_vala_code_node_unref0 (ev);
				}
				_vala_collection_object_unref0 (_ev_it);
			}
			clist_ev = (_tmp124_ = vala_ccode_initializer_list_new (), _vala_ccode_node_unref0 (clist_ev), _tmp124_);
			vala_ccode_initializer_list_append (clist_ev, (ValaCCodeExpression*) (_tmp125_ = vala_ccode_constant_new ("0")));
			_vala_ccode_node_unref0 (_tmp125_);
			vala_ccode_initializer_list_append (clist_ev, (ValaCCodeExpression*) (_tmp126_ = vala_ccode_constant_new ("NULL")));
			_vala_ccode_node_unref0 (_tmp126_);
			vala_ccode_initializer_list_append (clist_ev, (ValaCCodeExpression*) (_tmp127_ = vala_ccode_constant_new ("NULL")));
			_vala_ccode_node_unref0 (_tmp127_);
			vala_ccode_initializer_list_append (clist, (ValaCCodeExpression*) clist_ev);
			enum_decl = vala_ccode_variable_declarator_new ("values[]", (ValaCCodeExpression*) clist, NULL);
			if (vala_enum_get_is_flags (en)) {
				ValaCCodeDeclaration* _tmp128_;
				_cdecl_ = (_tmp128_ = vala_ccode_declaration_new ("const GFlagsValue"), _vala_ccode_node_unref0 (_cdecl_), _tmp128_);
			} else {
				ValaCCodeDeclaration* _tmp129_;
				_cdecl_ = (_tmp129_ = vala_ccode_declaration_new ("const GEnumValue"), _vala_ccode_node_unref0 (_cdecl_), _tmp129_);
			}
			vala_ccode_declaration_add_declarator (_cdecl_, (ValaCCodeDeclarator*) enum_decl);
			vala_ccode_declaration_set_modifiers (_cdecl_, VALA_CCODE_MODIFIERS_STATIC);
			vala_ccode_block_add_statement (type_init, (ValaCCodeNode*) _cdecl_);
			vala_ccode_function_call_add_argument (reg_call, (ValaCCodeExpression*) (_tmp130_ = vala_ccode_identifier_new ("values")));
			_vala_ccode_node_unref0 (_tmp130_);
			_vala_ccode_node_unref0 (enum_decl);
			_vala_ccode_node_unref0 (clist_ev);
			_vala_ccode_node_unref0 (clist);
			_vala_code_node_unref0 (en);
		} else {
			ValaCCodeIdentifier* _tmp131_;
			char* _tmp133_;
			ValaCCodeConstant* _tmp134_;
			vala_ccode_function_call_add_argument (reg_call, (ValaCCodeExpression*) (_tmp131_ = vala_ccode_identifier_new ("&g_define_type_info")));
			_vala_ccode_node_unref0 (_tmp131_);
			if (fundamental) {
				ValaCCodeIdentifier* _tmp132_;
				vala_ccode_function_call_add_argument (reg_call, (ValaCCodeExpression*) (_tmp132_ = vala_ccode_identifier_new ("&g_define_type_fundamental_info")));
				_vala_ccode_node_unref0 (_tmp132_);
			}
			vala_ccode_function_call_add_argument (reg_call, (ValaCCodeExpression*) (_tmp134_ = vala_ccode_constant_new (_tmp133_ = vala_typeregister_function_get_type_flags (self))));
			_vala_ccode_node_unref0 (_tmp134_);
			_g_free0 (_tmp133_);
		}
	}
	if (use_thread_safe) {
		_tmp135_ = !plugin;
	} else {
		_tmp135_ = FALSE;
	}
	if (_tmp135_) {
		ValaCCodeDeclaration* temp_decl;
		ValaCCodeVariableDeclarator* _tmp136_;
		temp_decl = vala_ccode_declaration_new ("GType");
		vala_ccode_declaration_add_declarator (temp_decl, (ValaCCodeDeclarator*) (_tmp136_ = vala_ccode_variable_declarator_new (type_id_name, (ValaCCodeExpression*) reg_call, NULL)));
		_vala_ccode_node_unref0 (_tmp136_);
		vala_ccode_block_add_statement (type_init, (ValaCCodeNode*) temp_decl);
		_vala_ccode_node_unref0 (temp_decl);
	} else {
		ValaCCodeIdentifier* _tmp137_;
		ValaCCodeAssignment* _tmp138_;
		ValaCCodeExpressionStatement* _tmp139_;
		vala_ccode_block_add_statement (type_init, (ValaCCodeNode*) (_tmp139_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) (_tmp138_ = vala_ccode_assignment_new ((ValaCCodeExpression*) (_tmp137_ = vala_ccode_identifier_new (type_id_name)), (ValaCCodeExpression*) reg_call, VALA_CCODE_ASSIGNMENT_OPERATOR_SIMPLE)))));
		_vala_ccode_node_unref0 (_tmp139_);
		_vala_ccode_node_unref0 (_tmp138_);
		_vala_ccode_node_unref0 (_tmp137_);
	}
	if (cl != NULL) {
		_tmp141_ = vala_class_get_has_class_private_fields (cl);
	} else {
		_tmp141_ = FALSE;
	}
	if (_tmp141_) {
		_tmp140_ = vala_code_context_require_glib_version (self->priv->_context, 2, 24);
	} else {
		_tmp140_ = FALSE;
	}
	if (_tmp140_) {
		ValaCCodeFunctionCall* add_class_private_call;
		ValaCCodeIdentifier* _tmp142_;
		ValaCCodeFunctionCall* _tmp143_;
		ValaCCodeIdentifier* _tmp144_;
		ValaTypeSymbol* _tmp145_;
		char* _tmp146_;
		char* _tmp147_;
		ValaCCodeIdentifier* _tmp148_;
		ValaCCodeExpressionStatement* _tmp149_;
		add_class_private_call = NULL;
		add_class_private_call = (_tmp143_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp142_ = vala_ccode_identifier_new ("g_type_add_class_private"))), _vala_ccode_node_unref0 (add_class_private_call), _tmp143_);
		_vala_ccode_node_unref0 (_tmp142_);
		vala_ccode_function_call_add_argument (add_class_private_call, (ValaCCodeExpression*) (_tmp144_ = vala_ccode_identifier_new (type_id_name)));
		_vala_ccode_node_unref0 (_tmp144_);
		vala_ccode_function_call_add_argument (add_class_private_call, (ValaCCodeExpression*) (_tmp148_ = vala_ccode_identifier_new (_tmp147_ = g_strdup_printf ("sizeof (%sClassPrivate)", _tmp146_ = vala_typesymbol_get_cname (_tmp145_ = vala_typeregister_function_get_type_declaration (self), FALSE)))));
		_vala_ccode_node_unref0 (_tmp148_);
		_g_free0 (_tmp147_);
		_g_free0 (_tmp146_);
		_vala_code_node_unref0 (_tmp145_);
		vala_ccode_block_add_statement (type_init, (ValaCCodeNode*) (_tmp149_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) add_class_private_call)));
		_vala_ccode_node_unref0 (_tmp149_);
		_vala_ccode_node_unref0 (add_class_private_call);
	}
	vala_ccode_block_add_statement (type_init, (ValaCCodeNode*) (_tmp150_ = vala_typeregister_function_get_type_interface_init_statements (self, plugin)));
	_vala_ccode_node_unref0 (_tmp150_);
	if (!plugin) {
		ValaCCodeExpression* condition;
		ValaCCodeExpression* cond;
		ValaCCodeIfStatement* cif;
		condition = NULL;
		if (use_thread_safe) {
			ValaCCodeIdentifier* _tmp151_;
			ValaCCodeFunctionCall* _tmp152_;
			ValaCCodeFunctionCall* enter;
			char* _tmp153_;
			ValaCCodeIdentifier* _tmp154_;
			ValaCCodeUnaryExpression* _tmp155_;
			ValaCCodeExpression* _tmp156_;
			ValaCCodeIdentifier* _tmp157_;
			ValaCCodeFunctionCall* _tmp158_;
			ValaCCodeFunctionCall* leave;
			char* _tmp159_;
			ValaCCodeIdentifier* _tmp160_;
			ValaCCodeUnaryExpression* _tmp161_;
			ValaCCodeIdentifier* _tmp162_;
			ValaCCodeExpressionStatement* _tmp163_;
			enter = (_tmp152_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp151_ = vala_ccode_identifier_new ("g_once_init_enter"))), _vala_ccode_node_unref0 (_tmp151_), _tmp152_);
			vala_ccode_function_call_add_argument (enter, (ValaCCodeExpression*) (_tmp155_ = vala_ccode_unary_expression_new (VALA_CCODE_UNARY_OPERATOR_ADDRESS_OF, (ValaCCodeExpression*) (_tmp154_ = vala_ccode_identifier_new (_tmp153_ = g_strconcat (type_id_name, "__volatile", NULL))))));
			_vala_ccode_node_unref0 (_tmp155_);
			_vala_ccode_node_unref0 (_tmp154_);
			_g_free0 (_tmp153_);
			condition = (_tmp156_ = _vala_ccode_node_ref0 ((ValaCCodeExpression*) enter), _vala_ccode_node_unref0 (condition), _tmp156_);
			leave = (_tmp158_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp157_ = vala_ccode_identifier_new ("g_once_init_leave"))), _vala_ccode_node_unref0 (_tmp157_), _tmp158_);
			vala_ccode_function_call_add_argument (leave, (ValaCCodeExpression*) (_tmp161_ = vala_ccode_unary_expression_new (VALA_CCODE_UNARY_OPERATOR_ADDRESS_OF, (ValaCCodeExpression*) (_tmp160_ = vala_ccode_identifier_new (_tmp159_ = g_strconcat (type_id_name, "__volatile", NULL))))));
			_vala_ccode_node_unref0 (_tmp161_);
			_vala_ccode_node_unref0 (_tmp160_);
			_g_free0 (_tmp159_);
			vala_ccode_function_call_add_argument (leave, (ValaCCodeExpression*) (_tmp162_ = vala_ccode_identifier_new (type_id_name)));
			_vala_ccode_node_unref0 (_tmp162_);
			vala_ccode_block_add_statement (type_init, (ValaCCodeNode*) (_tmp163_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) leave)));
			_vala_ccode_node_unref0 (_tmp163_);
			_vala_ccode_node_unref0 (leave);
			_vala_ccode_node_unref0 (enter);
		} else {
			ValaCCodeIdentifier* id;
			ValaCCodeConstant* zero;
			ValaCCodeExpression* _tmp164_;
			id = vala_ccode_identifier_new (type_id_name);
			zero = vala_ccode_constant_new ("0");
			condition = (_tmp164_ = (ValaCCodeExpression*) vala_ccode_binary_expression_new (VALA_CCODE_BINARY_OPERATOR_EQUALITY, (ValaCCodeExpression*) id, (ValaCCodeExpression*) zero), _vala_ccode_node_unref0 (condition), _tmp164_);
			_vala_ccode_node_unref0 (zero);
			_vala_ccode_node_unref0 (id);
		}
		cond = NULL;
		if (use_thread_safe) {
			ValaCCodeExpression* _tmp165_;
			cond = (_tmp165_ = _vala_ccode_node_ref0 (condition), _vala_ccode_node_unref0 (cond), _tmp165_);
		} else {
			ValaCCodeIdentifier* _tmp166_;
			ValaCCodeExpression* _tmp167_;
			ValaCCodeExpression* _tmp168_;
			cond = (_tmp167_ = (ValaCCodeExpression*) vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp166_ = vala_ccode_identifier_new ("G_UNLIKELY"))), _vala_ccode_node_unref0 (cond), _tmp167_);
			_vala_ccode_node_unref0 (_tmp166_);
			vala_ccode_function_call_add_argument ((_tmp168_ = cond, VALA_IS_CCODE_FUNCTION_CALL (_tmp168_) ? ((ValaCCodeFunctionCall*) _tmp168_) : NULL), condition);
		}
		cif = vala_ccode_if_statement_new (cond, (ValaCCodeStatement*) type_init, NULL);
		vala_ccode_block_add_statement (type_block, (ValaCCodeNode*) cif);
		_vala_ccode_node_unref0 (cif);
		_vala_ccode_node_unref0 (cond);
		_vala_ccode_node_unref0 (condition);
	} else {
		ValaCCodeBlock* _tmp169_;
		type_block = (_tmp169_ = _vala_ccode_node_ref0 (type_init), _vala_ccode_node_unref0 (type_block), _tmp169_);
	}
	if (use_thread_safe) {
		char* _tmp170_;
		ValaCCodeIdentifier* _tmp171_;
		ValaCCodeReturnStatement* _tmp172_;
		vala_ccode_block_add_statement (type_block, (ValaCCodeNode*) (_tmp172_ = vala_ccode_return_statement_new ((ValaCCodeExpression*) (_tmp171_ = vala_ccode_identifier_new (_tmp170_ = g_strconcat (type_id_name, "__volatile", NULL))))));
		_vala_ccode_node_unref0 (_tmp172_);
		_vala_ccode_node_unref0 (_tmp171_);
		_g_free0 (_tmp170_);
	} else {
		ValaCCodeIdentifier* _tmp173_;
		ValaCCodeReturnStatement* _tmp174_;
		vala_ccode_block_add_statement (type_block, (ValaCCodeNode*) (_tmp174_ = vala_ccode_return_statement_new ((ValaCCodeExpression*) (_tmp173_ = vala_ccode_identifier_new (type_id_name)))));
		_vala_ccode_node_unref0 (_tmp174_);
		_vala_ccode_node_unref0 (_tmp173_);
	}
	vala_ccode_fragment_append (self->priv->declaration_fragment, (ValaCCodeNode*) (_tmp175_ = vala_ccode_function_copy (fun)));
	_vala_ccode_node_unref0 (_tmp175_);
	vala_ccode_function_set_block (fun, type_block);
	vala_ccode_fragment_append (self->priv->definition_fragment, (ValaCCodeNode*) fun);
	_vala_ccode_node_unref0 (reg_call);
	_vala_ccode_node_unref0 (type_init);
	_g_free0 (type_value_table_decl_name);
	_vala_ccode_node_unref0 (fun);
	_vala_ccode_node_unref0 (_cdecl_);
	_vala_ccode_node_unref0 (type_block);
	_g_free0 (type_id_name);
	_vala_code_node_unref0 (cl);
}


/**
 * Returns the data type to be registered.
 *
 * @return type to be registered
 */
static ValaTypeSymbol* vala_typeregister_function_real_get_type_declaration (ValaTypeRegisterFunction* self) {
	g_return_val_if_fail (self != NULL, NULL);
	g_critical ("Type `%s' does not implement abstract method `vala_typeregister_function_get_type_declaration'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


ValaTypeSymbol* vala_typeregister_function_get_type_declaration (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_type_declaration (self);
}


/**
 * Returns the name of the type struct in C code.
 *
 * @return C struct name
 */
static char* vala_typeregister_function_real_get_type_struct_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_assert_not_reached ();
	return result;
}


char* vala_typeregister_function_get_type_struct_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_type_struct_name (self);
}


/**
 * Returns the name of the base_init function in C code.
 *
 * @return C function name
 */
static char* vala_typeregister_function_real_get_base_init_func_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_assert_not_reached ();
	return result;
}


char* vala_typeregister_function_get_base_init_func_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_base_init_func_name (self);
}


/**
 * Returns the name of the class_finalize function in C code.
 *
 * @return C function name
 */
static char* vala_typeregister_function_real_get_class_finalize_func_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_assert_not_reached ();
	return result;
}


char* vala_typeregister_function_get_class_finalize_func_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_class_finalize_func_name (self);
}


/**
 * Returns the name of the base_finalize function in C code.
 *
 * @return C function name
 */
static char* vala_typeregister_function_real_get_base_finalize_func_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_assert_not_reached ();
	return result;
}


char* vala_typeregister_function_get_base_finalize_func_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_base_finalize_func_name (self);
}


/**
 * Returns the name of the class_init function in C code.
 *
 * @return C function name
 */
static char* vala_typeregister_function_real_get_class_init_func_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_assert_not_reached ();
	return result;
}


char* vala_typeregister_function_get_class_init_func_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_class_init_func_name (self);
}


/**
 * Returns the size of the instance struct in C code.
 *
 * @return C instance struct size
 */
static char* vala_typeregister_function_real_get_instance_struct_size (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_assert_not_reached ();
	return result;
}


char* vala_typeregister_function_get_instance_struct_size (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_instance_struct_size (self);
}


/**
 * Returns the name of the instance_init function in C code.
 *
 * @return C function name
 */
static char* vala_typeregister_function_real_get_instance_init_func_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_assert_not_reached ();
	return result;
}


char* vala_typeregister_function_get_instance_init_func_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_instance_init_func_name (self);
}


/**
 * Returns the name of the parent type in C code.
 *
 * @return C function name
 */
static char* vala_typeregister_function_real_get_parent_type_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_assert_not_reached ();
	return result;
}


char* vala_typeregister_function_get_parent_type_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_parent_type_name (self);
}


/**
 * Returns the C-name of the new generated GTypeValueTable init function or null when not available.
 *
 * @return C function name
 */
static char* vala_typeregister_function_real_get_gtype_value_table_init_function_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = NULL;
	return result;
}


char* vala_typeregister_function_get_gtype_value_table_init_function_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_gtype_value_table_init_function_name (self);
}


/**
 * Returns the C-name of the new generated GTypeValueTable peek pointer function or null when not available.
 *
 * @return C function name
 */
static char* vala_typeregister_function_real_get_gtype_value_table_peek_pointer_function_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = NULL;
	return result;
}


char* vala_typeregister_function_get_gtype_value_table_peek_pointer_function_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_gtype_value_table_peek_pointer_function_name (self);
}


/**
 * Returns the C-name of the new generated GTypeValueTable free function or null when not available.
 *
 * @return C function name
 */
static char* vala_typeregister_function_real_get_gtype_value_table_free_function_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = NULL;
	return result;
}


char* vala_typeregister_function_get_gtype_value_table_free_function_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_gtype_value_table_free_function_name (self);
}


/**
 * Returns the C-name of the new generated GTypeValueTable copy function or null when not available.
 *
 * @return C function name
 */
static char* vala_typeregister_function_real_get_gtype_value_table_copy_function_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = NULL;
	return result;
}


char* vala_typeregister_function_get_gtype_value_table_copy_function_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_gtype_value_table_copy_function_name (self);
}


/**
 * Returns the C-name of the new generated GTypeValueTable lcopy function or null when not available.
 *
 * @return C function name
 */
static char* vala_typeregister_function_real_get_gtype_value_table_lcopy_value_function_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = NULL;
	return result;
}


char* vala_typeregister_function_get_gtype_value_table_lcopy_value_function_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_gtype_value_table_lcopy_value_function_name (self);
}


/**
 * Returns the C-name of the new generated GTypeValueTable collect value function or null when not available.
 *
 * @return C function name
 */
static char* vala_typeregister_function_real_get_gtype_value_table_collect_value_function_name (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = NULL;
	return result;
}


char* vala_typeregister_function_get_gtype_value_table_collect_value_function_name (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_gtype_value_table_collect_value_function_name (self);
}


/**
 * Returns the set of type flags to be applied when registering.
 *
 * @return type flags
 */
static char* vala_typeregister_function_real_get_type_flags (ValaTypeRegisterFunction* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = g_strdup ("0");
	return result;
}


char* vala_typeregister_function_get_type_flags (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_type_flags (self);
}


/**
 * Returns additional C declarations to setup interfaces.
 *
 * @return C declarations
 */
static ValaCCodeFragment* vala_typeregister_function_real_get_type_interface_init_declaration (ValaTypeRegisterFunction* self) {
	ValaCCodeFragment* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = vala_ccode_fragment_new ();
	return result;
}


ValaCCodeFragment* vala_typeregister_function_get_type_interface_init_declaration (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_type_interface_init_declaration (self);
}


/**
 * Returns additional C initialization statements to setup interfaces.
 *
 * @return C statements
 */
static ValaCCodeFragment* vala_typeregister_function_real_get_type_interface_init_statements (ValaTypeRegisterFunction* self, gboolean plugin) {
	g_return_val_if_fail (self != NULL, NULL);
	g_critical ("Type `%s' does not implement abstract method `vala_typeregister_function_get_type_interface_init_statements'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return NULL;
}


ValaCCodeFragment* vala_typeregister_function_get_type_interface_init_statements (ValaTypeRegisterFunction* self, gboolean plugin) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_type_interface_init_statements (self, plugin);
}


ValaCCodeFragment* vala_typeregister_function_get_source_declaration (ValaTypeRegisterFunction* self) {
	ValaCCodeFragment* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = _vala_ccode_node_ref0 (self->priv->source_declaration_fragment);
	return result;
}


/**
 * Returns the declaration for this type register function in C code.
 *
 * @return C function declaration fragment
 */
ValaCCodeFragment* vala_typeregister_function_get_declaration (ValaTypeRegisterFunction* self) {
	ValaCCodeFragment* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = _vala_ccode_node_ref0 (self->priv->declaration_fragment);
	return result;
}


/**
 * Returns the definition for this type register function in C code.
 *
 * @return C function definition fragment
 */
ValaCCodeFragment* vala_typeregister_function_get_definition (ValaTypeRegisterFunction* self) {
	ValaCCodeFragment* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = _vala_ccode_node_ref0 (self->priv->definition_fragment);
	return result;
}


/**
 * Returns the accessibility for this type.
 */
static ValaSymbolAccessibility vala_typeregister_function_real_get_accessibility (ValaTypeRegisterFunction* self) {
	g_return_val_if_fail (self != NULL, 0);
	g_critical ("Type `%s' does not implement abstract method `vala_typeregister_function_get_accessibility'", g_type_name (G_TYPE_FROM_INSTANCE (self)));
	return 0;
}


ValaSymbolAccessibility vala_typeregister_function_get_accessibility (ValaTypeRegisterFunction* self) {
	return VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->get_accessibility (self);
}


ValaTypeRegisterFunction* vala_typeregister_function_construct (GType object_type) {
	ValaTypeRegisterFunction* self = (ValaTypeRegisterFunction*) g_type_create_instance (object_type);
	return self;
}


ValaCodeContext* vala_typeregister_function_get_context (ValaTypeRegisterFunction* self) {
	ValaCodeContext* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self->priv->_context;
	return result;
}


static gpointer _vala_code_context_ref0 (gpointer self) {
	return self ? vala_code_context_ref (self) : NULL;
}


void vala_typeregister_function_set_context (ValaTypeRegisterFunction* self, ValaCodeContext* value) {
	ValaCodeContext* _tmp0_;
	g_return_if_fail (self != NULL);
	self->priv->_context = (_tmp0_ = _vala_code_context_ref0 (value), _vala_code_context_unref0 (self->priv->_context), _tmp0_);
}


static void vala_value_typeregister_function_init (GValue* value) {
	value->data[0].v_pointer = NULL;
}


static void vala_value_typeregister_function_free_value (GValue* value) {
	if (value->data[0].v_pointer) {
		vala_typeregister_function_unref (value->data[0].v_pointer);
	}
}


static void vala_value_typeregister_function_copy_value (const GValue* src_value, GValue* dest_value) {
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = vala_typeregister_function_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}


static gpointer vala_value_typeregister_function_peek_pointer (const GValue* value) {
	return value->data[0].v_pointer;
}


static gchar* vala_value_typeregister_function_collect_value (GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	if (collect_values[0].v_pointer) {
		ValaTypeRegisterFunction* object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = vala_typeregister_function_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}


static gchar* vala_value_typeregister_function_lcopy_value (const GValue* value, guint n_collect_values, GTypeCValue* collect_values, guint collect_flags) {
	ValaTypeRegisterFunction** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = vala_typeregister_function_ref (value->data[0].v_pointer);
	}
	return NULL;
}


GParamSpec* vala_param_spec_typeregister_function (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags) {
	ValaParamSpecTypeRegisterFunction* spec;
	g_return_val_if_fail (g_type_is_a (object_type, VALA_TYPE_TYPEREGISTER_FUNCTION), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}


gpointer vala_value_get_typeregister_function (const GValue* value) {
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_TYPE_TYPEREGISTER_FUNCTION), NULL);
	return value->data[0].v_pointer;
}


void vala_value_set_typeregister_function (GValue* value, gpointer v_object) {
	ValaTypeRegisterFunction* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_TYPE_TYPEREGISTER_FUNCTION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, VALA_TYPE_TYPEREGISTER_FUNCTION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		vala_typeregister_function_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		vala_typeregister_function_unref (old);
	}
}


void vala_value_take_typeregister_function (GValue* value, gpointer v_object) {
	ValaTypeRegisterFunction* old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, VALA_TYPE_TYPEREGISTER_FUNCTION));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, VALA_TYPE_TYPEREGISTER_FUNCTION));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		vala_typeregister_function_unref (old);
	}
}


static void vala_typeregister_function_class_init (ValaTypeRegisterFunctionClass * klass) {
	vala_typeregister_function_parent_class = g_type_class_peek_parent (klass);
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->finalize = vala_typeregister_function_finalize;
	g_type_class_add_private (klass, sizeof (ValaTypeRegisterFunctionPrivate));
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_type_declaration = vala_typeregister_function_real_get_type_declaration;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_type_struct_name = vala_typeregister_function_real_get_type_struct_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_base_init_func_name = vala_typeregister_function_real_get_base_init_func_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_class_finalize_func_name = vala_typeregister_function_real_get_class_finalize_func_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_base_finalize_func_name = vala_typeregister_function_real_get_base_finalize_func_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_class_init_func_name = vala_typeregister_function_real_get_class_init_func_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_instance_struct_size = vala_typeregister_function_real_get_instance_struct_size;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_instance_init_func_name = vala_typeregister_function_real_get_instance_init_func_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_parent_type_name = vala_typeregister_function_real_get_parent_type_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_gtype_value_table_init_function_name = vala_typeregister_function_real_get_gtype_value_table_init_function_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_gtype_value_table_peek_pointer_function_name = vala_typeregister_function_real_get_gtype_value_table_peek_pointer_function_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_gtype_value_table_free_function_name = vala_typeregister_function_real_get_gtype_value_table_free_function_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_gtype_value_table_copy_function_name = vala_typeregister_function_real_get_gtype_value_table_copy_function_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_gtype_value_table_lcopy_value_function_name = vala_typeregister_function_real_get_gtype_value_table_lcopy_value_function_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_gtype_value_table_collect_value_function_name = vala_typeregister_function_real_get_gtype_value_table_collect_value_function_name;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_type_flags = vala_typeregister_function_real_get_type_flags;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_type_interface_init_declaration = vala_typeregister_function_real_get_type_interface_init_declaration;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_type_interface_init_statements = vala_typeregister_function_real_get_type_interface_init_statements;
	VALA_TYPEREGISTER_FUNCTION_CLASS (klass)->get_accessibility = vala_typeregister_function_real_get_accessibility;
}


static void vala_typeregister_function_instance_init (ValaTypeRegisterFunction * self) {
	self->priv = VALA_TYPEREGISTER_FUNCTION_GET_PRIVATE (self);
	self->priv->source_declaration_fragment = vala_ccode_fragment_new ();
	self->priv->declaration_fragment = vala_ccode_fragment_new ();
	self->priv->definition_fragment = vala_ccode_fragment_new ();
	self->ref_count = 1;
}


static void vala_typeregister_function_finalize (ValaTypeRegisterFunction* obj) {
	ValaTypeRegisterFunction * self;
	self = VALA_TYPEREGISTER_FUNCTION (obj);
	_vala_ccode_node_unref0 (self->priv->source_declaration_fragment);
	_vala_ccode_node_unref0 (self->priv->declaration_fragment);
	_vala_ccode_node_unref0 (self->priv->definition_fragment);
	_vala_code_context_unref0 (self->priv->_context);
}


/**
 * C function to register a type at runtime.
 */
GType vala_typeregister_function_get_type (void) {
	static volatile gsize vala_typeregister_function_type_id__volatile = 0;
	if (g_once_init_enter (&vala_typeregister_function_type_id__volatile)) {
		static const GTypeValueTable g_define_type_value_table = { vala_value_typeregister_function_init, vala_value_typeregister_function_free_value, vala_value_typeregister_function_copy_value, vala_value_typeregister_function_peek_pointer, "p", vala_value_typeregister_function_collect_value, "p", vala_value_typeregister_function_lcopy_value };
		static const GTypeInfo g_define_type_info = { sizeof (ValaTypeRegisterFunctionClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_typeregister_function_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaTypeRegisterFunction), 0, (GInstanceInitFunc) vala_typeregister_function_instance_init, &g_define_type_value_table };
		static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
		GType vala_typeregister_function_type_id;
		vala_typeregister_function_type_id = g_type_register_fundamental (g_type_fundamental_next (), "ValaTypeRegisterFunction", &g_define_type_info, &g_define_type_fundamental_info, G_TYPE_FLAG_ABSTRACT);
		g_once_init_leave (&vala_typeregister_function_type_id__volatile, vala_typeregister_function_type_id);
	}
	return vala_typeregister_function_type_id__volatile;
}


gpointer vala_typeregister_function_ref (gpointer instance) {
	ValaTypeRegisterFunction* self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}


void vala_typeregister_function_unref (gpointer instance) {
	ValaTypeRegisterFunction* self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		VALA_TYPEREGISTER_FUNCTION_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}




