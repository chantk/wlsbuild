/* valagsignalmodule.c generated by valac, the Vala compiler
 * generated from valagsignalmodule.vala, do not modify */

/* valagsignalmodule.vala
 *
 * Copyright (C) 2006-2010  Jürg Billeter
 * Copyright (C) 2006-2008  Raffaele Sandrini
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 *	Raffaele Sandrini <raffaele@sandrini.ch>
 */

#include <glib.h>
#include <glib-object.h>
#include <vala.h>
#include <valagee.h>
#include <valaccode.h>
#include <stdlib.h>
#include <string.h>


#define VALA_TYPE_CCODE_BASE_MODULE (vala_ccode_base_module_get_type ())
#define VALA_CCODE_BASE_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CCODE_BASE_MODULE, ValaCCodeBaseModule))
#define VALA_CCODE_BASE_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CCODE_BASE_MODULE, ValaCCodeBaseModuleClass))
#define VALA_IS_CCODE_BASE_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CCODE_BASE_MODULE))
#define VALA_IS_CCODE_BASE_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CCODE_BASE_MODULE))
#define VALA_CCODE_BASE_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CCODE_BASE_MODULE, ValaCCodeBaseModuleClass))

typedef struct _ValaCCodeBaseModule ValaCCodeBaseModule;
typedef struct _ValaCCodeBaseModuleClass ValaCCodeBaseModuleClass;
typedef struct _ValaCCodeBaseModulePrivate ValaCCodeBaseModulePrivate;

#define VALA_TYPE_CCODE_DECLARATION_SPACE (vala_ccode_declaration_space_get_type ())
#define VALA_CCODE_DECLARATION_SPACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CCODE_DECLARATION_SPACE, ValaCCodeDeclarationSpace))
#define VALA_CCODE_DECLARATION_SPACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CCODE_DECLARATION_SPACE, ValaCCodeDeclarationSpaceClass))
#define VALA_IS_CCODE_DECLARATION_SPACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CCODE_DECLARATION_SPACE))
#define VALA_IS_CCODE_DECLARATION_SPACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CCODE_DECLARATION_SPACE))
#define VALA_CCODE_DECLARATION_SPACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CCODE_DECLARATION_SPACE, ValaCCodeDeclarationSpaceClass))

typedef struct _ValaCCodeDeclarationSpace ValaCCodeDeclarationSpace;
typedef struct _ValaCCodeDeclarationSpaceClass ValaCCodeDeclarationSpaceClass;

#define VALA_CCODE_BASE_MODULE_TYPE_EMIT_CONTEXT (vala_ccode_base_module_emit_context_get_type ())
#define VALA_CCODE_BASE_MODULE_EMIT_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_CCODE_BASE_MODULE_TYPE_EMIT_CONTEXT, ValaCCodeBaseModuleEmitContext))
#define VALA_CCODE_BASE_MODULE_EMIT_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_CCODE_BASE_MODULE_TYPE_EMIT_CONTEXT, ValaCCodeBaseModuleEmitContextClass))
#define VALA_CCODE_BASE_MODULE_IS_EMIT_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_CCODE_BASE_MODULE_TYPE_EMIT_CONTEXT))
#define VALA_CCODE_BASE_MODULE_IS_EMIT_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_CCODE_BASE_MODULE_TYPE_EMIT_CONTEXT))
#define VALA_CCODE_BASE_MODULE_EMIT_CONTEXT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_CCODE_BASE_MODULE_TYPE_EMIT_CONTEXT, ValaCCodeBaseModuleEmitContextClass))

typedef struct _ValaCCodeBaseModuleEmitContext ValaCCodeBaseModuleEmitContext;
typedef struct _ValaCCodeBaseModuleEmitContextClass ValaCCodeBaseModuleEmitContextClass;

#define VALA_TYPE_CCODE_STRUCT_MODULE (vala_ccode_struct_module_get_type ())
#define VALA_CCODE_STRUCT_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CCODE_STRUCT_MODULE, ValaCCodeStructModule))
#define VALA_CCODE_STRUCT_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CCODE_STRUCT_MODULE, ValaCCodeStructModuleClass))
#define VALA_IS_CCODE_STRUCT_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CCODE_STRUCT_MODULE))
#define VALA_IS_CCODE_STRUCT_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CCODE_STRUCT_MODULE))
#define VALA_CCODE_STRUCT_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CCODE_STRUCT_MODULE, ValaCCodeStructModuleClass))

typedef struct _ValaCCodeStructModule ValaCCodeStructModule;
typedef struct _ValaCCodeStructModuleClass ValaCCodeStructModuleClass;
typedef struct _ValaCCodeStructModulePrivate ValaCCodeStructModulePrivate;

#define VALA_TYPE_CCODE_METHOD_MODULE (vala_ccode_method_module_get_type ())
#define VALA_CCODE_METHOD_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CCODE_METHOD_MODULE, ValaCCodeMethodModule))
#define VALA_CCODE_METHOD_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CCODE_METHOD_MODULE, ValaCCodeMethodModuleClass))
#define VALA_IS_CCODE_METHOD_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CCODE_METHOD_MODULE))
#define VALA_IS_CCODE_METHOD_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CCODE_METHOD_MODULE))
#define VALA_CCODE_METHOD_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CCODE_METHOD_MODULE, ValaCCodeMethodModuleClass))

typedef struct _ValaCCodeMethodModule ValaCCodeMethodModule;
typedef struct _ValaCCodeMethodModuleClass ValaCCodeMethodModuleClass;
typedef struct _ValaCCodeMethodModulePrivate ValaCCodeMethodModulePrivate;

#define VALA_TYPE_CCODE_CONTROL_FLOW_MODULE (vala_ccode_control_flow_module_get_type ())
#define VALA_CCODE_CONTROL_FLOW_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CCODE_CONTROL_FLOW_MODULE, ValaCCodeControlFlowModule))
#define VALA_CCODE_CONTROL_FLOW_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CCODE_CONTROL_FLOW_MODULE, ValaCCodeControlFlowModuleClass))
#define VALA_IS_CCODE_CONTROL_FLOW_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CCODE_CONTROL_FLOW_MODULE))
#define VALA_IS_CCODE_CONTROL_FLOW_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CCODE_CONTROL_FLOW_MODULE))
#define VALA_CCODE_CONTROL_FLOW_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CCODE_CONTROL_FLOW_MODULE, ValaCCodeControlFlowModuleClass))

typedef struct _ValaCCodeControlFlowModule ValaCCodeControlFlowModule;
typedef struct _ValaCCodeControlFlowModuleClass ValaCCodeControlFlowModuleClass;
typedef struct _ValaCCodeControlFlowModulePrivate ValaCCodeControlFlowModulePrivate;

#define VALA_TYPE_CCODE_MEMBER_ACCESS_MODULE (vala_ccode_member_access_module_get_type ())
#define VALA_CCODE_MEMBER_ACCESS_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CCODE_MEMBER_ACCESS_MODULE, ValaCCodeMemberAccessModule))
#define VALA_CCODE_MEMBER_ACCESS_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CCODE_MEMBER_ACCESS_MODULE, ValaCCodeMemberAccessModuleClass))
#define VALA_IS_CCODE_MEMBER_ACCESS_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CCODE_MEMBER_ACCESS_MODULE))
#define VALA_IS_CCODE_MEMBER_ACCESS_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CCODE_MEMBER_ACCESS_MODULE))
#define VALA_CCODE_MEMBER_ACCESS_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CCODE_MEMBER_ACCESS_MODULE, ValaCCodeMemberAccessModuleClass))

typedef struct _ValaCCodeMemberAccessModule ValaCCodeMemberAccessModule;
typedef struct _ValaCCodeMemberAccessModuleClass ValaCCodeMemberAccessModuleClass;
typedef struct _ValaCCodeMemberAccessModulePrivate ValaCCodeMemberAccessModulePrivate;

#define VALA_TYPE_CCODE_ASSIGNMENT_MODULE (vala_ccode_assignment_module_get_type ())
#define VALA_CCODE_ASSIGNMENT_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CCODE_ASSIGNMENT_MODULE, ValaCCodeAssignmentModule))
#define VALA_CCODE_ASSIGNMENT_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CCODE_ASSIGNMENT_MODULE, ValaCCodeAssignmentModuleClass))
#define VALA_IS_CCODE_ASSIGNMENT_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CCODE_ASSIGNMENT_MODULE))
#define VALA_IS_CCODE_ASSIGNMENT_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CCODE_ASSIGNMENT_MODULE))
#define VALA_CCODE_ASSIGNMENT_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CCODE_ASSIGNMENT_MODULE, ValaCCodeAssignmentModuleClass))

typedef struct _ValaCCodeAssignmentModule ValaCCodeAssignmentModule;
typedef struct _ValaCCodeAssignmentModuleClass ValaCCodeAssignmentModuleClass;
typedef struct _ValaCCodeAssignmentModulePrivate ValaCCodeAssignmentModulePrivate;

#define VALA_TYPE_CCODE_METHOD_CALL_MODULE (vala_ccode_method_call_module_get_type ())
#define VALA_CCODE_METHOD_CALL_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CCODE_METHOD_CALL_MODULE, ValaCCodeMethodCallModule))
#define VALA_CCODE_METHOD_CALL_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CCODE_METHOD_CALL_MODULE, ValaCCodeMethodCallModuleClass))
#define VALA_IS_CCODE_METHOD_CALL_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CCODE_METHOD_CALL_MODULE))
#define VALA_IS_CCODE_METHOD_CALL_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CCODE_METHOD_CALL_MODULE))
#define VALA_CCODE_METHOD_CALL_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CCODE_METHOD_CALL_MODULE, ValaCCodeMethodCallModuleClass))

typedef struct _ValaCCodeMethodCallModule ValaCCodeMethodCallModule;
typedef struct _ValaCCodeMethodCallModuleClass ValaCCodeMethodCallModuleClass;
typedef struct _ValaCCodeMethodCallModulePrivate ValaCCodeMethodCallModulePrivate;

#define VALA_TYPE_CCODE_ARRAY_MODULE (vala_ccode_array_module_get_type ())
#define VALA_CCODE_ARRAY_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CCODE_ARRAY_MODULE, ValaCCodeArrayModule))
#define VALA_CCODE_ARRAY_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CCODE_ARRAY_MODULE, ValaCCodeArrayModuleClass))
#define VALA_IS_CCODE_ARRAY_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CCODE_ARRAY_MODULE))
#define VALA_IS_CCODE_ARRAY_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CCODE_ARRAY_MODULE))
#define VALA_CCODE_ARRAY_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CCODE_ARRAY_MODULE, ValaCCodeArrayModuleClass))

typedef struct _ValaCCodeArrayModule ValaCCodeArrayModule;
typedef struct _ValaCCodeArrayModuleClass ValaCCodeArrayModuleClass;
typedef struct _ValaCCodeArrayModulePrivate ValaCCodeArrayModulePrivate;

#define VALA_TYPE_CCODE_DELEGATE_MODULE (vala_ccode_delegate_module_get_type ())
#define VALA_CCODE_DELEGATE_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CCODE_DELEGATE_MODULE, ValaCCodeDelegateModule))
#define VALA_CCODE_DELEGATE_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CCODE_DELEGATE_MODULE, ValaCCodeDelegateModuleClass))
#define VALA_IS_CCODE_DELEGATE_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CCODE_DELEGATE_MODULE))
#define VALA_IS_CCODE_DELEGATE_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CCODE_DELEGATE_MODULE))
#define VALA_CCODE_DELEGATE_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CCODE_DELEGATE_MODULE, ValaCCodeDelegateModuleClass))

typedef struct _ValaCCodeDelegateModule ValaCCodeDelegateModule;
typedef struct _ValaCCodeDelegateModuleClass ValaCCodeDelegateModuleClass;
typedef struct _ValaCCodeDelegateModulePrivate ValaCCodeDelegateModulePrivate;

#define VALA_TYPE_GERROR_MODULE (vala_gerror_module_get_type ())
#define VALA_GERROR_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_GERROR_MODULE, ValaGErrorModule))
#define VALA_GERROR_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_GERROR_MODULE, ValaGErrorModuleClass))
#define VALA_IS_GERROR_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_GERROR_MODULE))
#define VALA_IS_GERROR_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_GERROR_MODULE))
#define VALA_GERROR_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_GERROR_MODULE, ValaGErrorModuleClass))

typedef struct _ValaGErrorModule ValaGErrorModule;
typedef struct _ValaGErrorModuleClass ValaGErrorModuleClass;
typedef struct _ValaGErrorModulePrivate ValaGErrorModulePrivate;

#define VALA_TYPE_GTYPE_MODULE (vala_gtype_module_get_type ())
#define VALA_GTYPE_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_GTYPE_MODULE, ValaGTypeModule))
#define VALA_GTYPE_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_GTYPE_MODULE, ValaGTypeModuleClass))
#define VALA_IS_GTYPE_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_GTYPE_MODULE))
#define VALA_IS_GTYPE_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_GTYPE_MODULE))
#define VALA_GTYPE_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_GTYPE_MODULE, ValaGTypeModuleClass))

typedef struct _ValaGTypeModule ValaGTypeModule;
typedef struct _ValaGTypeModuleClass ValaGTypeModuleClass;
typedef struct _ValaGTypeModulePrivate ValaGTypeModulePrivate;

#define VALA_TYPE_TYPEREGISTER_FUNCTION (vala_typeregister_function_get_type ())
#define VALA_TYPEREGISTER_FUNCTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPEREGISTER_FUNCTION, ValaTypeRegisterFunction))
#define VALA_TYPEREGISTER_FUNCTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPEREGISTER_FUNCTION, ValaTypeRegisterFunctionClass))
#define VALA_IS_TYPEREGISTER_FUNCTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPEREGISTER_FUNCTION))
#define VALA_IS_TYPEREGISTER_FUNCTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPEREGISTER_FUNCTION))
#define VALA_TYPEREGISTER_FUNCTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPEREGISTER_FUNCTION, ValaTypeRegisterFunctionClass))

typedef struct _ValaTypeRegisterFunction ValaTypeRegisterFunction;
typedef struct _ValaTypeRegisterFunctionClass ValaTypeRegisterFunctionClass;

#define VALA_TYPE_GOBJECT_MODULE (vala_gobject_module_get_type ())
#define VALA_GOBJECT_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_GOBJECT_MODULE, ValaGObjectModule))
#define VALA_GOBJECT_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_GOBJECT_MODULE, ValaGObjectModuleClass))
#define VALA_IS_GOBJECT_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_GOBJECT_MODULE))
#define VALA_IS_GOBJECT_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_GOBJECT_MODULE))
#define VALA_GOBJECT_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_GOBJECT_MODULE, ValaGObjectModuleClass))

typedef struct _ValaGObjectModule ValaGObjectModule;
typedef struct _ValaGObjectModuleClass ValaGObjectModuleClass;
typedef struct _ValaGObjectModulePrivate ValaGObjectModulePrivate;

#define VALA_TYPE_GSIGNAL_MODULE (vala_gsignal_module_get_type ())
#define VALA_GSIGNAL_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_GSIGNAL_MODULE, ValaGSignalModule))
#define VALA_GSIGNAL_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_GSIGNAL_MODULE, ValaGSignalModuleClass))
#define VALA_IS_GSIGNAL_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_GSIGNAL_MODULE))
#define VALA_IS_GSIGNAL_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_GSIGNAL_MODULE))
#define VALA_GSIGNAL_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_GSIGNAL_MODULE, ValaGSignalModuleClass))

typedef struct _ValaGSignalModule ValaGSignalModule;
typedef struct _ValaGSignalModuleClass ValaGSignalModuleClass;
typedef struct _ValaGSignalModulePrivate ValaGSignalModulePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_node_unref (var), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _vala_collection_object_unref0(var) ((var == NULL) ? NULL : (var = (vala_collection_object_unref (var), NULL)))
#define _vala_ccode_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_ccode_node_unref (var), NULL)))

struct _ValaCCodeBaseModule {
	ValaCodeGenerator parent_instance;
	ValaCCodeBaseModulePrivate * priv;
	ValaSymbol* root_symbol;
	ValaCCodeBaseModuleEmitContext* emit_context;
	ValaCCodeDeclarationSpace* header_declarations;
	ValaCCodeDeclarationSpace* internal_header_declarations;
	ValaCCodeDeclarationSpace* source_declarations;
	ValaCCodeFragment* source_signal_marshaller_declaration;
	ValaCCodeFragment* source_type_member_definition;
	ValaCCodeFragment* class_init_fragment;
	ValaCCodeFragment* base_init_fragment;
	ValaCCodeFragment* class_finalize_fragment;
	ValaCCodeFragment* base_finalize_fragment;
	ValaCCodeFragment* instance_init_fragment;
	ValaCCodeFragment* instance_finalize_fragment;
	ValaCCodeFragment* source_signal_marshaller_definition;
	ValaCCodeStruct* param_spec_struct;
	ValaCCodeStruct* closure_struct;
	ValaCCodeEnum* prop_enum;
	ValaCCodeFunction* function;
	ValaCCodeFragment* pre_statement_fragment;
	ValaSet* user_marshal_set;
	ValaSet* predefined_marshal_set;
	gint next_regex_id;
	gboolean in_constructor;
	gboolean in_static_or_class_context;
	gint next_coroutine_state;
	ValaDataType* void_type;
	ValaDataType* bool_type;
	ValaDataType* char_type;
	ValaDataType* uchar_type;
	ValaDataType* unichar_type;
	ValaDataType* short_type;
	ValaDataType* ushort_type;
	ValaDataType* int_type;
	ValaDataType* uint_type;
	ValaDataType* long_type;
	ValaDataType* ulong_type;
	ValaDataType* int8_type;
	ValaDataType* uint8_type;
	ValaDataType* int16_type;
	ValaDataType* uint16_type;
	ValaDataType* int32_type;
	ValaDataType* uint32_type;
	ValaDataType* int64_type;
	ValaDataType* uint64_type;
	ValaDataType* string_type;
	ValaDataType* regex_type;
	ValaDataType* float_type;
	ValaDataType* double_type;
	ValaTypeSymbol* gtype_type;
	ValaTypeSymbol* gobject_type;
	ValaErrorType* gerror_type;
	ValaClass* glist_type;
	ValaClass* gslist_type;
	ValaClass* gnode_type;
	ValaClass* gvaluearray_type;
	ValaTypeSymbol* gstringbuilder_type;
	ValaTypeSymbol* garray_type;
	ValaTypeSymbol* gbytearray_type;
	ValaTypeSymbol* gptrarray_type;
	ValaTypeSymbol* gthreadpool_type;
	ValaDataType* gquark_type;
	ValaStruct* gvalue_type;
	ValaClass* gvariant_type;
	ValaStruct* mutex_type;
	ValaTypeSymbol* type_module_type;
	ValaTypeSymbol* dbus_proxy_type;
	ValaTypeSymbol* dbus_object_type;
	gboolean in_plugin;
	char* module_init_param_name;
	gboolean gvaluecollector_h_needed;
	gboolean requires_array_free;
	gboolean requires_array_move;
	gboolean requires_array_length;
	gboolean requires_strcmp0;
	ValaSet* wrappers;
};

struct _ValaCCodeBaseModuleClass {
	ValaCodeGeneratorClass parent_class;
	void (*append_vala_array_free) (ValaCCodeBaseModule* self);
	void (*append_vala_array_move) (ValaCCodeBaseModule* self);
	void (*append_vala_array_length) (ValaCCodeBaseModule* self);
	gboolean (*generate_enum_declaration) (ValaCCodeBaseModule* self, ValaEnum* en, ValaCCodeDeclarationSpace* decl_space);
	void (*generate_class_struct_declaration) (ValaCCodeBaseModule* self, ValaClass* cl, ValaCCodeDeclarationSpace* decl_space);
	void (*generate_struct_declaration) (ValaCCodeBaseModule* self, ValaStruct* st, ValaCCodeDeclarationSpace* decl_space);
	void (*generate_delegate_declaration) (ValaCCodeBaseModule* self, ValaDelegate* d, ValaCCodeDeclarationSpace* decl_space);
	void (*generate_cparameters) (ValaCCodeBaseModule* self, ValaMethod* m, ValaCCodeDeclarationSpace* decl_space, ValaMap* cparam_map, ValaCCodeFunction* func, ValaCCodeFunctionDeclarator* vdeclarator, ValaMap* carg_map, ValaCCodeFunctionCall* vcall, gint direction);
	ValaCCodeExpression* (*get_dup_func_expression) (ValaCCodeBaseModule* self, ValaDataType* type, ValaSourceReference* source_reference, gboolean is_chainup);
	char* (*append_struct_array_free) (ValaCCodeBaseModule* self, ValaStruct* st);
	ValaCCodeExpression* (*get_unref_expression) (ValaCCodeBaseModule* self, ValaCCodeExpression* cvar, ValaDataType* type, ValaExpression* expr, gboolean is_macro_definition);
	void (*append_local_free) (ValaCCodeBaseModule* self, ValaSymbol* sym, ValaCCodeFragment* cfrag, gboolean stop_at_loop);
	char* (*get_delegate_target_cname) (ValaCCodeBaseModule* self, const char* delegate_cname);
	ValaCCodeExpression* (*get_delegate_target_cexpression) (ValaCCodeBaseModule* self, ValaExpression* delegate_expr, ValaCCodeExpression** delegate_target_destroy_notify);
	char* (*get_delegate_target_destroy_notify_cname) (ValaCCodeBaseModule* self, const char* delegate_cname);
	ValaCCodeExpression* (*get_ref_cexpression) (ValaCCodeBaseModule* self, ValaDataType* expression_type, ValaCCodeExpression* cexpr, ValaExpression* expr, ValaCodeNode* node);
	void (*generate_class_declaration) (ValaCCodeBaseModule* self, ValaClass* cl, ValaCCodeDeclarationSpace* decl_space);
	void (*generate_interface_declaration) (ValaCCodeBaseModule* self, ValaInterface* iface, ValaCCodeDeclarationSpace* decl_space);
	void (*generate_method_declaration) (ValaCCodeBaseModule* self, ValaMethod* m, ValaCCodeDeclarationSpace* decl_space);
	void (*generate_error_domain_declaration) (ValaCCodeBaseModule* self, ValaErrorDomain* edomain, ValaCCodeDeclarationSpace* decl_space);
	ValaCCodeExpression* (*deserialize_expression) (ValaCCodeBaseModule* self, ValaCCodeFragment* fragment, ValaDataType* type, ValaCCodeExpression* variant_expr, ValaCCodeExpression* expr);
	ValaCCodeExpression* (*serialize_expression) (ValaCCodeBaseModule* self, ValaCCodeFragment* fragment, ValaDataType* type, ValaCCodeExpression* expr);
	ValaCCodeExpression* (*get_implicit_cast_expression) (ValaCCodeBaseModule* self, ValaCCodeExpression* source_cexpr, ValaDataType* expression_type, ValaDataType* target_type, ValaExpression* expr);
	gboolean (*is_gobject_property) (ValaCCodeBaseModule* self, ValaProperty* prop);
	char* (*get_custom_creturn_type) (ValaCCodeBaseModule* self, ValaMethod* m);
	void (*generate_dynamic_method_wrapper) (ValaCCodeBaseModule* self, ValaDynamicMethod* method);
	gboolean (*method_has_wrapper) (ValaCCodeBaseModule* self, ValaMethod* method);
	ValaCCodeExpression* (*get_construct_property_assignment) (ValaCCodeBaseModule* self, ValaCCodeConstant* canonical_cconstant, ValaDataType* property_type, ValaCCodeExpression* value);
	ValaCCodeFunctionCall* (*get_param_spec) (ValaCCodeBaseModule* self, ValaProperty* prop);
	ValaCCodeFunctionCall* (*get_signal_creation) (ValaCCodeBaseModule* self, ValaSignal* sig, ValaTypeSymbol* type);
	ValaCCodeFragment* (*register_dbus_info) (ValaCCodeBaseModule* self, ValaObjectTypeSymbol* bindable);
	char* (*get_dynamic_property_getter_cname) (ValaCCodeBaseModule* self, ValaDynamicProperty* node);
	char* (*get_dynamic_property_setter_cname) (ValaCCodeBaseModule* self, ValaDynamicProperty* node);
	char* (*get_dynamic_signal_cname) (ValaCCodeBaseModule* self, ValaDynamicSignal* node);
	char* (*get_dynamic_signal_connect_wrapper_name) (ValaCCodeBaseModule* self, ValaDynamicSignal* node);
	char* (*get_dynamic_signal_connect_after_wrapper_name) (ValaCCodeBaseModule* self, ValaDynamicSignal* node);
	char* (*get_dynamic_signal_disconnect_wrapper_name) (ValaCCodeBaseModule* self, ValaDynamicSignal* node);
	void (*generate_marshaller) (ValaCCodeBaseModule* self, ValaList* params, ValaDataType* return_type, gboolean dbus);
	char* (*get_marshaller_function) (ValaCCodeBaseModule* self, ValaList* params, ValaDataType* return_type, const char* prefix, gboolean dbus);
	char* (*get_array_length_cname) (ValaCCodeBaseModule* self, const char* array_cname, gint dim);
	char* (*get_parameter_array_length_cname) (ValaCCodeBaseModule* self, ValaFormalParameter* param, gint dim);
	ValaCCodeExpression* (*get_array_length_cexpression) (ValaCCodeBaseModule* self, ValaExpression* array_expr, gint dim);
	char* (*get_array_size_cname) (ValaCCodeBaseModule* self, const char* array_cname);
	ValaCCodeExpression* (*get_array_size_cexpression) (ValaCCodeBaseModule* self, ValaExpression* array_expr);
	void (*add_simple_check) (ValaCCodeBaseModule* self, ValaCodeNode* node, ValaCCodeFragment* cfrag, gboolean always_fails);
};

struct _ValaCCodeStructModule {
	ValaCCodeBaseModule parent_instance;
	ValaCCodeStructModulePrivate * priv;
};

struct _ValaCCodeStructModuleClass {
	ValaCCodeBaseModuleClass parent_class;
};

struct _ValaCCodeMethodModule {
	ValaCCodeStructModule parent_instance;
	ValaCCodeMethodModulePrivate * priv;
};

struct _ValaCCodeMethodModuleClass {
	ValaCCodeStructModuleClass parent_class;
	void (*generate_method_result_declaration) (ValaCCodeMethodModule* self, ValaMethod* m, ValaCCodeDeclarationSpace* decl_space, ValaCCodeFunction* cfunc, ValaMap* cparam_map, ValaMap* carg_map);
	void (*generate_parameter) (ValaCCodeMethodModule* self, ValaFormalParameter* param, ValaCCodeDeclarationSpace* decl_space, ValaMap* cparam_map, ValaMap* carg_map);
};

struct _ValaCCodeControlFlowModule {
	ValaCCodeMethodModule parent_instance;
	ValaCCodeControlFlowModulePrivate * priv;
};

struct _ValaCCodeControlFlowModuleClass {
	ValaCCodeMethodModuleClass parent_class;
};

struct _ValaCCodeMemberAccessModule {
	ValaCCodeControlFlowModule parent_instance;
	ValaCCodeMemberAccessModulePrivate * priv;
};

struct _ValaCCodeMemberAccessModuleClass {
	ValaCCodeControlFlowModuleClass parent_class;
};

struct _ValaCCodeAssignmentModule {
	ValaCCodeMemberAccessModule parent_instance;
	ValaCCodeAssignmentModulePrivate * priv;
};

struct _ValaCCodeAssignmentModuleClass {
	ValaCCodeMemberAccessModuleClass parent_class;
};

struct _ValaCCodeMethodCallModule {
	ValaCCodeAssignmentModule parent_instance;
	ValaCCodeMethodCallModulePrivate * priv;
};

struct _ValaCCodeMethodCallModuleClass {
	ValaCCodeAssignmentModuleClass parent_class;
};

struct _ValaCCodeArrayModule {
	ValaCCodeMethodCallModule parent_instance;
	ValaCCodeArrayModulePrivate * priv;
};

struct _ValaCCodeArrayModuleClass {
	ValaCCodeMethodCallModuleClass parent_class;
};

struct _ValaCCodeDelegateModule {
	ValaCCodeArrayModule parent_instance;
	ValaCCodeDelegateModulePrivate * priv;
};

struct _ValaCCodeDelegateModuleClass {
	ValaCCodeArrayModuleClass parent_class;
};

struct _ValaGErrorModule {
	ValaCCodeDelegateModule parent_instance;
	ValaGErrorModulePrivate * priv;
};

struct _ValaGErrorModuleClass {
	ValaCCodeDelegateModuleClass parent_class;
	ValaCCodeStatement* (*return_with_exception) (ValaGErrorModule* self, ValaCCodeExpression* error_expr);
};

struct _ValaGTypeModule {
	ValaGErrorModule parent_instance;
	ValaGTypeModulePrivate * priv;
};

struct _ValaGTypeModuleClass {
	ValaGErrorModuleClass parent_class;
	void (*generate_virtual_method_declaration) (ValaGTypeModule* self, ValaMethod* m, ValaCCodeDeclarationSpace* decl_space, ValaCCodeStruct* type_struct);
	void (*generate_class_init) (ValaGTypeModule* self, ValaClass* cl, ValaCCodeBlock* init_block);
	ValaTypeRegisterFunction* (*create_interface_register_function) (ValaGTypeModule* self, ValaInterface* iface);
};

struct _ValaGObjectModule {
	ValaGTypeModule parent_instance;
	ValaGObjectModulePrivate * priv;
};

struct _ValaGObjectModuleClass {
	ValaGTypeModuleClass parent_class;
};

struct _ValaGSignalModule {
	ValaGObjectModule parent_instance;
	ValaGSignalModulePrivate * priv;
};

struct _ValaGSignalModuleClass {
	ValaGObjectModuleClass parent_class;
	ValaCCodeExpression* (*get_dbus_g_type) (ValaGSignalModule* self, ValaDataType* data_type);
};


static gpointer vala_gsignal_module_parent_class = NULL;

GType vala_ccode_base_module_get_type (void) G_GNUC_CONST;
gpointer vala_ccode_declaration_space_ref (gpointer instance);
void vala_ccode_declaration_space_unref (gpointer instance);
GParamSpec* vala_param_spec_ccode_declaration_space (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_ccode_declaration_space (GValue* value, gpointer v_object);
void vala_value_take_ccode_declaration_space (GValue* value, gpointer v_object);
gpointer vala_value_get_ccode_declaration_space (const GValue* value);
GType vala_ccode_declaration_space_get_type (void) G_GNUC_CONST;
gpointer vala_ccode_base_module_emit_context_ref (gpointer instance);
void vala_ccode_base_module_emit_context_unref (gpointer instance);
GParamSpec* vala_ccode_base_module_param_spec_emit_context (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_ccode_base_module_value_set_emit_context (GValue* value, gpointer v_object);
void vala_ccode_base_module_value_take_emit_context (GValue* value, gpointer v_object);
gpointer vala_ccode_base_module_value_get_emit_context (const GValue* value);
GType vala_ccode_base_module_emit_context_get_type (void) G_GNUC_CONST;
GType vala_ccode_struct_module_get_type (void) G_GNUC_CONST;
GType vala_ccode_method_module_get_type (void) G_GNUC_CONST;
GType vala_ccode_control_flow_module_get_type (void) G_GNUC_CONST;
GType vala_ccode_member_access_module_get_type (void) G_GNUC_CONST;
GType vala_ccode_assignment_module_get_type (void) G_GNUC_CONST;
GType vala_ccode_method_call_module_get_type (void) G_GNUC_CONST;
GType vala_ccode_array_module_get_type (void) G_GNUC_CONST;
GType vala_ccode_delegate_module_get_type (void) G_GNUC_CONST;
GType vala_gerror_module_get_type (void) G_GNUC_CONST;
GType vala_gtype_module_get_type (void) G_GNUC_CONST;
gpointer vala_typeregister_function_ref (gpointer instance);
void vala_typeregister_function_unref (gpointer instance);
GParamSpec* vala_param_spec_typeregister_function (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_typeregister_function (GValue* value, gpointer v_object);
void vala_value_take_typeregister_function (GValue* value, gpointer v_object);
gpointer vala_value_get_typeregister_function (const GValue* value);
GType vala_typeregister_function_get_type (void) G_GNUC_CONST;
GType vala_gobject_module_get_type (void) G_GNUC_CONST;
GType vala_gsignal_module_get_type (void) G_GNUC_CONST;
enum  {
	VALA_GSIGNAL_MODULE_DUMMY_PROPERTY
};
static char* vala_gsignal_module_get_marshaller_type_name (ValaGSignalModule* self, ValaDataType* t, gboolean dbus);
char* vala_dbus_module_get_type_signature (ValaDataType* datatype);
static char* vala_gsignal_module_get_marshaller_type_name_for_parameter (ValaGSignalModule* self, ValaFormalParameter* param, gboolean dbus);
static char* vala_gsignal_module_real_get_marshaller_function (ValaCCodeBaseModule* base, ValaList* params, ValaDataType* return_type, const char* prefix, gboolean dbus);
static char* vala_gsignal_module_get_marshaller_signature (ValaGSignalModule* self, ValaList* params, ValaDataType* return_type, gboolean dbus);
static char* vala_gsignal_module_get_value_type_name_from_type_reference (ValaGSignalModule* self, ValaDataType* t);
static char* vala_gsignal_module_get_value_type_name_from_parameter (ValaGSignalModule* self, ValaFormalParameter* p);
static ValaCCodeExpression* vala_gsignal_module_get_signal_name_cexpression (ValaGSignalModule* self, ValaSignal* sig, ValaExpression* detail_expr, ValaCodeNode* node);
ValaLocalVariable* vala_ccode_base_module_get_temp_variable (ValaCCodeBaseModule* self, ValaDataType* type, gboolean value_owned, ValaCodeNode* node_reference, gboolean init);
ValaArrayList* vala_ccode_base_module_get_temp_vars (ValaCCodeBaseModule* self);
ValaArrayList* vala_ccode_base_module_get_temp_ref_vars (ValaCCodeBaseModule* self);
ValaCCodeExpression* vala_ccode_base_module_get_variable_cexpression (ValaCCodeBaseModule* self, const char* name);
static void vala_gsignal_module_real_visit_signal (ValaCodeVisitor* base, ValaSignal* sig);
void vala_ccode_method_module_generate_parameter (ValaCCodeMethodModule* self, ValaFormalParameter* param, ValaCCodeDeclarationSpace* decl_space, ValaMap* cparam_map, ValaMap* carg_map);
void vala_ccode_base_module_generate_marshaller (ValaCCodeBaseModule* self, ValaList* params, ValaDataType* return_type, gboolean dbus);
static void vala_gsignal_module_real_generate_marshaller (ValaCCodeBaseModule* base, ValaList* params, ValaDataType* return_type, gboolean dbus);
char* vala_ccode_base_module_get_marshaller_function (ValaCCodeBaseModule* self, ValaList* params, ValaDataType* return_type, const char* prefix, gboolean dbus);
static ValaCCodeFunctionCall* vala_gsignal_module_real_get_signal_creation (ValaCCodeBaseModule* base, ValaSignal* sig, ValaTypeSymbol* type);
static void _vala_array_add1 (char*** array, int* length, int* size, char* value);
static void _vala_array_add2 (char*** array, int* length, int* size, char* value);
static void _vala_array_add3 (char*** array, int* length, int* size, char* value);
static void _vala_array_add4 (char*** array, int* length, int* size, char* value);
static void _vala_array_add5 (char*** array, int* length, int* size, char* value);
static void _vala_array_add6 (char*** array, int* length, int* size, char* value);
static void _vala_array_add7 (char*** array, int* length, int* size, char* value);
ValaCCodeExpression* vala_gsignal_module_get_dbus_g_type (ValaGSignalModule* self, ValaDataType* data_type);
static ValaCCodeExpression* vala_gsignal_module_real_get_dbus_g_type (ValaGSignalModule* self, ValaDataType* data_type);
static void vala_gsignal_module_real_visit_element_access (ValaCodeVisitor* base, ValaElementAccess* expr);
static gboolean vala_gsignal_module_in_gobject_instance (ValaGSignalModule* self, ValaMethod* m);
static ValaCCodeExpression* vala_gsignal_module_emit_signal_assignment (ValaGSignalModule* self, ValaAssignment* assignment);
static ValaCCodeExpression* vala_gsignal_module_connect_signal (ValaGSignalModule* self, ValaSignal* sig, ValaExpression* signal_access, ValaExpression* handler, gboolean disconnect, gboolean after, ValaCodeNode* expr);
static void vala_gsignal_module_real_visit_assignment (ValaCodeVisitor* base, ValaAssignment* assignment);
static void vala_gsignal_module_real_visit_member_access (ValaCodeVisitor* base, ValaMemberAccess* expr);
ValaClass* vala_ccode_base_module_get_current_class (ValaCCodeBaseModule* self);
static void vala_gsignal_module_real_visit_method_call (ValaCodeVisitor* base, ValaMethodCall* expr);
char* vala_ccode_base_module_get_dynamic_signal_connect_wrapper_name (ValaCCodeBaseModule* self, ValaDynamicSignal* node);
char* vala_ccode_base_module_get_dynamic_signal_connect_after_wrapper_name (ValaCCodeBaseModule* self, ValaDynamicSignal* node);
char* vala_ccode_base_module_get_dynamic_signal_disconnect_wrapper_name (ValaCCodeBaseModule* self, ValaDynamicSignal* node);
ValaCCodeNode* vala_ccode_base_module_get_ccodenode (ValaCCodeBaseModule* self, ValaCodeNode* node);
ValaCCodeExpression* vala_ccode_base_module_get_result_cexpression (ValaCCodeBaseModule* self, const char* cname);
ValaCCodeExpression* vala_ccode_base_module_get_delegate_target_cexpression (ValaCCodeBaseModule* self, ValaExpression* delegate_expr, ValaCCodeExpression** delegate_target_destroy_notify);
ValaGSignalModule* vala_gsignal_module_new (void);
ValaGSignalModule* vala_gsignal_module_construct (GType object_type);
ValaGObjectModule* vala_gobject_module_new (void);
ValaGObjectModule* vala_gobject_module_construct (GType object_type);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static int _vala_strcmp0 (const char * str1, const char * str2);



static gpointer _vala_code_node_ref0 (gpointer self) {
	return self ? vala_code_node_ref (self) : NULL;
}


static char* vala_gsignal_module_get_marshaller_type_name (ValaGSignalModule* self, ValaDataType* t, gboolean dbus) {
	char* result = NULL;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (t != NULL, NULL);
	if (VALA_IS_POINTER_TYPE (t)) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = vala_data_type_get_type_parameter (t) != NULL;
	}
	if (_tmp0_) {
		result = g_strdup ("POINTER");
		return result;
	} else {
		if (VALA_IS_ERROR_TYPE (t)) {
			result = g_strdup ("POINTER");
			return result;
		} else {
			if (VALA_IS_ARRAY_TYPE (t)) {
				if (dbus) {
					result = g_strdup ("BOXED");
					return result;
				} else {
					if (vala_data_type_get_data_type (vala_array_type_get_element_type (VALA_ARRAY_TYPE (t))) == vala_data_type_get_data_type (((ValaCCodeBaseModule*) self)->string_type)) {
						result = g_strdup ("BOXED,INT");
						return result;
					} else {
						result = g_strdup ("POINTER,INT");
						return result;
					}
				}
			} else {
				if (VALA_IS_VOID_TYPE (t)) {
					result = g_strdup ("VOID");
					return result;
				} else {
					gboolean _tmp1_ = FALSE;
					if (dbus) {
						char* _tmp2_;
						_tmp1_ = g_str_has_prefix (_tmp2_ = vala_dbus_module_get_type_signature (t), "(");
						_g_free0 (_tmp2_);
					} else {
						_tmp1_ = FALSE;
					}
					if (_tmp1_) {
						result = g_strdup ("BOXED");
						return result;
					} else {
						if (VALA_IS_ENUM (vala_data_type_get_data_type (t))) {
							ValaEnum* en;
							en = _vala_code_node_ref0 (VALA_ENUM (vala_data_type_get_data_type (t)));
							if (dbus) {
								if (vala_enum_get_is_flags (en)) {
									result = g_strdup ("UINT");
									_vala_code_node_unref0 (en);
									return result;
								} else {
									result = g_strdup ("INT");
									_vala_code_node_unref0 (en);
									return result;
								}
							} else {
								result = vala_typesymbol_get_marshaller_type_name ((ValaTypeSymbol*) en);
								_vala_code_node_unref0 (en);
								return result;
							}
							_vala_code_node_unref0 (en);
						} else {
							result = vala_typesymbol_get_marshaller_type_name (vala_data_type_get_data_type (t));
							return result;
						}
					}
				}
			}
		}
	}
}


static char* vala_gsignal_module_get_marshaller_type_name_for_parameter (ValaGSignalModule* self, ValaFormalParameter* param, gboolean dbus) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (param != NULL, NULL);
	if (vala_formal_parameter_get_direction (param) != VALA_PARAMETER_DIRECTION_IN) {
		result = g_strdup ("POINTER");
		return result;
	} else {
		result = vala_gsignal_module_get_marshaller_type_name (self, vala_variable_get_variable_type ((ValaVariable*) param), dbus);
		return result;
	}
}


static char* string_replace (const char* self, const char* old, const char* replacement) {
	char* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		char* _tmp0_;
		GRegex* _tmp1_;
		GRegex* regex;
		char* _tmp2_;
		regex = (_tmp1_ = g_regex_new (_tmp0_ = g_regex_escape_string (old, -1), 0, 0, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch4_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp2_ = g_regex_replace_literal (regex, self, (gssize) (-1), 0, replacement, 0, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch4_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp2_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally4;
	__catch4_g_regex_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_assert_not_reached ();
			_g_error_free0 (e);
		}
	}
	__finally4:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static char* vala_gsignal_module_real_get_marshaller_function (ValaCCodeBaseModule* base, ValaList* params, ValaDataType* return_type, const char* prefix, gboolean dbus) {
	ValaGSignalModule * self;
	char* result = NULL;
	char* signature;
	char* ret;
	char* _tmp0_;
	char* _tmp1_;
	gboolean _tmp2_ = FALSE;
	self = (ValaGSignalModule*) base;
	g_return_val_if_fail (params != NULL, NULL);
	g_return_val_if_fail (return_type != NULL, NULL);
	signature = vala_gsignal_module_get_marshaller_signature (self, params, return_type, dbus);
	ret = NULL;
	if (prefix == NULL) {
		if (vala_collection_contains ((ValaCollection*) ((ValaCCodeBaseModule*) self)->predefined_marshal_set, signature)) {
			prefix = "g_cclosure_marshal";
		} else {
			prefix = "g_cclosure_user_marshal";
		}
	}
	ret = (_tmp1_ = g_strdup_printf ("%s_%s_", prefix, _tmp0_ = vala_gsignal_module_get_marshaller_type_name (self, return_type, dbus)), _g_free0 (ret), _tmp1_);
	_g_free0 (_tmp0_);
	if (params == NULL) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = vala_collection_get_size ((ValaCollection*) params) == 0;
	}
	if (_tmp2_) {
		char* _tmp3_;
		ret = (_tmp3_ = g_strconcat (ret, "_VOID", NULL), _g_free0 (ret), _tmp3_);
	} else {
		{
			ValaIterator* _p_it;
			_p_it = vala_iterable_iterator ((ValaIterable*) params);
			while (TRUE) {
				ValaFormalParameter* p;
				char* _tmp4_;
				char* _tmp5_;
				char* _tmp6_;
				if (!vala_iterator_next (_p_it)) {
					break;
				}
				p = (ValaFormalParameter*) vala_iterator_get (_p_it);
				ret = (_tmp6_ = g_strdup_printf ("%s_%s", ret, _tmp5_ = string_replace (_tmp4_ = vala_gsignal_module_get_marshaller_type_name_for_parameter (self, p, dbus), ",", "_")), _g_free0 (ret), _tmp6_);
				_g_free0 (_tmp5_);
				_g_free0 (_tmp4_);
				_vala_code_node_unref0 (p);
			}
			_vala_collection_object_unref0 (_p_it);
		}
	}
	result = ret;
	_g_free0 (signature);
	return result;
}


static char* vala_gsignal_module_get_value_type_name_from_type_reference (ValaGSignalModule* self, ValaDataType* t) {
	char* result = NULL;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (t != NULL, NULL);
	if (VALA_IS_POINTER_TYPE (t)) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = vala_data_type_get_type_parameter (t) != NULL;
	}
	if (_tmp0_) {
		result = g_strdup ("gpointer");
		return result;
	} else {
		if (VALA_IS_VOID_TYPE (t)) {
			result = g_strdup ("void");
			return result;
		} else {
			if (vala_data_type_get_data_type (t) == vala_data_type_get_data_type (((ValaCCodeBaseModule*) self)->string_type)) {
				result = g_strdup ("const char*");
				return result;
			} else {
				gboolean _tmp1_ = FALSE;
				if (VALA_IS_CLASS (vala_data_type_get_data_type (t))) {
					_tmp1_ = TRUE;
				} else {
					_tmp1_ = VALA_IS_INTERFACE (vala_data_type_get_data_type (t));
				}
				if (_tmp1_) {
					result = g_strdup ("gpointer");
					return result;
				} else {
					if (VALA_IS_STRUCT (vala_data_type_get_data_type (t))) {
						ValaStruct* st;
						st = _vala_code_node_ref0 (VALA_STRUCT (vala_data_type_get_data_type (t)));
						if (vala_struct_is_simple_type (st)) {
							result = vala_typesymbol_get_cname (vala_data_type_get_data_type (t), FALSE);
							_vala_code_node_unref0 (st);
							return result;
						} else {
							result = g_strdup ("gpointer");
							_vala_code_node_unref0 (st);
							return result;
						}
						_vala_code_node_unref0 (st);
					} else {
						if (VALA_IS_ENUM (vala_data_type_get_data_type (t))) {
							result = g_strdup ("gint");
							return result;
						} else {
							if (VALA_IS_ARRAY_TYPE (t)) {
								result = g_strdup ("gpointer");
								return result;
							} else {
								if (VALA_IS_ERROR_TYPE (t)) {
									result = g_strdup ("gpointer");
									return result;
								}
							}
						}
					}
				}
			}
		}
	}
	result = NULL;
	return result;
}


static char* vala_gsignal_module_get_value_type_name_from_parameter (ValaGSignalModule* self, ValaFormalParameter* p) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (p != NULL, NULL);
	if (vala_formal_parameter_get_direction (p) != VALA_PARAMETER_DIRECTION_IN) {
		result = g_strdup ("gpointer");
		return result;
	} else {
		result = vala_gsignal_module_get_value_type_name_from_type_reference (self, vala_variable_get_variable_type ((ValaVariable*) p));
		return result;
	}
}


static char* vala_gsignal_module_get_marshaller_signature (ValaGSignalModule* self, ValaList* params, ValaDataType* return_type, gboolean dbus) {
	char* result = NULL;
	char* signature;
	char* _tmp0_;
	char* _tmp1_;
	gboolean _tmp2_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (params != NULL, NULL);
	g_return_val_if_fail (return_type != NULL, NULL);
	signature = NULL;
	signature = (_tmp1_ = g_strdup_printf ("%s:", _tmp0_ = vala_gsignal_module_get_marshaller_type_name (self, return_type, dbus)), _g_free0 (signature), _tmp1_);
	_g_free0 (_tmp0_);
	if (params == NULL) {
		_tmp2_ = TRUE;
	} else {
		_tmp2_ = vala_collection_get_size ((ValaCollection*) params) == 0;
	}
	if (_tmp2_) {
		char* _tmp3_;
		signature = (_tmp3_ = g_strconcat (signature, "VOID", NULL), _g_free0 (signature), _tmp3_);
	} else {
		gboolean first;
		first = TRUE;
		{
			ValaIterator* _p_it;
			_p_it = vala_iterable_iterator ((ValaIterable*) params);
			while (TRUE) {
				ValaFormalParameter* p;
				if (!vala_iterator_next (_p_it)) {
					break;
				}
				p = (ValaFormalParameter*) vala_iterator_get (_p_it);
				if (first) {
					char* _tmp4_;
					char* _tmp5_;
					signature = (_tmp5_ = g_strconcat (signature, _tmp4_ = vala_gsignal_module_get_marshaller_type_name_for_parameter (self, p, dbus), NULL), _g_free0 (signature), _tmp5_);
					_g_free0 (_tmp4_);
					first = FALSE;
				} else {
					char* _tmp6_;
					char* _tmp7_;
					signature = (_tmp7_ = g_strdup_printf ("%s,%s", signature, _tmp6_ = vala_gsignal_module_get_marshaller_type_name_for_parameter (self, p, dbus)), _g_free0 (signature), _tmp7_);
					_g_free0 (_tmp6_);
				}
				_vala_code_node_unref0 (p);
			}
			_vala_collection_object_unref0 (_p_it);
		}
	}
	result = signature;
	return result;
}


static ValaCCodeExpression* vala_gsignal_module_get_signal_name_cexpression (ValaGSignalModule* self, ValaSignal* sig, ValaExpression* detail_expr, ValaCodeNode* node) {
	ValaCCodeExpression* result = NULL;
	gboolean _tmp0_ = FALSE;
	ValaLocalVariable* detail_decl;
	ValaCCodeIdentifier* _tmp3_;
	ValaCCodeFunctionCall* _tmp4_;
	ValaCCodeFunctionCall* ccall;
	ValaCCodeConstant* _tmp5_;
	ValaCCodeConstant* _tmp6_;
	ValaCCodeCommaExpression* ccomma;
	ValaCCodeExpression* _tmp7_;
	ValaCCodeAssignment* _tmp8_;
	ValaCCodeExpression* _tmp9_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (sig != NULL, NULL);
	g_return_val_if_fail (node != NULL, NULL);
	if (detail_expr == NULL) {
		result = (ValaCCodeExpression*) vala_signal_get_canonical_cconstant (sig, NULL);
		return result;
	}
	if (VALA_IS_NULL_TYPE (vala_expression_get_value_type (detail_expr))) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = !vala_data_type_compatible (vala_expression_get_value_type (detail_expr), ((ValaCCodeBaseModule*) self)->string_type);
	}
	if (_tmp0_) {
		vala_code_node_set_error (node, TRUE);
		vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) detail_expr), "only string details are supported");
		result = NULL;
		return result;
	}
	if (VALA_IS_STRING_LITERAL (detail_expr)) {
		char* _tmp1_;
		ValaCCodeExpression* _tmp2_;
		result = (_tmp2_ = (ValaCCodeExpression*) vala_signal_get_canonical_cconstant (sig, _tmp1_ = vala_string_literal_eval (VALA_STRING_LITERAL (detail_expr))), _g_free0 (_tmp1_), _tmp2_);
		return result;
	}
	detail_decl = vala_ccode_base_module_get_temp_variable ((ValaCCodeBaseModule*) self, vala_expression_get_value_type (detail_expr), TRUE, node, TRUE);
	vala_list_insert ((ValaList*) vala_ccode_base_module_get_temp_vars ((ValaCCodeBaseModule*) self), 0, detail_decl);
	vala_list_insert ((ValaList*) vala_ccode_base_module_get_temp_ref_vars ((ValaCCodeBaseModule*) self), 0, detail_decl);
	ccall = (_tmp4_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp3_ = vala_ccode_identifier_new ("g_strconcat"))), _vala_ccode_node_unref0 (_tmp3_), _tmp4_);
	vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp5_ = vala_signal_get_canonical_cconstant (sig, "")));
	_vala_ccode_node_unref0 (_tmp5_);
	vala_ccode_function_call_add_argument (ccall, VALA_CCODE_EXPRESSION (vala_code_node_get_ccodenode ((ValaCodeNode*) detail_expr)));
	vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp6_ = vala_ccode_constant_new ("NULL")));
	_vala_ccode_node_unref0 (_tmp6_);
	ccomma = vala_ccode_comma_expression_new ();
	vala_ccode_comma_expression_append_expression (ccomma, (ValaCCodeExpression*) (_tmp8_ = vala_ccode_assignment_new (_tmp7_ = vala_ccode_base_module_get_variable_cexpression ((ValaCCodeBaseModule*) self, vala_symbol_get_name ((ValaSymbol*) detail_decl)), (ValaCCodeExpression*) ccall, VALA_CCODE_ASSIGNMENT_OPERATOR_SIMPLE)));
	_vala_ccode_node_unref0 (_tmp8_);
	_vala_ccode_node_unref0 (_tmp7_);
	vala_ccode_comma_expression_append_expression (ccomma, _tmp9_ = vala_ccode_base_module_get_variable_cexpression ((ValaCCodeBaseModule*) self, vala_symbol_get_name ((ValaSymbol*) detail_decl)));
	_vala_ccode_node_unref0 (_tmp9_);
	result = (ValaCCodeExpression*) ccomma;
	_vala_ccode_node_unref0 (ccall);
	_vala_code_node_unref0 (detail_decl);
	return result;
}


static void vala_gsignal_module_real_visit_signal (ValaCodeVisitor* base, ValaSignal* sig) {
	ValaGSignalModule * self;
	ValaSymbol* _tmp0_;
	ValaClass* cl;
	gboolean _tmp1_ = FALSE;
	ValaList* _tmp9_;
	self = (ValaGSignalModule*) base;
	g_return_if_fail (sig != NULL);
	cl = _vala_code_node_ref0 ((_tmp0_ = vala_symbol_get_parent_symbol ((ValaSymbol*) sig), VALA_IS_CLASS (_tmp0_) ? ((ValaClass*) _tmp0_) : NULL));
	if (cl != NULL) {
		_tmp1_ = vala_class_get_is_compact (cl);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		vala_code_node_set_error ((ValaCodeNode*) sig, TRUE);
		vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) sig), "Signals are not supported in compact classes");
		_vala_code_node_unref0 (cl);
		return;
	}
	if (cl != NULL) {
		{
			ValaList* _tmp2_;
			ValaIterator* _tmp3_;
			ValaIterator* _base_type_it;
			_base_type_it = (_tmp3_ = vala_iterable_iterator ((ValaIterable*) (_tmp2_ = vala_class_get_base_types (cl))), _vala_collection_object_unref0 (_tmp2_), _tmp3_);
			while (TRUE) {
				ValaDataType* base_type;
				ValaSymbol* _tmp4_;
				gboolean _tmp5_;
				if (!vala_iterator_next (_base_type_it)) {
					break;
				}
				base_type = (ValaDataType*) vala_iterator_get (_base_type_it);
				if ((_tmp5_ = VALA_IS_SIGNAL (_tmp4_ = vala_semantic_analyzer_symbol_lookup_inherited ((ValaSymbol*) vala_data_type_get_data_type (base_type), vala_symbol_get_name ((ValaSymbol*) sig))), _vala_code_node_unref0 (_tmp4_), _tmp5_)) {
					vala_code_node_set_error ((ValaCodeNode*) sig, TRUE);
					vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) sig), "Signals with the same name as a signal in a base type are not supporte" \
"d");
					_vala_code_node_unref0 (base_type);
					_vala_collection_object_unref0 (_base_type_it);
					_vala_code_node_unref0 (cl);
					return;
				}
				_vala_code_node_unref0 (base_type);
			}
			_vala_collection_object_unref0 (_base_type_it);
		}
	}
	vala_code_node_accept_children ((ValaCodeNode*) sig, (ValaCodeVisitor*) self);
	{
		ValaList* _tmp6_;
		ValaIterator* _tmp7_;
		ValaIterator* _p_it;
		_p_it = (_tmp7_ = vala_iterable_iterator ((ValaIterable*) (_tmp6_ = vala_signal_get_parameters (sig))), _vala_collection_object_unref0 (_tmp6_), _tmp7_);
		while (TRUE) {
			ValaFormalParameter* p;
			ValaHashMap* _tmp8_;
			if (!vala_iterator_next (_p_it)) {
				break;
			}
			p = (ValaFormalParameter*) vala_iterator_get (_p_it);
			vala_ccode_method_module_generate_parameter ((ValaCCodeMethodModule*) self, p, ((ValaCCodeBaseModule*) self)->source_declarations, (ValaMap*) (_tmp8_ = vala_hash_map_new (G_TYPE_INT, NULL, NULL, VALA_TYPE_CCODE_FORMAL_PARAMETER, (GBoxedCopyFunc) vala_ccode_node_ref, vala_ccode_node_unref, g_direct_hash, g_direct_equal, g_direct_equal)), NULL);
			_vala_collection_object_unref0 (_tmp8_);
			_vala_code_node_unref0 (p);
		}
		_vala_collection_object_unref0 (_p_it);
	}
	vala_ccode_base_module_generate_marshaller ((ValaCCodeBaseModule*) self, _tmp9_ = vala_signal_get_parameters (sig), vala_signal_get_return_type (sig), FALSE);
	_vala_collection_object_unref0 (_tmp9_);
	_vala_code_node_unref0 (cl);
}


static void vala_gsignal_module_real_generate_marshaller (ValaCCodeBaseModule* base, ValaList* params, ValaDataType* return_type, gboolean dbus) {
	ValaGSignalModule * self;
	char* signature;
	gint n_params = 0;
	gint i = 0;
	char* _tmp0_;
	gboolean _tmp1_ = FALSE;
	char* _tmp2_;
	ValaCCodeFunction* _tmp3_;
	ValaCCodeFunction* signal_marshaller;
	ValaCCodeFormalParameter* _tmp4_;
	ValaCCodeFormalParameter* _tmp5_;
	ValaCCodeFormalParameter* _tmp6_;
	ValaCCodeFormalParameter* _tmp7_;
	ValaCCodeFormalParameter* _tmp8_;
	ValaCCodeFormalParameter* _tmp9_;
	ValaCCodeFunction* _tmp10_;
	ValaCCodeBlock* marshaller_body;
	char* _tmp11_;
	ValaCCodeFunctionDeclarator* _tmp12_;
	ValaCCodeFunctionDeclarator* callback_decl;
	ValaCCodeFormalParameter* _tmp13_;
	ValaCCodeFormalParameter* _tmp20_;
	char* _tmp21_;
	ValaCCodeTypeDefinition* _tmp22_;
	char* _tmp23_;
	ValaCCodeDeclaration* _tmp24_;
	ValaCCodeDeclaration* var_decl;
	ValaCCodeVariableDeclarator* _tmp25_;
	ValaCCodeDeclaration* _tmp26_;
	ValaCCodeIdentifier* _tmp27_;
	ValaCCodeCastExpression* _tmp28_;
	ValaCCodeVariableDeclarator* _tmp29_;
	ValaCCodeDeclaration* _tmp30_;
	ValaCCodeVariableDeclarator* _tmp31_;
	ValaCCodeVariableDeclarator* _tmp32_;
	ValaCCodeFunctionCall* fc;
	gboolean _tmp33_ = FALSE;
	ValaCCodeIdentifier* _tmp43_;
	ValaCCodeFunctionCall* _tmp44_;
	ValaCCodeIdentifier* _tmp45_;
	char* _tmp46_;
	ValaCCodeConstant* _tmp47_;
	ValaCCodeBinaryExpression* _tmp48_;
	ValaCCodeExpressionStatement* _tmp49_;
	ValaCCodeIdentifier* _tmp50_;
	ValaCCodeMemberAccess* _tmp51_;
	ValaCCodeMemberAccess* data;
	ValaCCodeIdentifier* _tmp52_;
	ValaCCodeMemberAccess* _tmp53_;
	ValaCCodeMemberAccess* _tmp54_;
	ValaCCodeMemberAccess* param;
	ValaCCodeConstant* _tmp55_;
	ValaCCodeFunctionCall* _tmp56_;
	ValaCCodeFunctionCall* cond;
	ValaCCodeIdentifier* _tmp57_;
	ValaCCodeBlock* true_block;
	ValaCCodeIdentifier* _tmp58_;
	ValaCCodeAssignment* _tmp59_;
	ValaCCodeExpressionStatement* _tmp60_;
	ValaCCodeIdentifier* _tmp61_;
	ValaCCodeAssignment* _tmp62_;
	ValaCCodeExpressionStatement* _tmp63_;
	ValaCCodeBlock* false_block;
	ValaCCodeIdentifier* _tmp64_;
	ValaCCodeAssignment* _tmp65_;
	ValaCCodeExpressionStatement* _tmp66_;
	ValaCCodeIdentifier* _tmp67_;
	ValaCCodeAssignment* _tmp68_;
	ValaCCodeExpressionStatement* _tmp69_;
	ValaCCodeIfStatement* _tmp70_;
	ValaCCodeIdentifier* _tmp71_;
	ValaCCodeIdentifier* _tmp72_;
	ValaCCodeIdentifier* _tmp73_;
	ValaCCodeIdentifier* _tmp74_;
	ValaCCodeMemberAccess* _tmp75_;
	ValaCCodeConditionalExpression* _tmp76_;
	char* _tmp77_;
	ValaCCodeCastExpression* _tmp78_;
	ValaCCodeAssignment* _tmp79_;
	ValaCCodeAssignment* c_assign;
	ValaCCodeExpressionStatement* _tmp80_;
	ValaCCodeIdentifier* _tmp81_;
	ValaCCodeFunctionCall* _tmp82_;
	ValaCCodeIdentifier* _tmp83_;
	ValaCCodeIdentifier* _tmp111_;
	gboolean _tmp112_ = FALSE;
	self = (ValaGSignalModule*) base;
	g_return_if_fail (params != NULL);
	g_return_if_fail (return_type != NULL);
	signature = NULL;
	signature = (_tmp0_ = vala_gsignal_module_get_marshaller_signature (self, params, return_type, dbus), _g_free0 (signature), _tmp0_);
	if (vala_collection_contains ((ValaCollection*) ((ValaCCodeBaseModule*) self)->predefined_marshal_set, signature)) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = vala_collection_contains ((ValaCollection*) ((ValaCCodeBaseModule*) self)->user_marshal_set, signature);
	}
	if (_tmp1_) {
		_g_free0 (signature);
		return;
	}
	signal_marshaller = (_tmp3_ = vala_ccode_function_new (_tmp2_ = vala_ccode_base_module_get_marshaller_function ((ValaCCodeBaseModule*) self, params, return_type, NULL, dbus), "void"), _g_free0 (_tmp2_), _tmp3_);
	vala_ccode_function_set_modifiers (signal_marshaller, VALA_CCODE_MODIFIERS_STATIC);
	vala_ccode_function_add_parameter (signal_marshaller, _tmp4_ = vala_ccode_formal_parameter_new ("closure", "GClosure *"));
	_vala_ccode_node_unref0 (_tmp4_);
	vala_ccode_function_add_parameter (signal_marshaller, _tmp5_ = vala_ccode_formal_parameter_new ("return_value", "GValue *"));
	_vala_ccode_node_unref0 (_tmp5_);
	vala_ccode_function_add_parameter (signal_marshaller, _tmp6_ = vala_ccode_formal_parameter_new ("n_param_values", "guint"));
	_vala_ccode_node_unref0 (_tmp6_);
	vala_ccode_function_add_parameter (signal_marshaller, _tmp7_ = vala_ccode_formal_parameter_new ("param_values", "const GValue *"));
	_vala_ccode_node_unref0 (_tmp7_);
	vala_ccode_function_add_parameter (signal_marshaller, _tmp8_ = vala_ccode_formal_parameter_new ("invocation_hint", "gpointer"));
	_vala_ccode_node_unref0 (_tmp8_);
	vala_ccode_function_add_parameter (signal_marshaller, _tmp9_ = vala_ccode_formal_parameter_new ("marshal_data", "gpointer"));
	_vala_ccode_node_unref0 (_tmp9_);
	vala_ccode_fragment_append (((ValaCCodeBaseModule*) self)->source_signal_marshaller_declaration, (ValaCCodeNode*) (_tmp10_ = vala_ccode_function_copy (signal_marshaller)));
	_vala_ccode_node_unref0 (_tmp10_);
	marshaller_body = vala_ccode_block_new ();
	callback_decl = (_tmp12_ = vala_ccode_function_declarator_new (_tmp11_ = vala_ccode_base_module_get_marshaller_function ((ValaCCodeBaseModule*) self, params, return_type, "GMarshalFunc", dbus)), _g_free0 (_tmp11_), _tmp12_);
	vala_ccode_function_declarator_add_parameter (callback_decl, _tmp13_ = vala_ccode_formal_parameter_new ("data1", "gpointer"));
	_vala_ccode_node_unref0 (_tmp13_);
	n_params = 1;
	{
		ValaIterator* _p_it;
		_p_it = vala_iterable_iterator ((ValaIterable*) params);
		while (TRUE) {
			ValaFormalParameter* p;
			char* _tmp14_;
			char* _tmp15_;
			ValaCCodeFormalParameter* _tmp16_;
			gboolean _tmp17_ = FALSE;
			if (!vala_iterator_next (_p_it)) {
				break;
			}
			p = (ValaFormalParameter*) vala_iterator_get (_p_it);
			vala_ccode_function_declarator_add_parameter (callback_decl, _tmp16_ = vala_ccode_formal_parameter_new (_tmp14_ = g_strdup_printf ("arg_%d", n_params), _tmp15_ = vala_gsignal_module_get_value_type_name_from_parameter (self, p)));
			_vala_ccode_node_unref0 (_tmp16_);
			_g_free0 (_tmp15_);
			_g_free0 (_tmp14_);
			n_params++;
			if (vala_data_type_is_array (vala_variable_get_variable_type ((ValaVariable*) p))) {
				_tmp17_ = !dbus;
			} else {
				_tmp17_ = FALSE;
			}
			if (_tmp17_) {
				char* _tmp18_;
				ValaCCodeFormalParameter* _tmp19_;
				vala_ccode_function_declarator_add_parameter (callback_decl, _tmp19_ = vala_ccode_formal_parameter_new (_tmp18_ = g_strdup_printf ("arg_%d", n_params), "gint"));
				_vala_ccode_node_unref0 (_tmp19_);
				_g_free0 (_tmp18_);
				n_params++;
			}
			_vala_code_node_unref0 (p);
		}
		_vala_collection_object_unref0 (_p_it);
	}
	vala_ccode_function_declarator_add_parameter (callback_decl, _tmp20_ = vala_ccode_formal_parameter_new ("data2", "gpointer"));
	_vala_ccode_node_unref0 (_tmp20_);
	vala_ccode_block_add_statement (marshaller_body, (ValaCCodeNode*) (_tmp22_ = vala_ccode_type_definition_new (_tmp21_ = vala_gsignal_module_get_value_type_name_from_type_reference (self, return_type), (ValaCCodeDeclarator*) callback_decl)));
	_vala_ccode_node_unref0 (_tmp22_);
	_g_free0 (_tmp21_);
	var_decl = (_tmp24_ = vala_ccode_declaration_new (_tmp23_ = vala_ccode_base_module_get_marshaller_function ((ValaCCodeBaseModule*) self, params, return_type, "GMarshalFunc", dbus)), _g_free0 (_tmp23_), _tmp24_);
	vala_ccode_declaration_set_modifiers (var_decl, VALA_CCODE_MODIFIERS_REGISTER);
	vala_ccode_declaration_add_declarator (var_decl, (ValaCCodeDeclarator*) (_tmp25_ = vala_ccode_variable_declarator_new ("callback", NULL, NULL)));
	_vala_ccode_node_unref0 (_tmp25_);
	vala_ccode_block_add_statement (marshaller_body, (ValaCCodeNode*) var_decl);
	var_decl = (_tmp26_ = vala_ccode_declaration_new ("GCClosure *"), _vala_ccode_node_unref0 (var_decl), _tmp26_);
	vala_ccode_declaration_set_modifiers (var_decl, VALA_CCODE_MODIFIERS_REGISTER);
	vala_ccode_declaration_add_declarator (var_decl, (ValaCCodeDeclarator*) (_tmp29_ = vala_ccode_variable_declarator_new ("cc", (ValaCCodeExpression*) (_tmp28_ = vala_ccode_cast_expression_new ((ValaCCodeExpression*) (_tmp27_ = vala_ccode_identifier_new ("closure")), "GCClosure *")), NULL)));
	_vala_ccode_node_unref0 (_tmp29_);
	_vala_ccode_node_unref0 (_tmp28_);
	_vala_ccode_node_unref0 (_tmp27_);
	vala_ccode_block_add_statement (marshaller_body, (ValaCCodeNode*) var_decl);
	var_decl = (_tmp30_ = vala_ccode_declaration_new ("gpointer"), _vala_ccode_node_unref0 (var_decl), _tmp30_);
	vala_ccode_declaration_set_modifiers (var_decl, VALA_CCODE_MODIFIERS_REGISTER);
	vala_ccode_declaration_add_declarator (var_decl, (ValaCCodeDeclarator*) (_tmp31_ = vala_ccode_variable_declarator_new ("data1", NULL, NULL)));
	_vala_ccode_node_unref0 (_tmp31_);
	vala_ccode_declaration_add_declarator (var_decl, (ValaCCodeDeclarator*) (_tmp32_ = vala_ccode_variable_declarator_new ("data2", NULL, NULL)));
	_vala_ccode_node_unref0 (_tmp32_);
	vala_ccode_block_add_statement (marshaller_body, (ValaCCodeNode*) var_decl);
	fc = NULL;
	if (vala_data_type_get_data_type (return_type) != NULL) {
		_tmp33_ = TRUE;
	} else {
		_tmp33_ = vala_data_type_is_array (return_type);
	}
	if (_tmp33_) {
		char* _tmp34_;
		ValaCCodeDeclaration* _tmp35_;
		ValaCCodeVariableDeclarator* _tmp36_;
		ValaCCodeIdentifier* _tmp37_;
		ValaCCodeFunctionCall* _tmp38_;
		ValaCCodeIdentifier* _tmp39_;
		ValaCCodeConstant* _tmp40_;
		ValaCCodeBinaryExpression* _tmp41_;
		ValaCCodeExpressionStatement* _tmp42_;
		var_decl = (_tmp35_ = vala_ccode_declaration_new (_tmp34_ = vala_gsignal_module_get_value_type_name_from_type_reference (self, return_type)), _vala_ccode_node_unref0 (var_decl), _tmp35_);
		_g_free0 (_tmp34_);
		vala_ccode_declaration_add_declarator (var_decl, (ValaCCodeDeclarator*) (_tmp36_ = vala_ccode_variable_declarator_new ("v_return", NULL, NULL)));
		_vala_ccode_node_unref0 (_tmp36_);
		vala_ccode_block_add_statement (marshaller_body, (ValaCCodeNode*) var_decl);
		fc = (_tmp38_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp37_ = vala_ccode_identifier_new ("g_return_if_fail"))), _vala_ccode_node_unref0 (fc), _tmp38_);
		_vala_ccode_node_unref0 (_tmp37_);
		vala_ccode_function_call_add_argument (fc, (ValaCCodeExpression*) (_tmp41_ = vala_ccode_binary_expression_new (VALA_CCODE_BINARY_OPERATOR_INEQUALITY, (ValaCCodeExpression*) (_tmp39_ = vala_ccode_identifier_new ("return_value")), (ValaCCodeExpression*) (_tmp40_ = vala_ccode_constant_new ("NULL")))));
		_vala_ccode_node_unref0 (_tmp41_);
		_vala_ccode_node_unref0 (_tmp40_);
		_vala_ccode_node_unref0 (_tmp39_);
		vala_ccode_block_add_statement (marshaller_body, (ValaCCodeNode*) (_tmp42_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) fc)));
		_vala_ccode_node_unref0 (_tmp42_);
	}
	fc = (_tmp44_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp43_ = vala_ccode_identifier_new ("g_return_if_fail"))), _vala_ccode_node_unref0 (fc), _tmp44_);
	_vala_ccode_node_unref0 (_tmp43_);
	vala_ccode_function_call_add_argument (fc, (ValaCCodeExpression*) (_tmp48_ = vala_ccode_binary_expression_new (VALA_CCODE_BINARY_OPERATOR_EQUALITY, (ValaCCodeExpression*) (_tmp45_ = vala_ccode_identifier_new ("n_param_values")), (ValaCCodeExpression*) (_tmp47_ = vala_ccode_constant_new (_tmp46_ = g_strdup_printf ("%i", n_params))))));
	_vala_ccode_node_unref0 (_tmp48_);
	_vala_ccode_node_unref0 (_tmp47_);
	_g_free0 (_tmp46_);
	_vala_ccode_node_unref0 (_tmp45_);
	vala_ccode_block_add_statement (marshaller_body, (ValaCCodeNode*) (_tmp49_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) fc)));
	_vala_ccode_node_unref0 (_tmp49_);
	data = (_tmp51_ = vala_ccode_member_access_new ((ValaCCodeExpression*) (_tmp50_ = vala_ccode_identifier_new ("closure")), "data", TRUE), _vala_ccode_node_unref0 (_tmp50_), _tmp51_);
	param = (_tmp54_ = vala_ccode_member_access_new ((ValaCCodeExpression*) (_tmp53_ = vala_ccode_member_access_new ((ValaCCodeExpression*) (_tmp52_ = vala_ccode_identifier_new ("param_values")), "data[0]", TRUE)), "v_pointer", FALSE), _vala_ccode_node_unref0 (_tmp53_), _vala_ccode_node_unref0 (_tmp52_), _tmp54_);
	cond = (_tmp56_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp55_ = vala_ccode_constant_new ("G_CCLOSURE_SWAP_DATA"))), _vala_ccode_node_unref0 (_tmp55_), _tmp56_);
	vala_ccode_function_call_add_argument (cond, (ValaCCodeExpression*) (_tmp57_ = vala_ccode_identifier_new ("closure")));
	_vala_ccode_node_unref0 (_tmp57_);
	true_block = vala_ccode_block_new ();
	vala_ccode_block_add_statement (true_block, (ValaCCodeNode*) (_tmp60_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) (_tmp59_ = vala_ccode_assignment_new ((ValaCCodeExpression*) (_tmp58_ = vala_ccode_identifier_new ("data1")), (ValaCCodeExpression*) data, VALA_CCODE_ASSIGNMENT_OPERATOR_SIMPLE)))));
	_vala_ccode_node_unref0 (_tmp60_);
	_vala_ccode_node_unref0 (_tmp59_);
	_vala_ccode_node_unref0 (_tmp58_);
	vala_ccode_block_add_statement (true_block, (ValaCCodeNode*) (_tmp63_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) (_tmp62_ = vala_ccode_assignment_new ((ValaCCodeExpression*) (_tmp61_ = vala_ccode_identifier_new ("data2")), (ValaCCodeExpression*) param, VALA_CCODE_ASSIGNMENT_OPERATOR_SIMPLE)))));
	_vala_ccode_node_unref0 (_tmp63_);
	_vala_ccode_node_unref0 (_tmp62_);
	_vala_ccode_node_unref0 (_tmp61_);
	false_block = vala_ccode_block_new ();
	vala_ccode_block_add_statement (false_block, (ValaCCodeNode*) (_tmp66_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) (_tmp65_ = vala_ccode_assignment_new ((ValaCCodeExpression*) (_tmp64_ = vala_ccode_identifier_new ("data1")), (ValaCCodeExpression*) param, VALA_CCODE_ASSIGNMENT_OPERATOR_SIMPLE)))));
	_vala_ccode_node_unref0 (_tmp66_);
	_vala_ccode_node_unref0 (_tmp65_);
	_vala_ccode_node_unref0 (_tmp64_);
	vala_ccode_block_add_statement (false_block, (ValaCCodeNode*) (_tmp69_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) (_tmp68_ = vala_ccode_assignment_new ((ValaCCodeExpression*) (_tmp67_ = vala_ccode_identifier_new ("data2")), (ValaCCodeExpression*) data, VALA_CCODE_ASSIGNMENT_OPERATOR_SIMPLE)))));
	_vala_ccode_node_unref0 (_tmp69_);
	_vala_ccode_node_unref0 (_tmp68_);
	_vala_ccode_node_unref0 (_tmp67_);
	vala_ccode_block_add_statement (marshaller_body, (ValaCCodeNode*) (_tmp70_ = vala_ccode_if_statement_new ((ValaCCodeExpression*) cond, (ValaCCodeStatement*) true_block, (ValaCCodeStatement*) false_block)));
	_vala_ccode_node_unref0 (_tmp70_);
	c_assign = (_tmp79_ = vala_ccode_assignment_new ((ValaCCodeExpression*) (_tmp71_ = vala_ccode_identifier_new ("callback")), (ValaCCodeExpression*) (_tmp78_ = vala_ccode_cast_expression_new ((ValaCCodeExpression*) (_tmp76_ = vala_ccode_conditional_expression_new ((ValaCCodeExpression*) (_tmp72_ = vala_ccode_identifier_new ("marshal_data")), (ValaCCodeExpression*) (_tmp73_ = vala_ccode_identifier_new ("marshal_data")), (ValaCCodeExpression*) (_tmp75_ = vala_ccode_member_access_new ((ValaCCodeExpression*) (_tmp74_ = vala_ccode_identifier_new ("cc")), "callback", TRUE)))), _tmp77_ = vala_ccode_base_module_get_marshaller_function ((ValaCCodeBaseModule*) self, params, return_type, "GMarshalFunc", dbus))), VALA_CCODE_ASSIGNMENT_OPERATOR_SIMPLE), _vala_ccode_node_unref0 (_tmp78_), _g_free0 (_tmp77_), _vala_ccode_node_unref0 (_tmp76_), _vala_ccode_node_unref0 (_tmp75_), _vala_ccode_node_unref0 (_tmp74_), _vala_ccode_node_unref0 (_tmp73_), _vala_ccode_node_unref0 (_tmp72_), _vala_ccode_node_unref0 (_tmp71_), _tmp79_);
	vala_ccode_block_add_statement (marshaller_body, (ValaCCodeNode*) (_tmp80_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) c_assign)));
	_vala_ccode_node_unref0 (_tmp80_);
	fc = (_tmp82_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp81_ = vala_ccode_identifier_new ("callback"))), _vala_ccode_node_unref0 (fc), _tmp82_);
	_vala_ccode_node_unref0 (_tmp81_);
	vala_ccode_function_call_add_argument (fc, (ValaCCodeExpression*) (_tmp83_ = vala_ccode_identifier_new ("data1")));
	_vala_ccode_node_unref0 (_tmp83_);
	i = 1;
	{
		ValaIterator* _p_it;
		_p_it = vala_iterable_iterator ((ValaIterable*) params);
		while (TRUE) {
			ValaFormalParameter* p;
			char* get_value_function;
			gboolean is_array;
			ValaCCodeIdentifier* _tmp98_;
			ValaCCodeFunctionCall* _tmp99_;
			ValaCCodeFunctionCall* inner_fc;
			ValaCCodeIdentifier* _tmp100_;
			char* _tmp101_;
			ValaCCodeIdentifier* _tmp102_;
			ValaCCodeBinaryExpression* _tmp103_;
			gboolean _tmp104_ = FALSE;
			if (!vala_iterator_next (_p_it)) {
				break;
			}
			p = (ValaFormalParameter*) vala_iterator_get (_p_it);
			get_value_function = NULL;
			is_array = vala_data_type_is_array (vala_variable_get_variable_type ((ValaVariable*) p));
			if (vala_formal_parameter_get_direction (p) != VALA_PARAMETER_DIRECTION_IN) {
				char* _tmp84_;
				get_value_function = (_tmp84_ = g_strdup ("g_value_get_pointer"), _g_free0 (get_value_function), _tmp84_);
			} else {
				if (is_array) {
					if (dbus) {
						char* _tmp85_;
						get_value_function = (_tmp85_ = g_strdup ("g_value_get_boxed"), _g_free0 (get_value_function), _tmp85_);
					} else {
						if (vala_data_type_get_data_type (vala_array_type_get_element_type (VALA_ARRAY_TYPE (vala_variable_get_variable_type ((ValaVariable*) p)))) == vala_data_type_get_data_type (((ValaCCodeBaseModule*) self)->string_type)) {
							char* _tmp86_;
							get_value_function = (_tmp86_ = g_strdup ("g_value_get_boxed"), _g_free0 (get_value_function), _tmp86_);
						} else {
							char* _tmp87_;
							get_value_function = (_tmp87_ = g_strdup ("g_value_get_pointer"), _g_free0 (get_value_function), _tmp87_);
						}
					}
				} else {
					gboolean _tmp88_ = FALSE;
					if (VALA_IS_POINTER_TYPE (vala_variable_get_variable_type ((ValaVariable*) p))) {
						_tmp88_ = TRUE;
					} else {
						_tmp88_ = vala_data_type_get_type_parameter (vala_variable_get_variable_type ((ValaVariable*) p)) != NULL;
					}
					if (_tmp88_) {
						char* _tmp89_;
						get_value_function = (_tmp89_ = g_strdup ("g_value_get_pointer"), _g_free0 (get_value_function), _tmp89_);
					} else {
						if (VALA_IS_ERROR_TYPE (vala_variable_get_variable_type ((ValaVariable*) p))) {
							char* _tmp90_;
							get_value_function = (_tmp90_ = g_strdup ("g_value_get_pointer"), _g_free0 (get_value_function), _tmp90_);
						} else {
							gboolean _tmp91_ = FALSE;
							if (dbus) {
								char* _tmp92_;
								_tmp91_ = g_str_has_prefix (_tmp92_ = vala_dbus_module_get_type_signature (vala_variable_get_variable_type ((ValaVariable*) p)), "(");
								_g_free0 (_tmp92_);
							} else {
								_tmp91_ = FALSE;
							}
							if (_tmp91_) {
								char* _tmp93_;
								get_value_function = (_tmp93_ = g_strdup ("g_value_get_boxed"), _g_free0 (get_value_function), _tmp93_);
							} else {
								gboolean _tmp94_ = FALSE;
								if (dbus) {
									_tmp94_ = VALA_IS_ENUM (vala_data_type_get_data_type (vala_variable_get_variable_type ((ValaVariable*) p)));
								} else {
									_tmp94_ = FALSE;
								}
								if (_tmp94_) {
									ValaEnum* en;
									en = _vala_code_node_ref0 (VALA_ENUM (vala_data_type_get_data_type (vala_variable_get_variable_type ((ValaVariable*) p))));
									if (vala_enum_get_is_flags (en)) {
										char* _tmp95_;
										get_value_function = (_tmp95_ = g_strdup ("g_value_get_uint"), _g_free0 (get_value_function), _tmp95_);
									} else {
										char* _tmp96_;
										get_value_function = (_tmp96_ = g_strdup ("g_value_get_int"), _g_free0 (get_value_function), _tmp96_);
									}
									_vala_code_node_unref0 (en);
								} else {
									char* _tmp97_;
									get_value_function = (_tmp97_ = vala_typesymbol_get_get_value_function (vala_data_type_get_data_type (vala_variable_get_variable_type ((ValaVariable*) p))), _g_free0 (get_value_function), _tmp97_);
								}
							}
						}
					}
				}
			}
			inner_fc = (_tmp99_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp98_ = vala_ccode_identifier_new (get_value_function))), _vala_ccode_node_unref0 (_tmp98_), _tmp99_);
			vala_ccode_function_call_add_argument (inner_fc, (ValaCCodeExpression*) (_tmp103_ = vala_ccode_binary_expression_new (VALA_CCODE_BINARY_OPERATOR_PLUS, (ValaCCodeExpression*) (_tmp100_ = vala_ccode_identifier_new ("param_values")), (ValaCCodeExpression*) (_tmp102_ = vala_ccode_identifier_new (_tmp101_ = g_strdup_printf ("%i", i))))));
			_vala_ccode_node_unref0 (_tmp103_);
			_vala_ccode_node_unref0 (_tmp102_);
			_g_free0 (_tmp101_);
			_vala_ccode_node_unref0 (_tmp100_);
			vala_ccode_function_call_add_argument (fc, (ValaCCodeExpression*) inner_fc);
			i++;
			if (is_array) {
				_tmp104_ = !dbus;
			} else {
				_tmp104_ = FALSE;
			}
			if (_tmp104_) {
				ValaCCodeIdentifier* _tmp105_;
				ValaCCodeFunctionCall* _tmp106_;
				ValaCCodeIdentifier* _tmp107_;
				char* _tmp108_;
				ValaCCodeIdentifier* _tmp109_;
				ValaCCodeBinaryExpression* _tmp110_;
				inner_fc = (_tmp106_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp105_ = vala_ccode_identifier_new ("g_value_get_int"))), _vala_ccode_node_unref0 (inner_fc), _tmp106_);
				_vala_ccode_node_unref0 (_tmp105_);
				vala_ccode_function_call_add_argument (inner_fc, (ValaCCodeExpression*) (_tmp110_ = vala_ccode_binary_expression_new (VALA_CCODE_BINARY_OPERATOR_PLUS, (ValaCCodeExpression*) (_tmp107_ = vala_ccode_identifier_new ("param_values")), (ValaCCodeExpression*) (_tmp109_ = vala_ccode_identifier_new (_tmp108_ = g_strdup_printf ("%i", i))))));
				_vala_ccode_node_unref0 (_tmp110_);
				_vala_ccode_node_unref0 (_tmp109_);
				_g_free0 (_tmp108_);
				_vala_ccode_node_unref0 (_tmp107_);
				vala_ccode_function_call_add_argument (fc, (ValaCCodeExpression*) inner_fc);
				i++;
			}
			_vala_ccode_node_unref0 (inner_fc);
			_g_free0 (get_value_function);
			_vala_code_node_unref0 (p);
		}
		_vala_collection_object_unref0 (_p_it);
	}
	vala_ccode_function_call_add_argument (fc, (ValaCCodeExpression*) (_tmp111_ = vala_ccode_identifier_new ("data2")));
	_vala_ccode_node_unref0 (_tmp111_);
	if (vala_data_type_get_data_type (return_type) != NULL) {
		_tmp112_ = TRUE;
	} else {
		_tmp112_ = vala_data_type_is_array (return_type);
	}
	if (_tmp112_) {
		ValaCCodeIdentifier* _tmp113_;
		ValaCCodeAssignment* _tmp114_;
		ValaCCodeExpressionStatement* _tmp115_;
		ValaCCodeFunctionCall* set_fc;
		ValaCCodeIdentifier* _tmp143_;
		ValaCCodeIdentifier* _tmp144_;
		ValaCCodeExpressionStatement* _tmp145_;
		vala_ccode_block_add_statement (marshaller_body, (ValaCCodeNode*) (_tmp115_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) (_tmp114_ = vala_ccode_assignment_new ((ValaCCodeExpression*) (_tmp113_ = vala_ccode_identifier_new ("v_return")), (ValaCCodeExpression*) fc, VALA_CCODE_ASSIGNMENT_OPERATOR_SIMPLE)))));
		_vala_ccode_node_unref0 (_tmp115_);
		_vala_ccode_node_unref0 (_tmp114_);
		_vala_ccode_node_unref0 (_tmp113_);
		set_fc = NULL;
		if (vala_data_type_is_array (return_type)) {
			if (dbus) {
				ValaCCodeIdentifier* _tmp116_;
				ValaCCodeFunctionCall* _tmp117_;
				set_fc = (_tmp117_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp116_ = vala_ccode_identifier_new ("g_value_take_boxed"))), _vala_ccode_node_unref0 (set_fc), _tmp117_);
				_vala_ccode_node_unref0 (_tmp116_);
			} else {
				if (vala_data_type_get_data_type (vala_array_type_get_element_type (VALA_ARRAY_TYPE (return_type))) == vala_data_type_get_data_type (((ValaCCodeBaseModule*) self)->string_type)) {
					ValaCCodeIdentifier* _tmp118_;
					ValaCCodeFunctionCall* _tmp119_;
					set_fc = (_tmp119_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp118_ = vala_ccode_identifier_new ("g_value_take_boxed"))), _vala_ccode_node_unref0 (set_fc), _tmp119_);
					_vala_ccode_node_unref0 (_tmp118_);
				} else {
					ValaCCodeIdentifier* _tmp120_;
					ValaCCodeFunctionCall* _tmp121_;
					set_fc = (_tmp121_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp120_ = vala_ccode_identifier_new ("g_value_set_pointer"))), _vala_ccode_node_unref0 (set_fc), _tmp121_);
					_vala_ccode_node_unref0 (_tmp120_);
				}
			}
		} else {
			if (vala_data_type_get_type_parameter (return_type) != NULL) {
				ValaCCodeIdentifier* _tmp122_;
				ValaCCodeFunctionCall* _tmp123_;
				set_fc = (_tmp123_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp122_ = vala_ccode_identifier_new ("g_value_set_pointer"))), _vala_ccode_node_unref0 (set_fc), _tmp123_);
				_vala_ccode_node_unref0 (_tmp122_);
			} else {
				if (VALA_IS_ERROR_TYPE (return_type)) {
					ValaCCodeIdentifier* _tmp124_;
					ValaCCodeFunctionCall* _tmp125_;
					set_fc = (_tmp125_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp124_ = vala_ccode_identifier_new ("g_value_set_pointer"))), _vala_ccode_node_unref0 (set_fc), _tmp125_);
					_vala_ccode_node_unref0 (_tmp124_);
				} else {
					if (vala_data_type_get_data_type (return_type) == vala_data_type_get_data_type (((ValaCCodeBaseModule*) self)->string_type)) {
						ValaCCodeIdentifier* _tmp126_;
						ValaCCodeFunctionCall* _tmp127_;
						set_fc = (_tmp127_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp126_ = vala_ccode_identifier_new ("g_value_take_string"))), _vala_ccode_node_unref0 (set_fc), _tmp127_);
						_vala_ccode_node_unref0 (_tmp126_);
					} else {
						gboolean _tmp128_ = FALSE;
						if (VALA_IS_CLASS (vala_data_type_get_data_type (return_type))) {
							_tmp128_ = TRUE;
						} else {
							_tmp128_ = VALA_IS_INTERFACE (vala_data_type_get_data_type (return_type));
						}
						if (_tmp128_) {
							ValaCCodeIdentifier* _tmp129_;
							ValaCCodeFunctionCall* _tmp130_;
							set_fc = (_tmp130_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp129_ = vala_ccode_identifier_new ("g_value_take_object"))), _vala_ccode_node_unref0 (set_fc), _tmp130_);
							_vala_ccode_node_unref0 (_tmp129_);
						} else {
							gboolean _tmp131_ = FALSE;
							if (dbus) {
								char* _tmp132_;
								_tmp131_ = g_str_has_prefix (_tmp132_ = vala_dbus_module_get_type_signature (return_type), "(");
								_g_free0 (_tmp132_);
							} else {
								_tmp131_ = FALSE;
							}
							if (_tmp131_) {
								ValaCCodeIdentifier* _tmp133_;
								ValaCCodeFunctionCall* _tmp134_;
								set_fc = (_tmp134_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp133_ = vala_ccode_identifier_new ("g_value_take_boxed"))), _vala_ccode_node_unref0 (set_fc), _tmp134_);
								_vala_ccode_node_unref0 (_tmp133_);
							} else {
								gboolean _tmp135_ = FALSE;
								if (dbus) {
									_tmp135_ = VALA_IS_ENUM (vala_data_type_get_data_type (return_type));
								} else {
									_tmp135_ = FALSE;
								}
								if (_tmp135_) {
									ValaEnum* en;
									en = _vala_code_node_ref0 (VALA_ENUM (vala_data_type_get_data_type (return_type)));
									if (vala_enum_get_is_flags (en)) {
										ValaCCodeIdentifier* _tmp136_;
										ValaCCodeFunctionCall* _tmp137_;
										set_fc = (_tmp137_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp136_ = vala_ccode_identifier_new ("g_value_set_uint"))), _vala_ccode_node_unref0 (set_fc), _tmp137_);
										_vala_ccode_node_unref0 (_tmp136_);
									} else {
										ValaCCodeIdentifier* _tmp138_;
										ValaCCodeFunctionCall* _tmp139_;
										set_fc = (_tmp139_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp138_ = vala_ccode_identifier_new ("g_value_set_int"))), _vala_ccode_node_unref0 (set_fc), _tmp139_);
										_vala_ccode_node_unref0 (_tmp138_);
									}
									_vala_code_node_unref0 (en);
								} else {
									char* _tmp140_;
									ValaCCodeIdentifier* _tmp141_;
									ValaCCodeFunctionCall* _tmp142_;
									set_fc = (_tmp142_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp141_ = vala_ccode_identifier_new (_tmp140_ = vala_typesymbol_get_set_value_function (vala_data_type_get_data_type (return_type))))), _vala_ccode_node_unref0 (set_fc), _tmp142_);
									_vala_ccode_node_unref0 (_tmp141_);
									_g_free0 (_tmp140_);
								}
							}
						}
					}
				}
			}
		}
		vala_ccode_function_call_add_argument (set_fc, (ValaCCodeExpression*) (_tmp143_ = vala_ccode_identifier_new ("return_value")));
		_vala_ccode_node_unref0 (_tmp143_);
		vala_ccode_function_call_add_argument (set_fc, (ValaCCodeExpression*) (_tmp144_ = vala_ccode_identifier_new ("v_return")));
		_vala_ccode_node_unref0 (_tmp144_);
		vala_ccode_block_add_statement (marshaller_body, (ValaCCodeNode*) (_tmp145_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) set_fc)));
		_vala_ccode_node_unref0 (_tmp145_);
		_vala_ccode_node_unref0 (set_fc);
	} else {
		ValaCCodeExpressionStatement* _tmp146_;
		vala_ccode_block_add_statement (marshaller_body, (ValaCCodeNode*) (_tmp146_ = vala_ccode_expression_statement_new ((ValaCCodeExpression*) fc)));
		_vala_ccode_node_unref0 (_tmp146_);
	}
	vala_ccode_function_set_block (signal_marshaller, marshaller_body);
	vala_ccode_fragment_append (((ValaCCodeBaseModule*) self)->source_signal_marshaller_definition, (ValaCCodeNode*) signal_marshaller);
	vala_collection_add ((ValaCollection*) ((ValaCCodeBaseModule*) self)->user_marshal_set, signature);
	_vala_ccode_node_unref0 (c_assign);
	_vala_ccode_node_unref0 (false_block);
	_vala_ccode_node_unref0 (true_block);
	_vala_ccode_node_unref0 (cond);
	_vala_ccode_node_unref0 (param);
	_vala_ccode_node_unref0 (data);
	_vala_ccode_node_unref0 (fc);
	_vala_ccode_node_unref0 (var_decl);
	_vala_ccode_node_unref0 (callback_decl);
	_vala_ccode_node_unref0 (marshaller_body);
	_vala_ccode_node_unref0 (signal_marshaller);
	_g_free0 (signature);
}


static void _vala_array_add1 (char*** array, int* length, int* size, char* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (char*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add2 (char*** array, int* length, int* size, char* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (char*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add3 (char*** array, int* length, int* size, char* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (char*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add4 (char*** array, int* length, int* size, char* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (char*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add5 (char*** array, int* length, int* size, char* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (char*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add6 (char*** array, int* length, int* size, char* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (char*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void _vala_array_add7 (char*** array, int* length, int* size, char* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (char*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static ValaCCodeFunctionCall* vala_gsignal_module_real_get_signal_creation (ValaCCodeBaseModule* base, ValaSignal* sig, ValaTypeSymbol* type) {
	ValaGSignalModule * self;
	ValaCCodeFunctionCall* result = NULL;
	ValaCCodeIdentifier* _tmp0_;
	ValaCCodeFunctionCall* _tmp1_;
	ValaCCodeFunctionCall* csignew;
	ValaSymbol* _tmp2_;
	ValaClass* cl;
	char* _tmp3_;
	char* _tmp4_;
	ValaCCodeConstant* _tmp5_;
	char* _tmp6_;
	ValaCCodeIdentifier* _tmp7_;
	gint flags_length1;
	gint _flags_size_;
	char** _tmp8_;
	char** flags;
	char* _tmp9_;
	ValaCCodeConstant* _tmp10_;
	ValaCCodeConstant* _tmp18_;
	ValaCCodeConstant* _tmp19_;
	ValaList* _tmp20_;
	char* _tmp21_;
	char* marshaller;
	ValaCCodeIdentifier* marshal_arg;
	ValaList* params;
	gboolean _tmp22_ = FALSE;
	gint params_len;
	char* _tmp28_;
	ValaCCodeConstant* _tmp29_;
	self = (ValaGSignalModule*) base;
	g_return_val_if_fail (sig != NULL, NULL);
	g_return_val_if_fail (type != NULL, NULL);
	csignew = (_tmp1_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp0_ = vala_ccode_identifier_new ("g_signal_new"))), _vala_ccode_node_unref0 (_tmp0_), _tmp1_);
	cl = _vala_code_node_ref0 ((_tmp2_ = vala_symbol_get_parent_symbol ((ValaSymbol*) sig), VALA_IS_CLASS (_tmp2_) ? ((ValaClass*) _tmp2_) : NULL));
	vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp5_ = vala_ccode_constant_new (_tmp4_ = g_strdup_printf ("\"%s\"", _tmp3_ = vala_signal_get_cname (sig)))));
	_vala_ccode_node_unref0 (_tmp5_);
	_g_free0 (_tmp4_);
	_g_free0 (_tmp3_);
	vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp7_ = vala_ccode_identifier_new (_tmp6_ = vala_typesymbol_get_type_id (type))));
	_vala_ccode_node_unref0 (_tmp7_);
	_g_free0 (_tmp6_);
	flags = (_tmp8_ = g_new0 (char*, 0 + 1), flags_length1 = 0, _flags_size_ = flags_length1, _tmp8_);
	if (_vala_strcmp0 (vala_signal_get_run_type (sig), "first") == 0) {
		_vala_array_add1 (&flags, &flags_length1, &_flags_size_, g_strdup ("G_SIGNAL_RUN_FIRST"));
	} else {
		if (_vala_strcmp0 (vala_signal_get_run_type (sig), "cleanup") == 0) {
			_vala_array_add2 (&flags, &flags_length1, &_flags_size_, g_strdup ("G_SIGNAL_RUN_CLEANUP"));
		} else {
			_vala_array_add3 (&flags, &flags_length1, &_flags_size_, g_strdup ("G_SIGNAL_RUN_LAST"));
		}
	}
	if (vala_signal_get_is_detailed (sig)) {
		_vala_array_add4 (&flags, &flags_length1, &_flags_size_, g_strdup ("G_SIGNAL_DETAILED"));
	}
	if (vala_signal_get_no_recurse (sig)) {
		_vala_array_add5 (&flags, &flags_length1, &_flags_size_, g_strdup ("G_SIGNAL_NO_RECURSE"));
	}
	if (vala_signal_get_is_action (sig)) {
		_vala_array_add6 (&flags, &flags_length1, &_flags_size_, g_strdup ("G_SIGNAL_ACTION"));
	}
	if (vala_signal_get_no_hooks (sig)) {
		_vala_array_add7 (&flags, &flags_length1, &_flags_size_, g_strdup ("G_SIGNAL_NO_HOOKS"));
	}
	vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp10_ = vala_ccode_constant_new (_tmp9_ = g_strjoinv (" | ", flags))));
	_vala_ccode_node_unref0 (_tmp10_);
	_g_free0 (_tmp9_);
	if (vala_signal_get_default_handler (sig) == NULL) {
		ValaCCodeConstant* _tmp11_;
		vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp11_ = vala_ccode_constant_new ("0")));
		_vala_ccode_node_unref0 (_tmp11_);
	} else {
		ValaCCodeIdentifier* _tmp12_;
		ValaCCodeFunctionCall* _tmp13_;
		ValaCCodeFunctionCall* struct_offset;
		char* _tmp14_;
		char* _tmp15_;
		ValaCCodeIdentifier* _tmp16_;
		ValaCCodeIdentifier* _tmp17_;
		struct_offset = (_tmp13_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp12_ = vala_ccode_identifier_new ("G_STRUCT_OFFSET"))), _vala_ccode_node_unref0 (_tmp12_), _tmp13_);
		vala_ccode_function_call_add_argument (struct_offset, (ValaCCodeExpression*) (_tmp16_ = vala_ccode_identifier_new (_tmp15_ = g_strdup_printf ("%sClass", _tmp14_ = vala_typesymbol_get_cname ((ValaTypeSymbol*) cl, FALSE)))));
		_vala_ccode_node_unref0 (_tmp16_);
		_g_free0 (_tmp15_);
		_g_free0 (_tmp14_);
		vala_ccode_function_call_add_argument (struct_offset, (ValaCCodeExpression*) (_tmp17_ = vala_ccode_identifier_new (vala_method_get_vfunc_name (vala_signal_get_default_handler (sig)))));
		_vala_ccode_node_unref0 (_tmp17_);
		vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) struct_offset);
		_vala_ccode_node_unref0 (struct_offset);
	}
	vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp18_ = vala_ccode_constant_new ("NULL")));
	_vala_ccode_node_unref0 (_tmp18_);
	vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp19_ = vala_ccode_constant_new ("NULL")));
	_vala_ccode_node_unref0 (_tmp19_);
	marshaller = (_tmp21_ = vala_ccode_base_module_get_marshaller_function ((ValaCCodeBaseModule*) self, _tmp20_ = vala_signal_get_parameters (sig), vala_signal_get_return_type (sig), NULL, FALSE), _vala_collection_object_unref0 (_tmp20_), _tmp21_);
	marshal_arg = vala_ccode_identifier_new (marshaller);
	vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) marshal_arg);
	params = vala_signal_get_parameters (sig);
	if (VALA_IS_POINTER_TYPE (vala_signal_get_return_type (sig))) {
		_tmp22_ = TRUE;
	} else {
		_tmp22_ = vala_data_type_get_type_parameter (vala_signal_get_return_type (sig)) != NULL;
	}
	if (_tmp22_) {
		ValaCCodeConstant* _tmp23_;
		vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp23_ = vala_ccode_constant_new ("G_TYPE_POINTER")));
		_vala_ccode_node_unref0 (_tmp23_);
	} else {
		if (VALA_IS_ERROR_TYPE (vala_signal_get_return_type (sig))) {
			ValaCCodeConstant* _tmp24_;
			vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp24_ = vala_ccode_constant_new ("G_TYPE_POINTER")));
			_vala_ccode_node_unref0 (_tmp24_);
		} else {
			if (vala_data_type_get_data_type (vala_signal_get_return_type (sig)) == NULL) {
				ValaCCodeConstant* _tmp25_;
				vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp25_ = vala_ccode_constant_new ("G_TYPE_NONE")));
				_vala_ccode_node_unref0 (_tmp25_);
			} else {
				char* _tmp26_;
				ValaCCodeConstant* _tmp27_;
				vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp27_ = vala_ccode_constant_new (_tmp26_ = vala_typesymbol_get_type_id (vala_data_type_get_data_type (vala_signal_get_return_type (sig))))));
				_vala_ccode_node_unref0 (_tmp27_);
				_g_free0 (_tmp26_);
			}
		}
	}
	params_len = 0;
	{
		ValaIterator* _param_it;
		_param_it = vala_iterable_iterator ((ValaIterable*) params);
		while (TRUE) {
			ValaFormalParameter* param;
			if (!vala_iterator_next (_param_it)) {
				break;
			}
			param = (ValaFormalParameter*) vala_iterator_get (_param_it);
			params_len++;
			if (vala_data_type_is_array (vala_variable_get_variable_type ((ValaVariable*) param))) {
				params_len++;
			}
			_vala_code_node_unref0 (param);
		}
		_vala_collection_object_unref0 (_param_it);
	}
	vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp29_ = vala_ccode_constant_new (_tmp28_ = g_strdup_printf ("%d", params_len))));
	_vala_ccode_node_unref0 (_tmp29_);
	_g_free0 (_tmp28_);
	{
		ValaIterator* _param_it;
		_param_it = vala_iterable_iterator ((ValaIterable*) params);
		while (TRUE) {
			ValaFormalParameter* param;
			if (!vala_iterator_next (_param_it)) {
				break;
			}
			param = (ValaFormalParameter*) vala_iterator_get (_param_it);
			if (vala_data_type_is_array (vala_variable_get_variable_type ((ValaVariable*) param))) {
				ValaCCodeConstant* _tmp32_;
				if (vala_data_type_get_data_type (vala_array_type_get_element_type (VALA_ARRAY_TYPE (vala_variable_get_variable_type ((ValaVariable*) param)))) == vala_data_type_get_data_type (((ValaCCodeBaseModule*) self)->string_type)) {
					ValaCCodeConstant* _tmp30_;
					vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp30_ = vala_ccode_constant_new ("G_TYPE_STRV")));
					_vala_ccode_node_unref0 (_tmp30_);
				} else {
					ValaCCodeConstant* _tmp31_;
					vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp31_ = vala_ccode_constant_new ("G_TYPE_POINTER")));
					_vala_ccode_node_unref0 (_tmp31_);
				}
				vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp32_ = vala_ccode_constant_new ("G_TYPE_INT")));
				_vala_ccode_node_unref0 (_tmp32_);
			} else {
				gboolean _tmp33_ = FALSE;
				gboolean _tmp34_ = FALSE;
				if (VALA_IS_POINTER_TYPE (vala_variable_get_variable_type ((ValaVariable*) param))) {
					_tmp34_ = TRUE;
				} else {
					_tmp34_ = vala_data_type_get_type_parameter (vala_variable_get_variable_type ((ValaVariable*) param)) != NULL;
				}
				if (_tmp34_) {
					_tmp33_ = TRUE;
				} else {
					_tmp33_ = vala_formal_parameter_get_direction (param) != VALA_PARAMETER_DIRECTION_IN;
				}
				if (_tmp33_) {
					ValaCCodeConstant* _tmp35_;
					vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp35_ = vala_ccode_constant_new ("G_TYPE_POINTER")));
					_vala_ccode_node_unref0 (_tmp35_);
				} else {
					if (VALA_IS_ERROR_TYPE (vala_variable_get_variable_type ((ValaVariable*) param))) {
						ValaCCodeConstant* _tmp36_;
						vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp36_ = vala_ccode_constant_new ("G_TYPE_POINTER")));
						_vala_ccode_node_unref0 (_tmp36_);
					} else {
						char* _tmp37_;
						ValaCCodeConstant* _tmp38_;
						vala_ccode_function_call_add_argument (csignew, (ValaCCodeExpression*) (_tmp38_ = vala_ccode_constant_new (_tmp37_ = vala_typesymbol_get_type_id (vala_data_type_get_data_type (vala_variable_get_variable_type ((ValaVariable*) param))))));
						_vala_ccode_node_unref0 (_tmp38_);
						_g_free0 (_tmp37_);
					}
				}
			}
			_vala_code_node_unref0 (param);
		}
		_vala_collection_object_unref0 (_param_it);
	}
	vala_ccode_identifier_set_name (marshal_arg, marshaller);
	result = csignew;
	_vala_collection_object_unref0 (params);
	_vala_ccode_node_unref0 (marshal_arg);
	_g_free0 (marshaller);
	flags = (_vala_array_free (flags, flags_length1, (GDestroyNotify) g_free), NULL);
	_vala_code_node_unref0 (cl);
	return result;
}


static ValaCCodeExpression* vala_gsignal_module_real_get_dbus_g_type (ValaGSignalModule* self, ValaDataType* data_type) {
	ValaCCodeExpression* result = NULL;
	char* _tmp0_;
	ValaCCodeExpression* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (data_type != NULL, NULL);
	result = (_tmp1_ = (ValaCCodeExpression*) vala_ccode_constant_new (_tmp0_ = vala_typesymbol_get_type_id (vala_data_type_get_data_type (data_type))), _g_free0 (_tmp0_), _tmp1_);
	return result;
}


ValaCCodeExpression* vala_gsignal_module_get_dbus_g_type (ValaGSignalModule* self, ValaDataType* data_type) {
	return VALA_GSIGNAL_MODULE_GET_CLASS (self)->get_dbus_g_type (self, data_type);
}


static void vala_gsignal_module_real_visit_element_access (ValaCodeVisitor* base, ValaElementAccess* expr) {
	ValaGSignalModule * self;
	gboolean _tmp0_ = FALSE;
	self = (ValaGSignalModule*) base;
	g_return_if_fail (expr != NULL);
	if (VALA_IS_MEMBER_ACCESS (vala_element_access_get_container (expr))) {
		_tmp0_ = VALA_IS_SIGNAL (vala_expression_get_symbol_reference (vala_element_access_get_container (expr)));
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		ValaSignal* sig;
		ValaMemberAccess* ma;
		ValaList* _tmp1_;
		ValaExpression* _tmp2_;
		ValaExpression* detail_expr;
		ValaCCodeExpression* signal_name_cexpr;
		ValaCCodeIdentifier* _tmp3_;
		ValaCCodeFunctionCall* _tmp4_;
		ValaCCodeFunctionCall* ccall;
		sig = _vala_code_node_ref0 (VALA_SIGNAL (vala_expression_get_symbol_reference ((ValaExpression*) expr)));
		ma = _vala_code_node_ref0 (VALA_MEMBER_ACCESS (vala_element_access_get_container (expr)));
		detail_expr = (_tmp2_ = (ValaExpression*) vala_list_get (_tmp1_ = vala_element_access_get_indices (expr), 0), _vala_collection_object_unref0 (_tmp1_), _tmp2_);
		signal_name_cexpr = vala_gsignal_module_get_signal_name_cexpression (self, sig, detail_expr, (ValaCodeNode*) expr);
		ccall = (_tmp4_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp3_ = vala_ccode_identifier_new ("g_signal_emit_by_name"))), _vala_ccode_node_unref0 (_tmp3_), _tmp4_);
		vala_ccode_function_call_add_argument (ccall, VALA_CCODE_EXPRESSION (vala_code_node_get_ccodenode ((ValaCodeNode*) vala_member_access_get_inner (ma))));
		if (signal_name_cexpr != NULL) {
			vala_ccode_function_call_add_argument (ccall, signal_name_cexpr);
		}
		vala_code_node_set_ccodenode ((ValaCodeNode*) expr, (ValaCCodeNode*) ccall);
		_vala_ccode_node_unref0 (ccall);
		_vala_ccode_node_unref0 (signal_name_cexpr);
		_vala_code_node_unref0 (detail_expr);
		_vala_code_node_unref0 (ma);
		_vala_code_node_unref0 (sig);
	} else {
		VALA_CODE_VISITOR_CLASS (vala_gsignal_module_parent_class)->visit_element_access ((ValaCodeVisitor*) VALA_GOBJECT_MODULE (self), expr);
	}
}


static gboolean vala_gsignal_module_in_gobject_instance (ValaGSignalModule* self, ValaMethod* m) {
	gboolean result = FALSE;
	gboolean _result_;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (m != NULL, FALSE);
	_result_ = FALSE;
	if (vala_method_get_binding (m) == MEMBER_BINDING_INSTANCE) {
		_result_ = vala_typesymbol_is_subtype_of (vala_data_type_get_data_type (vala_variable_get_variable_type ((ValaVariable*) vala_method_get_this_parameter (m))), ((ValaCCodeBaseModule*) self)->gobject_type);
	}
	result = _result_;
	return result;
}


static ValaCCodeExpression* vala_gsignal_module_emit_signal_assignment (ValaGSignalModule* self, ValaAssignment* assignment) {
	ValaCCodeExpression* result = NULL;
	ValaSignal* sig;
	gboolean disconnect;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (assignment != NULL, NULL);
	sig = _vala_code_node_ref0 (VALA_SIGNAL (vala_expression_get_symbol_reference (vala_assignment_get_left (assignment))));
	disconnect = FALSE;
	if (vala_assignment_get_operator (assignment) == VALA_ASSIGNMENT_OPERATOR_ADD) {
	} else {
		if (vala_assignment_get_operator (assignment) == VALA_ASSIGNMENT_OPERATOR_SUB) {
			disconnect = TRUE;
		} else {
			vala_code_node_set_error ((ValaCodeNode*) assignment, TRUE);
			vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) assignment), "Specified compound assignment type for signals not supported.");
			result = NULL;
			_vala_code_node_unref0 (sig);
			return result;
		}
	}
	result = vala_gsignal_module_connect_signal (self, sig, vala_assignment_get_left (assignment), vala_assignment_get_right (assignment), disconnect, FALSE, (ValaCodeNode*) assignment);
	_vala_code_node_unref0 (sig);
	return result;
}


static void vala_gsignal_module_real_visit_assignment (ValaCodeVisitor* base, ValaAssignment* assignment) {
	ValaGSignalModule * self;
	self = (ValaGSignalModule*) base;
	g_return_if_fail (assignment != NULL);
	if (VALA_IS_SIGNAL (vala_expression_get_symbol_reference (vala_assignment_get_left (assignment)))) {
		gboolean _tmp0_ = FALSE;
		ValaCCodeExpression* _tmp1_;
		if (vala_code_node_get_error ((ValaCodeNode*) vala_assignment_get_left (assignment))) {
			_tmp0_ = TRUE;
		} else {
			_tmp0_ = vala_code_node_get_error ((ValaCodeNode*) vala_assignment_get_right (assignment));
		}
		if (_tmp0_) {
			vala_code_node_set_error ((ValaCodeNode*) assignment, TRUE);
			return;
		}
		vala_code_node_set_ccodenode ((ValaCodeNode*) assignment, (ValaCCodeNode*) (_tmp1_ = vala_gsignal_module_emit_signal_assignment (self, assignment)));
		_vala_ccode_node_unref0 (_tmp1_);
	} else {
		VALA_CODE_VISITOR_CLASS (vala_gsignal_module_parent_class)->visit_assignment ((ValaCodeVisitor*) VALA_GOBJECT_MODULE (self), assignment);
	}
}


static gpointer _vala_ccode_node_ref0 (gpointer self) {
	return self ? vala_ccode_node_ref (self) : NULL;
}


static void vala_gsignal_module_real_visit_member_access (ValaCodeVisitor* base, ValaMemberAccess* expr) {
	ValaGSignalModule * self;
	self = (ValaGSignalModule*) base;
	g_return_if_fail (expr != NULL);
	if (VALA_IS_SIGNAL (vala_expression_get_symbol_reference ((ValaExpression*) expr))) {
		ValaCCodeExpression* pub_inst;
		ValaSignal* sig;
		ValaTypeSymbol* cl;
		gboolean _tmp1_ = FALSE;
		pub_inst = NULL;
		if (vala_member_access_get_inner (expr) != NULL) {
			ValaCCodeExpression* _tmp0_;
			pub_inst = (_tmp0_ = _vala_ccode_node_ref0 (VALA_CCODE_EXPRESSION (vala_code_node_get_ccodenode ((ValaCodeNode*) vala_member_access_get_inner (expr)))), _vala_ccode_node_unref0 (pub_inst), _tmp0_);
		}
		sig = _vala_code_node_ref0 (VALA_SIGNAL (vala_expression_get_symbol_reference ((ValaExpression*) expr)));
		cl = _vala_code_node_ref0 (VALA_TYPESYMBOL (vala_symbol_get_parent_symbol ((ValaSymbol*) sig)));
		if (VALA_IS_BASE_ACCESS (vala_member_access_get_inner (expr))) {
			_tmp1_ = vala_signal_get_is_virtual (sig);
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			ValaMethod* m;
			ValaClass* base_class;
			char* _tmp2_;
			char* _tmp3_;
			ValaCCodeIdentifier* _tmp4_;
			ValaCCodeFunctionCall* _tmp5_;
			ValaCCodeFunctionCall* vcast;
			char* _tmp6_;
			char* _tmp7_;
			ValaCCodeIdentifier* _tmp8_;
			ValaCCodeMemberAccess* _tmp9_;
			m = _vala_code_node_ref0 (vala_signal_get_default_handler (sig));
			base_class = _vala_code_node_ref0 (VALA_CLASS (vala_symbol_get_parent_symbol ((ValaSymbol*) m)));
			vcast = (_tmp5_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp4_ = vala_ccode_identifier_new (_tmp3_ = g_strdup_printf ("%s_CLASS", _tmp2_ = vala_typesymbol_get_upper_case_cname ((ValaTypeSymbol*) base_class, NULL))))), _vala_ccode_node_unref0 (_tmp4_), _g_free0 (_tmp3_), _g_free0 (_tmp2_), _tmp5_);
			vala_ccode_function_call_add_argument (vcast, (ValaCCodeExpression*) (_tmp8_ = vala_ccode_identifier_new (_tmp7_ = g_strdup_printf ("%s_parent_class", _tmp6_ = vala_symbol_get_lower_case_cname ((ValaSymbol*) vala_ccode_base_module_get_current_class ((ValaCCodeBaseModule*) self), NULL)))));
			_vala_ccode_node_unref0 (_tmp8_);
			_g_free0 (_tmp7_);
			_g_free0 (_tmp6_);
			vala_code_node_set_ccodenode ((ValaCodeNode*) expr, (ValaCCodeNode*) (_tmp9_ = vala_ccode_member_access_new_pointer ((ValaCCodeExpression*) vcast, vala_symbol_get_name ((ValaSymbol*) m))));
			_vala_ccode_node_unref0 (_tmp9_);
			_vala_ccode_node_unref0 (vcast);
			_vala_code_node_unref0 (base_class);
			_vala_code_node_unref0 (m);
			_vala_code_node_unref0 (cl);
			_vala_code_node_unref0 (sig);
			_vala_ccode_node_unref0 (pub_inst);
			return;
		}
		if (vala_signal_get_has_emitter (sig)) {
			char* _tmp10_;
			char* _tmp11_;
			ValaCCodeIdentifier* _tmp12_;
			ValaCCodeFunctionCall* _tmp13_;
			ValaCCodeFunctionCall* ccall;
			ccall = (_tmp13_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp12_ = vala_ccode_identifier_new (_tmp11_ = g_strdup_printf ("%s_%s", _tmp10_ = vala_symbol_get_lower_case_cname ((ValaSymbol*) cl, NULL), vala_symbol_get_name ((ValaSymbol*) sig))))), _vala_ccode_node_unref0 (_tmp12_), _g_free0 (_tmp11_), _g_free0 (_tmp10_), _tmp13_);
			vala_ccode_function_call_add_argument (ccall, pub_inst);
			vala_code_node_set_ccodenode ((ValaCodeNode*) expr, (ValaCCodeNode*) ccall);
			_vala_ccode_node_unref0 (ccall);
		} else {
			ValaCCodeIdentifier* _tmp14_;
			ValaCCodeFunctionCall* _tmp15_;
			ValaCCodeFunctionCall* ccall;
			ValaCCodeConstant* _tmp16_;
			ccall = (_tmp15_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp14_ = vala_ccode_identifier_new ("g_signal_emit_by_name"))), _vala_ccode_node_unref0 (_tmp14_), _tmp15_);
			vala_ccode_function_call_add_argument (ccall, pub_inst);
			vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp16_ = vala_signal_get_canonical_cconstant (sig, NULL)));
			_vala_ccode_node_unref0 (_tmp16_);
			vala_code_node_set_ccodenode ((ValaCodeNode*) expr, (ValaCCodeNode*) ccall);
			_vala_ccode_node_unref0 (ccall);
		}
		_vala_code_node_unref0 (cl);
		_vala_code_node_unref0 (sig);
		_vala_ccode_node_unref0 (pub_inst);
	} else {
		VALA_CODE_VISITOR_CLASS (vala_gsignal_module_parent_class)->visit_member_access ((ValaCodeVisitor*) VALA_GOBJECT_MODULE (self), expr);
	}
}


static void vala_gsignal_module_real_visit_method_call (ValaCodeVisitor* base, ValaMethodCall* expr) {
	ValaGSignalModule * self;
	ValaDataType* _tmp0_;
	ValaMethodType* method_type;
	gboolean _tmp1_ = FALSE;
	ValaSignal* sig;
	ValaExpression* signal_access;
	ValaList* _tmp2_;
	ValaExpression* _tmp3_;
	ValaExpression* handler;
	gboolean disconnect;
	gboolean after;
	ValaCCodeExpression* _tmp4_;
	self = (ValaGSignalModule*) base;
	g_return_if_fail (expr != NULL);
	method_type = _vala_code_node_ref0 ((_tmp0_ = vala_expression_get_value_type (vala_method_call_get_call (expr)), VALA_IS_METHOD_TYPE (_tmp0_) ? ((ValaMethodType*) _tmp0_) : NULL));
	if (method_type == NULL) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = !VALA_IS_SIGNAL (vala_symbol_get_parent_symbol ((ValaSymbol*) vala_method_type_get_method_symbol (method_type)));
	}
	if (_tmp1_) {
		VALA_CODE_VISITOR_CLASS (vala_gsignal_module_parent_class)->visit_method_call ((ValaCodeVisitor*) VALA_GOBJECT_MODULE (self), expr);
		_vala_code_node_unref0 (method_type);
		return;
	}
	sig = _vala_code_node_ref0 (VALA_SIGNAL (vala_symbol_get_parent_symbol ((ValaSymbol*) vala_method_type_get_method_symbol (method_type))));
	signal_access = _vala_code_node_ref0 (vala_member_access_get_inner (VALA_MEMBER_ACCESS (vala_method_call_get_call (expr))));
	handler = (_tmp3_ = (ValaExpression*) vala_list_get (_tmp2_ = vala_method_call_get_argument_list (expr), 0), _vala_collection_object_unref0 (_tmp2_), _tmp3_);
	disconnect = _vala_strcmp0 (vala_symbol_get_name ((ValaSymbol*) vala_method_type_get_method_symbol (method_type)), "disconnect") == 0;
	after = _vala_strcmp0 (vala_symbol_get_name ((ValaSymbol*) vala_method_type_get_method_symbol (method_type)), "connect_after") == 0;
	vala_code_node_set_ccodenode ((ValaCodeNode*) expr, (ValaCCodeNode*) (_tmp4_ = vala_gsignal_module_connect_signal (self, sig, signal_access, handler, disconnect, after, (ValaCodeNode*) expr)));
	_vala_ccode_node_unref0 (_tmp4_);
	_vala_code_node_unref0 (handler);
	_vala_code_node_unref0 (signal_access);
	_vala_code_node_unref0 (sig);
	_vala_code_node_unref0 (method_type);
}


static ValaCCodeExpression* vala_gsignal_module_connect_signal (ValaGSignalModule* self, ValaSignal* sig, ValaExpression* signal_access, ValaExpression* handler, gboolean disconnect, gboolean after, ValaCodeNode* expr) {
	ValaCCodeExpression* result = NULL;
	char* connect_func;
	ValaMethod* m;
	ValaCCodeIdentifier* _tmp8_;
	ValaCCodeFunctionCall* _tmp9_;
	ValaCCodeFunctionCall* ccall;
	ValaCCodeExpression* signal_name_cexpr;
	ValaMemberAccess* ma;
	ValaCCodeCommaExpression* ccomma;
	ValaCCodeCastExpression* _tmp39_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (sig != NULL, NULL);
	g_return_val_if_fail (signal_access != NULL, NULL);
	g_return_val_if_fail (handler != NULL, NULL);
	g_return_val_if_fail (expr != NULL, NULL);
	connect_func = NULL;
	m = _vala_code_node_ref0 (VALA_METHOD (vala_expression_get_symbol_reference (handler)));
	if (!disconnect) {
		if (VALA_IS_DYNAMIC_SIGNAL (sig)) {
			if (!after) {
				char* _tmp0_;
				connect_func = (_tmp0_ = vala_ccode_base_module_get_dynamic_signal_connect_wrapper_name ((ValaCCodeBaseModule*) self, VALA_DYNAMIC_SIGNAL (sig)), _g_free0 (connect_func), _tmp0_);
			} else {
				char* _tmp1_;
				connect_func = (_tmp1_ = vala_ccode_base_module_get_dynamic_signal_connect_after_wrapper_name ((ValaCCodeBaseModule*) self, VALA_DYNAMIC_SIGNAL (sig)), _g_free0 (connect_func), _tmp1_);
			}
		} else {
			if (vala_method_get_closure (m)) {
				char* _tmp2_;
				connect_func = (_tmp2_ = g_strdup ("g_signal_connect_data"), _g_free0 (connect_func), _tmp2_);
			} else {
				if (vala_gsignal_module_in_gobject_instance (self, m)) {
					char* _tmp3_;
					connect_func = (_tmp3_ = g_strdup ("g_signal_connect_object"), _g_free0 (connect_func), _tmp3_);
				} else {
					if (!after) {
						char* _tmp4_;
						connect_func = (_tmp4_ = g_strdup ("g_signal_connect"), _g_free0 (connect_func), _tmp4_);
					} else {
						char* _tmp5_;
						connect_func = (_tmp5_ = g_strdup ("g_signal_connect_after"), _g_free0 (connect_func), _tmp5_);
					}
				}
			}
		}
	} else {
		if (VALA_IS_DYNAMIC_SIGNAL (sig)) {
			char* _tmp6_;
			connect_func = (_tmp6_ = vala_ccode_base_module_get_dynamic_signal_disconnect_wrapper_name ((ValaCCodeBaseModule*) self, VALA_DYNAMIC_SIGNAL (sig)), _g_free0 (connect_func), _tmp6_);
		} else {
			char* _tmp7_;
			connect_func = (_tmp7_ = g_strdup ("g_signal_handlers_disconnect_matched"), _g_free0 (connect_func), _tmp7_);
		}
	}
	ccall = (_tmp9_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp8_ = vala_ccode_identifier_new (connect_func))), _vala_ccode_node_unref0 (_tmp8_), _tmp9_);
	signal_name_cexpr = NULL;
	ma = NULL;
	if (VALA_IS_ELEMENT_ACCESS (signal_access)) {
		ValaElementAccess* ea;
		ValaMemberAccess* _tmp10_;
		ValaList* _tmp11_;
		ValaExpression* _tmp12_;
		ValaExpression* detail_expr;
		ValaCCodeExpression* _tmp13_;
		ea = _vala_code_node_ref0 (VALA_ELEMENT_ACCESS (signal_access));
		ma = (_tmp10_ = _vala_code_node_ref0 (VALA_MEMBER_ACCESS (vala_element_access_get_container (ea))), _vala_code_node_unref0 (ma), _tmp10_);
		detail_expr = (_tmp12_ = (ValaExpression*) vala_list_get (_tmp11_ = vala_element_access_get_indices (ea), 0), _vala_collection_object_unref0 (_tmp11_), _tmp12_);
		signal_name_cexpr = (_tmp13_ = vala_gsignal_module_get_signal_name_cexpression (self, sig, detail_expr, expr), _vala_ccode_node_unref0 (signal_name_cexpr), _tmp13_);
		if (signal_name_cexpr == NULL) {
			result = NULL;
			_vala_code_node_unref0 (detail_expr);
			_vala_code_node_unref0 (ea);
			_vala_code_node_unref0 (ma);
			_vala_ccode_node_unref0 (signal_name_cexpr);
			_vala_ccode_node_unref0 (ccall);
			_vala_code_node_unref0 (m);
			_g_free0 (connect_func);
			return result;
		}
		_vala_code_node_unref0 (detail_expr);
		_vala_code_node_unref0 (ea);
	} else {
		ValaMemberAccess* _tmp14_;
		ValaCCodeExpression* _tmp15_;
		ma = (_tmp14_ = _vala_code_node_ref0 (VALA_MEMBER_ACCESS (signal_access)), _vala_code_node_unref0 (ma), _tmp14_);
		signal_name_cexpr = (_tmp15_ = vala_gsignal_module_get_signal_name_cexpression (self, sig, NULL, expr), _vala_ccode_node_unref0 (signal_name_cexpr), _tmp15_);
	}
	if (vala_member_access_get_inner (ma) != NULL) {
		ValaCCodeExpression* _tmp16_;
		vala_ccode_function_call_add_argument (ccall, _tmp16_ = VALA_CCODE_EXPRESSION (vala_ccode_base_module_get_ccodenode ((ValaCCodeBaseModule*) self, (ValaCodeNode*) vala_member_access_get_inner (ma))));
		_vala_ccode_node_unref0 (_tmp16_);
	} else {
		ValaCCodeExpression* _tmp17_;
		vala_ccode_function_call_add_argument (ccall, _tmp17_ = vala_ccode_base_module_get_result_cexpression ((ValaCCodeBaseModule*) self, "self"));
		_vala_ccode_node_unref0 (_tmp17_);
	}
	ccomma = NULL;
	if (VALA_IS_DYNAMIC_SIGNAL (sig)) {
		char* _tmp18_;
		ValaCCodeConstant* _tmp19_;
		vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp19_ = vala_ccode_constant_new (_tmp18_ = g_strdup_printf ("\"%s\"", vala_symbol_get_name ((ValaSymbol*) sig)))));
		_vala_ccode_node_unref0 (_tmp19_);
		_g_free0 (_tmp18_);
	} else {
		if (!disconnect) {
			vala_ccode_function_call_add_argument (ccall, signal_name_cexpr);
		} else {
			ValaCCodeCommaExpression* _tmp22_;
			ValaLocalVariable* temp_decl;
			ValaCCodeIdentifier* _tmp23_;
			ValaCCodeFunctionCall* _tmp24_;
			ValaCCodeFunctionCall* parse_call;
			ValaTypeSymbol* decl_type;
			char* _tmp25_;
			ValaCCodeIdentifier* _tmp26_;
			ValaCCodeExpression* _tmp27_;
			ValaCCodeUnaryExpression* _tmp28_;
			ValaLocalVariable* detail_temp_decl;
			ValaCCodeExpression* _tmp35_;
			ValaCCodeConstant* _tmp38_;
			if (!VALA_IS_ELEMENT_ACCESS (signal_access)) {
				ValaCCodeConstant* _tmp20_;
				vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp20_ = vala_ccode_constant_new ("G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA")));
				_vala_ccode_node_unref0 (_tmp20_);
			} else {
				ValaCCodeConstant* _tmp21_;
				vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp21_ = vala_ccode_constant_new ("G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | G_SIGNAL_MATCH_FUNC | G_SI" \
"GNAL_MATCH_DATA")));
				_vala_ccode_node_unref0 (_tmp21_);
			}
			ccomma = (_tmp22_ = vala_ccode_comma_expression_new (), _vala_ccode_node_unref0 (ccomma), _tmp22_);
			temp_decl = vala_ccode_base_module_get_temp_variable ((ValaCCodeBaseModule*) self, ((ValaCCodeBaseModule*) self)->uint_type, TRUE, NULL, TRUE);
			vala_collection_add ((ValaCollection*) vala_ccode_base_module_get_temp_vars ((ValaCCodeBaseModule*) self), temp_decl);
			parse_call = (_tmp24_ = vala_ccode_function_call_new ((ValaCCodeExpression*) (_tmp23_ = vala_ccode_identifier_new ("g_signal_parse_name"))), _vala_ccode_node_unref0 (_tmp23_), _tmp24_);
			vala_ccode_function_call_add_argument (parse_call, signal_name_cexpr);
			decl_type = _vala_code_node_ref0 (VALA_TYPESYMBOL (vala_symbol_get_parent_symbol ((ValaSymbol*) sig)));
			vala_ccode_function_call_add_argument (parse_call, (ValaCCodeExpression*) (_tmp26_ = vala_ccode_identifier_new (_tmp25_ = vala_typesymbol_get_type_id (decl_type))));
			_vala_ccode_node_unref0 (_tmp26_);
			_g_free0 (_tmp25_);
			vala_ccode_function_call_add_argument (parse_call, (ValaCCodeExpression*) (_tmp28_ = vala_ccode_unary_expression_new (VALA_CCODE_UNARY_OPERATOR_ADDRESS_OF, _tmp27_ = vala_ccode_base_module_get_variable_cexpression ((ValaCCodeBaseModule*) self, vala_symbol_get_name ((ValaSymbol*) temp_decl)))));
			_vala_ccode_node_unref0 (_tmp28_);
			_vala_ccode_node_unref0 (_tmp27_);
			detail_temp_decl = NULL;
			if (!VALA_IS_ELEMENT_ACCESS (signal_access)) {
				ValaCCodeConstant* _tmp29_;
				ValaCCodeConstant* _tmp30_;
				vala_ccode_function_call_add_argument (parse_call, (ValaCCodeExpression*) (_tmp29_ = vala_ccode_constant_new ("NULL")));
				_vala_ccode_node_unref0 (_tmp29_);
				vala_ccode_function_call_add_argument (parse_call, (ValaCCodeExpression*) (_tmp30_ = vala_ccode_constant_new ("FALSE")));
				_vala_ccode_node_unref0 (_tmp30_);
			} else {
				ValaLocalVariable* _tmp31_;
				ValaCCodeIdentifier* _tmp32_;
				ValaCCodeUnaryExpression* _tmp33_;
				ValaCCodeConstant* _tmp34_;
				detail_temp_decl = (_tmp31_ = vala_ccode_base_module_get_temp_variable ((ValaCCodeBaseModule*) self, ((ValaCCodeBaseModule*) self)->gquark_type, TRUE, NULL, TRUE), _vala_code_node_unref0 (detail_temp_decl), _tmp31_);
				vala_collection_add ((ValaCollection*) vala_ccode_base_module_get_temp_vars ((ValaCCodeBaseModule*) self), detail_temp_decl);
				vala_ccode_function_call_add_argument (parse_call, (ValaCCodeExpression*) (_tmp33_ = vala_ccode_unary_expression_new (VALA_CCODE_UNARY_OPERATOR_ADDRESS_OF, (ValaCCodeExpression*) (_tmp32_ = vala_ccode_identifier_new (vala_symbol_get_name ((ValaSymbol*) detail_temp_decl))))));
				_vala_ccode_node_unref0 (_tmp33_);
				_vala_ccode_node_unref0 (_tmp32_);
				vala_ccode_function_call_add_argument (parse_call, (ValaCCodeExpression*) (_tmp34_ = vala_ccode_constant_new ("TRUE")));
				_vala_ccode_node_unref0 (_tmp34_);
			}
			vala_ccode_comma_expression_append_expression (ccomma, (ValaCCodeExpression*) parse_call);
			vala_ccode_function_call_add_argument (ccall, _tmp35_ = vala_ccode_base_module_get_variable_cexpression ((ValaCCodeBaseModule*) self, vala_symbol_get_name ((ValaSymbol*) temp_decl)));
			_vala_ccode_node_unref0 (_tmp35_);
			if (detail_temp_decl == NULL) {
				ValaCCodeConstant* _tmp36_;
				vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp36_ = vala_ccode_constant_new ("0")));
				_vala_ccode_node_unref0 (_tmp36_);
			} else {
				ValaCCodeExpression* _tmp37_;
				vala_ccode_function_call_add_argument (ccall, _tmp37_ = vala_ccode_base_module_get_variable_cexpression ((ValaCCodeBaseModule*) self, vala_symbol_get_name ((ValaSymbol*) detail_temp_decl)));
				_vala_ccode_node_unref0 (_tmp37_);
			}
			vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp38_ = vala_ccode_constant_new ("NULL")));
			_vala_ccode_node_unref0 (_tmp38_);
			_vala_code_node_unref0 (detail_temp_decl);
			_vala_code_node_unref0 (decl_type);
			_vala_ccode_node_unref0 (parse_call);
			_vala_code_node_unref0 (temp_decl);
		}
	}
	vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp39_ = vala_ccode_cast_expression_new (VALA_CCODE_EXPRESSION (vala_code_node_get_ccodenode ((ValaCodeNode*) handler)), "GCallback")));
	_vala_ccode_node_unref0 (_tmp39_);
	if (vala_method_get_closure (m)) {
		ValaCCodeExpression* handler_destroy_notify;
		ValaCCodeExpression* _tmp40_ = NULL;
		ValaCCodeExpression* _tmp41_;
		ValaCCodeExpression* _tmp42_;
		ValaCCodeExpression* _tmp43_;
		ValaCCodeCastExpression* _tmp44_;
		handler_destroy_notify = NULL;
		vala_ccode_function_call_add_argument (ccall, _tmp43_ = (_tmp41_ = vala_ccode_base_module_get_delegate_target_cexpression ((ValaCCodeBaseModule*) self, handler, &_tmp40_), handler_destroy_notify = (_tmp42_ = _tmp40_, _vala_ccode_node_unref0 (handler_destroy_notify), _tmp42_), _tmp41_));
		_vala_ccode_node_unref0 (_tmp43_);
		vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp44_ = vala_ccode_cast_expression_new (handler_destroy_notify, "GClosureNotify")));
		_vala_ccode_node_unref0 (_tmp44_);
		if (!after) {
			ValaCCodeConstant* _tmp45_;
			vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp45_ = vala_ccode_constant_new ("0")));
			_vala_ccode_node_unref0 (_tmp45_);
		} else {
			ValaCCodeConstant* _tmp46_;
			vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp46_ = vala_ccode_constant_new ("G_CONNECT_AFTER")));
			_vala_ccode_node_unref0 (_tmp46_);
		}
		_vala_ccode_node_unref0 (handler_destroy_notify);
	} else {
		if (vala_method_get_binding (m) == MEMBER_BINDING_INSTANCE) {
			gboolean _tmp49_ = FALSE;
			gboolean _tmp50_ = FALSE;
			if (VALA_IS_MEMBER_ACCESS (handler)) {
				ValaMemberAccess* right_ma;
				right_ma = _vala_code_node_ref0 (VALA_MEMBER_ACCESS (handler));
				if (vala_member_access_get_inner (right_ma) != NULL) {
					vala_ccode_function_call_add_argument (ccall, VALA_CCODE_EXPRESSION (vala_code_node_get_ccodenode ((ValaCodeNode*) vala_member_access_get_inner (right_ma))));
				} else {
					ValaCCodeExpression* _tmp47_;
					vala_ccode_function_call_add_argument (ccall, _tmp47_ = vala_ccode_base_module_get_result_cexpression ((ValaCCodeBaseModule*) self, "self"));
					_vala_ccode_node_unref0 (_tmp47_);
				}
				_vala_code_node_unref0 (right_ma);
			} else {
				if (VALA_IS_LAMBDA_EXPRESSION (handler)) {
					ValaCCodeExpression* _tmp48_;
					vala_ccode_function_call_add_argument (ccall, _tmp48_ = vala_ccode_base_module_get_result_cexpression ((ValaCCodeBaseModule*) self, "self"));
					_vala_ccode_node_unref0 (_tmp48_);
				}
			}
			if (!disconnect) {
				_tmp50_ = !VALA_IS_DYNAMIC_SIGNAL (sig);
			} else {
				_tmp50_ = FALSE;
			}
			if (_tmp50_) {
				_tmp49_ = vala_gsignal_module_in_gobject_instance (self, m);
			} else {
				_tmp49_ = FALSE;
			}
			if (_tmp49_) {
				if (!after) {
					ValaCCodeConstant* _tmp51_;
					vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp51_ = vala_ccode_constant_new ("0")));
					_vala_ccode_node_unref0 (_tmp51_);
				} else {
					ValaCCodeConstant* _tmp52_;
					vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp52_ = vala_ccode_constant_new ("G_CONNECT_AFTER")));
					_vala_ccode_node_unref0 (_tmp52_);
				}
			}
		} else {
			ValaCCodeConstant* _tmp53_;
			vala_ccode_function_call_add_argument (ccall, (ValaCCodeExpression*) (_tmp53_ = vala_ccode_constant_new ("NULL")));
			_vala_ccode_node_unref0 (_tmp53_);
		}
	}
	if (ccomma != NULL) {
		vala_ccode_comma_expression_append_expression (ccomma, (ValaCCodeExpression*) ccall);
		result = (ValaCCodeExpression*) ccomma;
		_vala_code_node_unref0 (ma);
		_vala_ccode_node_unref0 (signal_name_cexpr);
		_vala_ccode_node_unref0 (ccall);
		_vala_code_node_unref0 (m);
		_g_free0 (connect_func);
		return result;
	} else {
		result = (ValaCCodeExpression*) ccall;
		_vala_ccode_node_unref0 (ccomma);
		_vala_code_node_unref0 (ma);
		_vala_ccode_node_unref0 (signal_name_cexpr);
		_vala_code_node_unref0 (m);
		_g_free0 (connect_func);
		return result;
	}
	_vala_ccode_node_unref0 (ccomma);
	_vala_code_node_unref0 (ma);
	_vala_ccode_node_unref0 (signal_name_cexpr);
	_vala_ccode_node_unref0 (ccall);
	_vala_code_node_unref0 (m);
	_g_free0 (connect_func);
}


ValaGSignalModule* vala_gsignal_module_construct (GType object_type) {
	ValaGSignalModule* self = NULL;
	self = (ValaGSignalModule*) vala_gobject_module_construct (object_type);
	return self;
}


ValaGSignalModule* vala_gsignal_module_new (void) {
	return vala_gsignal_module_construct (VALA_TYPE_GSIGNAL_MODULE);
}


static void vala_gsignal_module_class_init (ValaGSignalModuleClass * klass) {
	vala_gsignal_module_parent_class = g_type_class_peek_parent (klass);
	VALA_CCODE_BASE_MODULE_CLASS (klass)->get_marshaller_function = vala_gsignal_module_real_get_marshaller_function;
	VALA_CODE_VISITOR_CLASS (klass)->visit_signal = vala_gsignal_module_real_visit_signal;
	VALA_CCODE_BASE_MODULE_CLASS (klass)->generate_marshaller = vala_gsignal_module_real_generate_marshaller;
	VALA_CCODE_BASE_MODULE_CLASS (klass)->get_signal_creation = vala_gsignal_module_real_get_signal_creation;
	VALA_GSIGNAL_MODULE_CLASS (klass)->get_dbus_g_type = vala_gsignal_module_real_get_dbus_g_type;
	VALA_CODE_VISITOR_CLASS (klass)->visit_element_access = vala_gsignal_module_real_visit_element_access;
	VALA_CODE_VISITOR_CLASS (klass)->visit_assignment = vala_gsignal_module_real_visit_assignment;
	VALA_CODE_VISITOR_CLASS (klass)->visit_member_access = vala_gsignal_module_real_visit_member_access;
	VALA_CODE_VISITOR_CLASS (klass)->visit_method_call = vala_gsignal_module_real_visit_method_call;
}


static void vala_gsignal_module_instance_init (ValaGSignalModule * self) {
}


GType vala_gsignal_module_get_type (void) {
	static volatile gsize vala_gsignal_module_type_id__volatile = 0;
	if (g_once_init_enter (&vala_gsignal_module_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValaGSignalModuleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_gsignal_module_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaGSignalModule), 0, (GInstanceInitFunc) vala_gsignal_module_instance_init, NULL };
		GType vala_gsignal_module_type_id;
		vala_gsignal_module_type_id = g_type_register_static (VALA_TYPE_GOBJECT_MODULE, "ValaGSignalModule", &g_define_type_info, 0);
		g_once_init_leave (&vala_gsignal_module_type_id__volatile, vala_gsignal_module_type_id);
	}
	return vala_gsignal_module_type_id__volatile;
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




