/* valadovacontrolflowmodule.c generated by valac, the Vala compiler
 * generated from valadovacontrolflowmodule.vala, do not modify */

/* valadovacontrolflowmodule.vala
 *
 * Copyright (C) 2006-2010  Jürg Billeter
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 */

#include <glib.h>
#include <glib-object.h>
#include <vala.h>
#include <valaccode.h>
#include <stdlib.h>
#include <string.h>
#include <valagee.h>


#define VALA_TYPE_DOVA_BASE_MODULE (vala_dova_base_module_get_type ())
#define VALA_DOVA_BASE_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DOVA_BASE_MODULE, ValaDovaBaseModule))
#define VALA_DOVA_BASE_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DOVA_BASE_MODULE, ValaDovaBaseModuleClass))
#define VALA_IS_DOVA_BASE_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DOVA_BASE_MODULE))
#define VALA_IS_DOVA_BASE_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DOVA_BASE_MODULE))
#define VALA_DOVA_BASE_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DOVA_BASE_MODULE, ValaDovaBaseModuleClass))

typedef struct _ValaDovaBaseModule ValaDovaBaseModule;
typedef struct _ValaDovaBaseModuleClass ValaDovaBaseModuleClass;
typedef struct _ValaDovaBaseModulePrivate ValaDovaBaseModulePrivate;

#define VALA_TYPE_CCODE_DECLARATION_SPACE (vala_ccode_declaration_space_get_type ())
#define VALA_CCODE_DECLARATION_SPACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CCODE_DECLARATION_SPACE, ValaCCodeDeclarationSpace))
#define VALA_CCODE_DECLARATION_SPACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CCODE_DECLARATION_SPACE, ValaCCodeDeclarationSpaceClass))
#define VALA_IS_CCODE_DECLARATION_SPACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CCODE_DECLARATION_SPACE))
#define VALA_IS_CCODE_DECLARATION_SPACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CCODE_DECLARATION_SPACE))
#define VALA_CCODE_DECLARATION_SPACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CCODE_DECLARATION_SPACE, ValaCCodeDeclarationSpaceClass))

typedef struct _ValaCCodeDeclarationSpace ValaCCodeDeclarationSpace;
typedef struct _ValaCCodeDeclarationSpaceClass ValaCCodeDeclarationSpaceClass;

#define VALA_DOVA_BASE_MODULE_TYPE_EMIT_CONTEXT (vala_dova_base_module_emit_context_get_type ())
#define VALA_DOVA_BASE_MODULE_EMIT_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_DOVA_BASE_MODULE_TYPE_EMIT_CONTEXT, ValaDovaBaseModuleEmitContext))
#define VALA_DOVA_BASE_MODULE_EMIT_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_DOVA_BASE_MODULE_TYPE_EMIT_CONTEXT, ValaDovaBaseModuleEmitContextClass))
#define VALA_DOVA_BASE_MODULE_IS_EMIT_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_DOVA_BASE_MODULE_TYPE_EMIT_CONTEXT))
#define VALA_DOVA_BASE_MODULE_IS_EMIT_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_DOVA_BASE_MODULE_TYPE_EMIT_CONTEXT))
#define VALA_DOVA_BASE_MODULE_EMIT_CONTEXT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_DOVA_BASE_MODULE_TYPE_EMIT_CONTEXT, ValaDovaBaseModuleEmitContextClass))

typedef struct _ValaDovaBaseModuleEmitContext ValaDovaBaseModuleEmitContext;
typedef struct _ValaDovaBaseModuleEmitContextClass ValaDovaBaseModuleEmitContextClass;

#define VALA_TYPE_DOVA_STRUCT_MODULE (vala_dova_struct_module_get_type ())
#define VALA_DOVA_STRUCT_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DOVA_STRUCT_MODULE, ValaDovaStructModule))
#define VALA_DOVA_STRUCT_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DOVA_STRUCT_MODULE, ValaDovaStructModuleClass))
#define VALA_IS_DOVA_STRUCT_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DOVA_STRUCT_MODULE))
#define VALA_IS_DOVA_STRUCT_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DOVA_STRUCT_MODULE))
#define VALA_DOVA_STRUCT_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DOVA_STRUCT_MODULE, ValaDovaStructModuleClass))

typedef struct _ValaDovaStructModule ValaDovaStructModule;
typedef struct _ValaDovaStructModuleClass ValaDovaStructModuleClass;
typedef struct _ValaDovaStructModulePrivate ValaDovaStructModulePrivate;

#define VALA_TYPE_DOVA_METHOD_MODULE (vala_dova_method_module_get_type ())
#define VALA_DOVA_METHOD_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DOVA_METHOD_MODULE, ValaDovaMethodModule))
#define VALA_DOVA_METHOD_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DOVA_METHOD_MODULE, ValaDovaMethodModuleClass))
#define VALA_IS_DOVA_METHOD_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DOVA_METHOD_MODULE))
#define VALA_IS_DOVA_METHOD_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DOVA_METHOD_MODULE))
#define VALA_DOVA_METHOD_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DOVA_METHOD_MODULE, ValaDovaMethodModuleClass))

typedef struct _ValaDovaMethodModule ValaDovaMethodModule;
typedef struct _ValaDovaMethodModuleClass ValaDovaMethodModuleClass;
typedef struct _ValaDovaMethodModulePrivate ValaDovaMethodModulePrivate;

#define VALA_TYPE_DOVA_CONTROL_FLOW_MODULE (vala_dova_control_flow_module_get_type ())
#define VALA_DOVA_CONTROL_FLOW_MODULE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DOVA_CONTROL_FLOW_MODULE, ValaDovaControlFlowModule))
#define VALA_DOVA_CONTROL_FLOW_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DOVA_CONTROL_FLOW_MODULE, ValaDovaControlFlowModuleClass))
#define VALA_IS_DOVA_CONTROL_FLOW_MODULE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DOVA_CONTROL_FLOW_MODULE))
#define VALA_IS_DOVA_CONTROL_FLOW_MODULE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DOVA_CONTROL_FLOW_MODULE))
#define VALA_DOVA_CONTROL_FLOW_MODULE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DOVA_CONTROL_FLOW_MODULE, ValaDovaControlFlowModuleClass))

typedef struct _ValaDovaControlFlowModule ValaDovaControlFlowModule;
typedef struct _ValaDovaControlFlowModuleClass ValaDovaControlFlowModuleClass;
typedef struct _ValaDovaControlFlowModulePrivate ValaDovaControlFlowModulePrivate;
#define _vala_ccode_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_ccode_node_unref (var), NULL)))
#define _vala_collection_object_unref0(var) ((var == NULL) ? NULL : (var = (vala_collection_object_unref (var), NULL)))
#define _vala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_node_unref (var), NULL)))

struct _ValaDovaBaseModule {
	ValaCodeGenerator parent_instance;
	ValaDovaBaseModulePrivate * priv;
	ValaSymbol* root_symbol;
	ValaDovaBaseModuleEmitContext* emit_context;
	ValaCCodeDeclarationSpace* header_declarations;
	ValaCCodeDeclarationSpace* source_declarations;
	ValaCCodeFragment* source_type_member_definition;
	ValaCCodeFragment* module_init_fragment;
	ValaCCodeFragment* instance_init_fragment;
	ValaCCodeFragment* instance_finalize_fragment;
	ValaCCodeFragment* pre_statement_fragment;
	gint next_wrapper_id;
	ValaDataType* void_type;
	ValaDataType* bool_type;
	ValaDataType* char_type;
	ValaDataType* short_type;
	ValaDataType* ushort_type;
	ValaDataType* int_type;
	ValaDataType* uint_type;
	ValaDataType* long_type;
	ValaDataType* ulong_type;
	ValaDataType* string_type;
	ValaDataType* float_type;
	ValaDataType* double_type;
	ValaClass* object_class;
	ValaClass* type_class;
	ValaClass* value_class;
	ValaClass* string_class;
	ValaClass* array_class;
	ValaClass* delegate_class;
	ValaClass* error_class;
};

struct _ValaDovaBaseModuleClass {
	ValaCodeGeneratorClass parent_class;
	void (*generate_struct_declaration) (ValaDovaBaseModule* self, ValaStruct* st, ValaCCodeDeclarationSpace* decl_space);
	void (*generate_delegate_declaration) (ValaDovaBaseModule* self, ValaDelegate* d, ValaCCodeDeclarationSpace* decl_space);
	void (*generate_cparameters) (ValaDovaBaseModule* self, ValaMethod* m, ValaCCodeDeclarationSpace* decl_space, ValaCCodeFunction* func, ValaCCodeFunctionDeclarator* vdeclarator, ValaCCodeFunctionCall* vcall);
	void (*generate_property_accessor_declaration) (ValaDovaBaseModule* self, ValaPropertyAccessor* acc, ValaCCodeDeclarationSpace* decl_space);
	ValaCCodeExpression* (*get_dup_func_expression) (ValaDovaBaseModule* self, ValaDataType* type, ValaSourceReference* source_reference, gboolean is_chainup);
	ValaCCodeExpression* (*get_unref_expression) (ValaDovaBaseModule* self, ValaCCodeExpression* cvar, ValaDataType* type, ValaExpression* expr);
	void (*append_local_free) (ValaDovaBaseModule* self, ValaSymbol* sym, ValaCCodeFragment* cfrag, gboolean stop_at_loop);
	ValaCCodeExpression* (*get_ref_cexpression) (ValaDovaBaseModule* self, ValaDataType* expression_type, ValaCCodeExpression* cexpr, ValaExpression* expr, ValaCodeNode* node);
	void (*generate_class_declaration) (ValaDovaBaseModule* self, ValaClass* cl, ValaCCodeDeclarationSpace* decl_space);
	void (*generate_interface_declaration) (ValaDovaBaseModule* self, ValaInterface* iface, ValaCCodeDeclarationSpace* decl_space);
	void (*generate_method_declaration) (ValaDovaBaseModule* self, ValaMethod* m, ValaCCodeDeclarationSpace* decl_space);
	ValaCCodeExpression* (*get_implicit_cast_expression) (ValaDovaBaseModule* self, ValaCCodeExpression* source_cexpr, ValaDataType* expression_type, ValaDataType* target_type, ValaExpression* expr);
	char* (*get_custom_creturn_type) (ValaDovaBaseModule* self, ValaMethod* m);
	gboolean (*method_has_wrapper) (ValaDovaBaseModule* self, ValaMethod* method);
	void (*add_simple_check) (ValaDovaBaseModule* self, ValaCodeNode* node, ValaCCodeFragment* cfrag, gboolean always_fails);
};

struct _ValaDovaStructModule {
	ValaDovaBaseModule parent_instance;
	ValaDovaStructModulePrivate * priv;
};

struct _ValaDovaStructModuleClass {
	ValaDovaBaseModuleClass parent_class;
};

struct _ValaDovaMethodModule {
	ValaDovaStructModule parent_instance;
	ValaDovaMethodModulePrivate * priv;
};

struct _ValaDovaMethodModuleClass {
	ValaDovaStructModuleClass parent_class;
};

struct _ValaDovaControlFlowModule {
	ValaDovaMethodModule parent_instance;
	ValaDovaControlFlowModulePrivate * priv;
};

struct _ValaDovaControlFlowModuleClass {
	ValaDovaMethodModuleClass parent_class;
};


static gpointer vala_dova_control_flow_module_parent_class = NULL;

GType vala_dova_base_module_get_type (void) G_GNUC_CONST;
gpointer vala_ccode_declaration_space_ref (gpointer instance);
void vala_ccode_declaration_space_unref (gpointer instance);
GParamSpec* vala_param_spec_ccode_declaration_space (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_ccode_declaration_space (GValue* value, gpointer v_object);
void vala_value_take_ccode_declaration_space (GValue* value, gpointer v_object);
gpointer vala_value_get_ccode_declaration_space (const GValue* value);
GType vala_ccode_declaration_space_get_type (void) G_GNUC_CONST;
gpointer vala_dova_base_module_emit_context_ref (gpointer instance);
void vala_dova_base_module_emit_context_unref (gpointer instance);
GParamSpec* vala_dova_base_module_param_spec_emit_context (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_dova_base_module_value_set_emit_context (GValue* value, gpointer v_object);
void vala_dova_base_module_value_take_emit_context (GValue* value, gpointer v_object);
gpointer vala_dova_base_module_value_get_emit_context (const GValue* value);
GType vala_dova_base_module_emit_context_get_type (void) G_GNUC_CONST;
GType vala_dova_struct_module_get_type (void) G_GNUC_CONST;
GType vala_dova_method_module_get_type (void) G_GNUC_CONST;
GType vala_dova_control_flow_module_get_type (void) G_GNUC_CONST;
enum  {
	VALA_DOVA_CONTROL_FLOW_MODULE_DUMMY_PROPERTY
};
static void vala_dova_control_flow_module_real_visit_if_statement (ValaCodeVisitor* base, ValaIfStatement* stmt);
void vala_dova_base_module_create_temp_decl (ValaDovaBaseModule* self, ValaStatement* stmt, ValaList* temp_vars);
static void vala_dova_control_flow_module_real_visit_switch_statement (ValaCodeVisitor* base, ValaSwitchStatement* stmt);
static void vala_dova_control_flow_module_real_visit_switch_label (ValaCodeVisitor* base, ValaSwitchLabel* label);
static void vala_dova_control_flow_module_real_visit_loop (ValaCodeVisitor* base, ValaLoop* stmt);
static void vala_dova_control_flow_module_real_visit_break_statement (ValaCodeVisitor* base, ValaBreakStatement* stmt);
void vala_dova_base_module_create_local_free (ValaDovaBaseModule* self, ValaCodeNode* stmt, gboolean stop_at_loop);
static void vala_dova_control_flow_module_real_visit_continue_statement (ValaCodeVisitor* base, ValaContinueStatement* stmt);
ValaDovaControlFlowModule* vala_dova_control_flow_module_new (void);
ValaDovaControlFlowModule* vala_dova_control_flow_module_construct (GType object_type);
ValaDovaMethodModule* vala_dova_method_module_new (void);
ValaDovaMethodModule* vala_dova_method_module_construct (GType object_type);



static void vala_dova_control_flow_module_real_visit_if_statement (ValaCodeVisitor* base, ValaIfStatement* stmt) {
	ValaDovaControlFlowModule * self;
	self = (ValaDovaControlFlowModule*) base;
	g_return_if_fail (stmt != NULL);
	vala_code_node_emit ((ValaCodeNode*) vala_if_statement_get_true_statement (stmt), (ValaCodeGenerator*) self);
	if (vala_if_statement_get_false_statement (stmt) != NULL) {
		vala_code_node_emit ((ValaCodeNode*) vala_if_statement_get_false_statement (stmt), (ValaCodeGenerator*) self);
	}
	if (vala_if_statement_get_false_statement (stmt) != NULL) {
		ValaCCodeIfStatement* _tmp0_;
		vala_code_node_set_ccodenode ((ValaCodeNode*) stmt, (ValaCCodeNode*) (_tmp0_ = vala_ccode_if_statement_new (VALA_CCODE_EXPRESSION (vala_code_node_get_ccodenode ((ValaCodeNode*) vala_if_statement_get_condition (stmt))), VALA_CCODE_STATEMENT (vala_code_node_get_ccodenode ((ValaCodeNode*) vala_if_statement_get_true_statement (stmt))), VALA_CCODE_STATEMENT (vala_code_node_get_ccodenode ((ValaCodeNode*) vala_if_statement_get_false_statement (stmt))))));
		_vala_ccode_node_unref0 (_tmp0_);
	} else {
		ValaCCodeIfStatement* _tmp1_;
		vala_code_node_set_ccodenode ((ValaCodeNode*) stmt, (ValaCCodeNode*) (_tmp1_ = vala_ccode_if_statement_new (VALA_CCODE_EXPRESSION (vala_code_node_get_ccodenode ((ValaCodeNode*) vala_if_statement_get_condition (stmt))), VALA_CCODE_STATEMENT (vala_code_node_get_ccodenode ((ValaCodeNode*) vala_if_statement_get_true_statement (stmt))), NULL)));
		_vala_ccode_node_unref0 (_tmp1_);
	}
	vala_dova_base_module_create_temp_decl ((ValaDovaBaseModule*) self, (ValaStatement*) stmt, (ValaList*) vala_if_statement_get_condition (stmt)->temp_vars);
}


static void vala_dova_control_flow_module_real_visit_switch_statement (ValaCodeVisitor* base, ValaSwitchStatement* stmt) {
	ValaDovaControlFlowModule * self;
	ValaCCodeSwitchStatement* cswitch;
	self = (ValaDovaControlFlowModule*) base;
	g_return_if_fail (stmt != NULL);
	{
		ValaList* _tmp0_;
		ValaIterator* _tmp1_;
		ValaIterator* _section_it;
		_section_it = (_tmp1_ = vala_iterable_iterator ((ValaIterable*) (_tmp0_ = vala_switch_statement_get_sections (stmt))), _vala_collection_object_unref0 (_tmp0_), _tmp1_);
		while (TRUE) {
			ValaSwitchSection* section;
			if (!vala_iterator_next (_section_it)) {
				break;
			}
			section = (ValaSwitchSection*) vala_iterator_get (_section_it);
			vala_code_node_emit ((ValaCodeNode*) section, (ValaCodeGenerator*) self);
			_vala_code_node_unref0 (section);
		}
		_vala_collection_object_unref0 (_section_it);
	}
	cswitch = vala_ccode_switch_statement_new (VALA_CCODE_EXPRESSION (vala_code_node_get_ccodenode ((ValaCodeNode*) vala_switch_statement_get_expression (stmt))));
	vala_code_node_set_ccodenode ((ValaCodeNode*) stmt, (ValaCCodeNode*) cswitch);
	{
		ValaList* _tmp2_;
		ValaIterator* _tmp3_;
		ValaIterator* _section_it;
		_section_it = (_tmp3_ = vala_iterable_iterator ((ValaIterable*) (_tmp2_ = vala_switch_statement_get_sections (stmt))), _vala_collection_object_unref0 (_tmp2_), _tmp3_);
		while (TRUE) {
			ValaSwitchSection* section;
			ValaCCodeBlock* cblock;
			if (!vala_iterator_next (_section_it)) {
				break;
			}
			section = (ValaSwitchSection*) vala_iterator_get (_section_it);
			if (vala_switch_section_has_default_label (section)) {
				ValaCCodeLabel* _tmp4_;
				ValaCCodeBlock* cdefaultblock;
				vala_ccode_block_add_statement ((ValaCCodeBlock*) cswitch, (ValaCCodeNode*) (_tmp4_ = vala_ccode_label_new ("default")));
				_vala_ccode_node_unref0 (_tmp4_);
				cdefaultblock = vala_ccode_block_new ();
				vala_ccode_block_add_statement ((ValaCCodeBlock*) cswitch, (ValaCCodeNode*) cdefaultblock);
				{
					ValaList* _tmp5_;
					ValaIterator* _tmp6_;
					ValaIterator* _default_stmt_it;
					_default_stmt_it = (_tmp6_ = vala_iterable_iterator ((ValaIterable*) (_tmp5_ = vala_block_get_statements ((ValaBlock*) section))), _vala_collection_object_unref0 (_tmp5_), _tmp6_);
					while (TRUE) {
						ValaCodeNode* default_stmt;
						if (!vala_iterator_next (_default_stmt_it)) {
							break;
						}
						default_stmt = (ValaCodeNode*) ((ValaStatement*) vala_iterator_get (_default_stmt_it));
						vala_ccode_block_add_statement (cdefaultblock, vala_code_node_get_ccodenode (default_stmt));
						_vala_code_node_unref0 (default_stmt);
					}
					_vala_collection_object_unref0 (_default_stmt_it);
				}
				_vala_ccode_node_unref0 (cdefaultblock);
				_vala_code_node_unref0 (section);
				continue;
			}
			{
				ValaList* _tmp7_;
				ValaIterator* _tmp8_;
				ValaIterator* _label_it;
				_label_it = (_tmp8_ = vala_iterable_iterator ((ValaIterable*) (_tmp7_ = vala_switch_section_get_labels (section))), _vala_collection_object_unref0 (_tmp7_), _tmp8_);
				while (TRUE) {
					ValaSwitchLabel* label;
					ValaCCodeCaseStatement* _tmp9_;
					if (!vala_iterator_next (_label_it)) {
						break;
					}
					label = (ValaSwitchLabel*) vala_iterator_get (_label_it);
					vala_ccode_block_add_statement ((ValaCCodeBlock*) cswitch, (ValaCCodeNode*) (_tmp9_ = vala_ccode_case_statement_new (VALA_CCODE_EXPRESSION (vala_code_node_get_ccodenode ((ValaCodeNode*) vala_switch_label_get_expression (label))))));
					_vala_ccode_node_unref0 (_tmp9_);
					_vala_code_node_unref0 (label);
				}
				_vala_collection_object_unref0 (_label_it);
			}
			cblock = vala_ccode_block_new ();
			vala_ccode_block_add_statement ((ValaCCodeBlock*) cswitch, (ValaCCodeNode*) cblock);
			{
				ValaList* _tmp10_;
				ValaIterator* _tmp11_;
				ValaIterator* _body_stmt_it;
				_body_stmt_it = (_tmp11_ = vala_iterable_iterator ((ValaIterable*) (_tmp10_ = vala_block_get_statements ((ValaBlock*) section))), _vala_collection_object_unref0 (_tmp10_), _tmp11_);
				while (TRUE) {
					ValaCodeNode* body_stmt;
					if (!vala_iterator_next (_body_stmt_it)) {
						break;
					}
					body_stmt = (ValaCodeNode*) ((ValaStatement*) vala_iterator_get (_body_stmt_it));
					vala_ccode_block_add_statement (cblock, vala_code_node_get_ccodenode (body_stmt));
					_vala_code_node_unref0 (body_stmt);
				}
				_vala_collection_object_unref0 (_body_stmt_it);
			}
			_vala_ccode_node_unref0 (cblock);
			_vala_code_node_unref0 (section);
		}
		_vala_collection_object_unref0 (_section_it);
	}
	vala_dova_base_module_create_temp_decl ((ValaDovaBaseModule*) self, (ValaStatement*) stmt, (ValaList*) vala_switch_statement_get_expression (stmt)->temp_vars);
	_vala_ccode_node_unref0 (cswitch);
}


static void vala_dova_control_flow_module_real_visit_switch_label (ValaCodeVisitor* base, ValaSwitchLabel* label) {
	ValaDovaControlFlowModule * self;
	self = (ValaDovaControlFlowModule*) base;
	g_return_if_fail (label != NULL);
	if (vala_switch_label_get_expression (label) != NULL) {
		vala_code_node_emit ((ValaCodeNode*) vala_switch_label_get_expression (label), (ValaCodeGenerator*) self);
		vala_code_visitor_visit_end_full_expression ((ValaCodeVisitor*) self, vala_switch_label_get_expression (label));
	}
}


static void vala_dova_control_flow_module_real_visit_loop (ValaCodeVisitor* base, ValaLoop* stmt) {
	ValaDovaControlFlowModule * self;
	ValaCCodeConstant* _tmp0_;
	ValaCCodeWhileStatement* _tmp1_;
	self = (ValaDovaControlFlowModule*) base;
	g_return_if_fail (stmt != NULL);
	vala_code_node_emit ((ValaCodeNode*) vala_loop_get_body (stmt), (ValaCodeGenerator*) self);
	vala_code_node_set_ccodenode ((ValaCodeNode*) stmt, (ValaCCodeNode*) (_tmp1_ = vala_ccode_while_statement_new ((ValaCCodeExpression*) (_tmp0_ = vala_ccode_constant_new ("true")), VALA_CCODE_STATEMENT (vala_code_node_get_ccodenode ((ValaCodeNode*) vala_loop_get_body (stmt))))));
	_vala_ccode_node_unref0 (_tmp1_);
	_vala_ccode_node_unref0 (_tmp0_);
}


static void vala_dova_control_flow_module_real_visit_break_statement (ValaCodeVisitor* base, ValaBreakStatement* stmt) {
	ValaDovaControlFlowModule * self;
	ValaCCodeBreakStatement* _tmp0_;
	self = (ValaDovaControlFlowModule*) base;
	g_return_if_fail (stmt != NULL);
	vala_code_node_set_ccodenode ((ValaCodeNode*) stmt, (ValaCCodeNode*) (_tmp0_ = vala_ccode_break_statement_new ()));
	_vala_ccode_node_unref0 (_tmp0_);
	vala_dova_base_module_create_local_free ((ValaDovaBaseModule*) self, (ValaCodeNode*) stmt, TRUE);
}


static void vala_dova_control_flow_module_real_visit_continue_statement (ValaCodeVisitor* base, ValaContinueStatement* stmt) {
	ValaDovaControlFlowModule * self;
	ValaCCodeContinueStatement* _tmp0_;
	self = (ValaDovaControlFlowModule*) base;
	g_return_if_fail (stmt != NULL);
	vala_code_node_set_ccodenode ((ValaCodeNode*) stmt, (ValaCCodeNode*) (_tmp0_ = vala_ccode_continue_statement_new ()));
	_vala_ccode_node_unref0 (_tmp0_);
	vala_dova_base_module_create_local_free ((ValaDovaBaseModule*) self, (ValaCodeNode*) stmt, TRUE);
}


ValaDovaControlFlowModule* vala_dova_control_flow_module_construct (GType object_type) {
	ValaDovaControlFlowModule* self = NULL;
	self = (ValaDovaControlFlowModule*) vala_dova_method_module_construct (object_type);
	return self;
}


ValaDovaControlFlowModule* vala_dova_control_flow_module_new (void) {
	return vala_dova_control_flow_module_construct (VALA_TYPE_DOVA_CONTROL_FLOW_MODULE);
}


static void vala_dova_control_flow_module_class_init (ValaDovaControlFlowModuleClass * klass) {
	vala_dova_control_flow_module_parent_class = g_type_class_peek_parent (klass);
	VALA_CODE_VISITOR_CLASS (klass)->visit_if_statement = vala_dova_control_flow_module_real_visit_if_statement;
	VALA_CODE_VISITOR_CLASS (klass)->visit_switch_statement = vala_dova_control_flow_module_real_visit_switch_statement;
	VALA_CODE_VISITOR_CLASS (klass)->visit_switch_label = vala_dova_control_flow_module_real_visit_switch_label;
	VALA_CODE_VISITOR_CLASS (klass)->visit_loop = vala_dova_control_flow_module_real_visit_loop;
	VALA_CODE_VISITOR_CLASS (klass)->visit_break_statement = vala_dova_control_flow_module_real_visit_break_statement;
	VALA_CODE_VISITOR_CLASS (klass)->visit_continue_statement = vala_dova_control_flow_module_real_visit_continue_statement;
}


static void vala_dova_control_flow_module_instance_init (ValaDovaControlFlowModule * self) {
}


GType vala_dova_control_flow_module_get_type (void) {
	static volatile gsize vala_dova_control_flow_module_type_id__volatile = 0;
	if (g_once_init_enter (&vala_dova_control_flow_module_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValaDovaControlFlowModuleClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_dova_control_flow_module_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaDovaControlFlowModule), 0, (GInstanceInitFunc) vala_dova_control_flow_module_instance_init, NULL };
		GType vala_dova_control_flow_module_type_id;
		vala_dova_control_flow_module_type_id = g_type_register_static (VALA_TYPE_DOVA_METHOD_MODULE, "ValaDovaControlFlowModule", &g_define_type_info, 0);
		g_once_init_leave (&vala_dova_control_flow_module_type_id__volatile, vala_dova_control_flow_module_type_id);
	}
	return vala_dova_control_flow_module_type_id__volatile;
}




