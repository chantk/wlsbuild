/* valagenieparser.c generated by valac, the Vala compiler
 * generated from valagenieparser.vala, do not modify */

/* valagenieparser.vala
 *
 * Copyright (C) 2008  Jamie McCracken, Jürg Billeter
 * Based on code by Jürg Billeter
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jamie McCracken jamiemcc gnome org
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <valagee.h>


#define VALA_TYPE_CODE_VISITOR (vala_code_visitor_get_type ())
#define VALA_CODE_VISITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_VISITOR, ValaCodeVisitor))
#define VALA_CODE_VISITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_VISITOR, ValaCodeVisitorClass))
#define VALA_IS_CODE_VISITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_VISITOR))
#define VALA_IS_CODE_VISITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_VISITOR))
#define VALA_CODE_VISITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_VISITOR, ValaCodeVisitorClass))

typedef struct _ValaCodeVisitor ValaCodeVisitor;
typedef struct _ValaCodeVisitorClass ValaCodeVisitorClass;
typedef struct _ValaCodeVisitorPrivate ValaCodeVisitorPrivate;

#define VALA_TYPE_SOURCE_FILE (vala_source_file_get_type ())
#define VALA_SOURCE_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SOURCE_FILE, ValaSourceFile))
#define VALA_SOURCE_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SOURCE_FILE, ValaSourceFileClass))
#define VALA_IS_SOURCE_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SOURCE_FILE))
#define VALA_IS_SOURCE_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SOURCE_FILE))
#define VALA_SOURCE_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SOURCE_FILE, ValaSourceFileClass))

typedef struct _ValaSourceFile ValaSourceFile;
typedef struct _ValaSourceFileClass ValaSourceFileClass;

#define VALA_TYPE_CODE_NODE (vala_code_node_get_type ())
#define VALA_CODE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_NODE, ValaCodeNode))
#define VALA_CODE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_NODE, ValaCodeNodeClass))
#define VALA_IS_CODE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_NODE))
#define VALA_IS_CODE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_NODE))
#define VALA_CODE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_NODE, ValaCodeNodeClass))

typedef struct _ValaCodeNode ValaCodeNode;
typedef struct _ValaCodeNodeClass ValaCodeNodeClass;

#define VALA_TYPE_SYMBOL (vala_symbol_get_type ())
#define VALA_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SYMBOL, ValaSymbol))
#define VALA_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SYMBOL, ValaSymbolClass))
#define VALA_IS_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SYMBOL))
#define VALA_IS_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SYMBOL))
#define VALA_SYMBOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SYMBOL, ValaSymbolClass))

typedef struct _ValaSymbol ValaSymbol;
typedef struct _ValaSymbolClass ValaSymbolClass;

#define VALA_TYPE_NAMESPACE (vala_namespace_get_type ())
#define VALA_NAMESPACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_NAMESPACE, ValaNamespace))
#define VALA_NAMESPACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_NAMESPACE, ValaNamespaceClass))
#define VALA_IS_NAMESPACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_NAMESPACE))
#define VALA_IS_NAMESPACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_NAMESPACE))
#define VALA_NAMESPACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_NAMESPACE, ValaNamespaceClass))

typedef struct _ValaNamespace ValaNamespace;
typedef struct _ValaNamespaceClass ValaNamespaceClass;

#define VALA_TYPE_TYPESYMBOL (vala_typesymbol_get_type ())
#define VALA_TYPESYMBOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPESYMBOL, ValaTypeSymbol))
#define VALA_TYPESYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPESYMBOL, ValaTypeSymbolClass))
#define VALA_IS_TYPESYMBOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPESYMBOL))
#define VALA_IS_TYPESYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPESYMBOL))
#define VALA_TYPESYMBOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPESYMBOL, ValaTypeSymbolClass))

typedef struct _ValaTypeSymbol ValaTypeSymbol;
typedef struct _ValaTypeSymbolClass ValaTypeSymbolClass;

#define VALA_TYPE_OBJECT_TYPE_SYMBOL (vala_object_type_symbol_get_type ())
#define VALA_OBJECT_TYPE_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_OBJECT_TYPE_SYMBOL, ValaObjectTypeSymbol))
#define VALA_OBJECT_TYPE_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_OBJECT_TYPE_SYMBOL, ValaObjectTypeSymbolClass))
#define VALA_IS_OBJECT_TYPE_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_OBJECT_TYPE_SYMBOL))
#define VALA_IS_OBJECT_TYPE_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_OBJECT_TYPE_SYMBOL))
#define VALA_OBJECT_TYPE_SYMBOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_OBJECT_TYPE_SYMBOL, ValaObjectTypeSymbolClass))

typedef struct _ValaObjectTypeSymbol ValaObjectTypeSymbol;
typedef struct _ValaObjectTypeSymbolClass ValaObjectTypeSymbolClass;

#define VALA_TYPE_CLASS (vala_class_get_type ())
#define VALA_CLASS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CLASS, ValaClass))
#define VALA_CLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CLASS, ValaClassClass))
#define VALA_IS_CLASS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CLASS))
#define VALA_IS_CLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CLASS))
#define VALA_CLASS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CLASS, ValaClassClass))

typedef struct _ValaClass ValaClass;
typedef struct _ValaClassClass ValaClassClass;

#define VALA_TYPE_STRUCT (vala_struct_get_type ())
#define VALA_STRUCT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_STRUCT, ValaStruct))
#define VALA_STRUCT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_STRUCT, ValaStructClass))
#define VALA_IS_STRUCT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_STRUCT))
#define VALA_IS_STRUCT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_STRUCT))
#define VALA_STRUCT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_STRUCT, ValaStructClass))

typedef struct _ValaStruct ValaStruct;
typedef struct _ValaStructClass ValaStructClass;

#define VALA_TYPE_INTERFACE (vala_interface_get_type ())
#define VALA_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_INTERFACE, ValaInterface))
#define VALA_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_INTERFACE, ValaInterfaceClass))
#define VALA_IS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_INTERFACE))
#define VALA_IS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_INTERFACE))
#define VALA_INTERFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_INTERFACE, ValaInterfaceClass))

typedef struct _ValaInterface ValaInterface;
typedef struct _ValaInterfaceClass ValaInterfaceClass;

#define VALA_TYPE_ENUM (vala_enum_get_type ())
#define VALA_ENUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ENUM, ValaEnum))
#define VALA_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ENUM, ValaEnumClass))
#define VALA_IS_ENUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ENUM))
#define VALA_IS_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ENUM))
#define VALA_ENUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ENUM, ValaEnumClass))

typedef struct _ValaEnum ValaEnum;
typedef struct _ValaEnumClass ValaEnumClass;

#define VALA_TYPE_CONSTANT (vala_constant_get_type ())
#define VALA_CONSTANT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CONSTANT, ValaConstant))
#define VALA_CONSTANT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CONSTANT, ValaConstantClass))
#define VALA_IS_CONSTANT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CONSTANT))
#define VALA_IS_CONSTANT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CONSTANT))
#define VALA_CONSTANT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CONSTANT, ValaConstantClass))

typedef struct _ValaConstant ValaConstant;
typedef struct _ValaConstantClass ValaConstantClass;

#define VALA_TYPE_ENUM_VALUE (vala_enum_value_get_type ())
#define VALA_ENUM_VALUE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ENUM_VALUE, ValaEnumValue))
#define VALA_ENUM_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ENUM_VALUE, ValaEnumValueClass))
#define VALA_IS_ENUM_VALUE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ENUM_VALUE))
#define VALA_IS_ENUM_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ENUM_VALUE))
#define VALA_ENUM_VALUE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ENUM_VALUE, ValaEnumValueClass))

typedef struct _ValaEnumValue ValaEnumValue;
typedef struct _ValaEnumValueClass ValaEnumValueClass;

#define VALA_TYPE_ERROR_DOMAIN (vala_error_domain_get_type ())
#define VALA_ERROR_DOMAIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ERROR_DOMAIN, ValaErrorDomain))
#define VALA_ERROR_DOMAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ERROR_DOMAIN, ValaErrorDomainClass))
#define VALA_IS_ERROR_DOMAIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ERROR_DOMAIN))
#define VALA_IS_ERROR_DOMAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ERROR_DOMAIN))
#define VALA_ERROR_DOMAIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ERROR_DOMAIN, ValaErrorDomainClass))

typedef struct _ValaErrorDomain ValaErrorDomain;
typedef struct _ValaErrorDomainClass ValaErrorDomainClass;

#define VALA_TYPE_ERROR_CODE (vala_error_code_get_type ())
#define VALA_ERROR_CODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ERROR_CODE, ValaErrorCode))
#define VALA_ERROR_CODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ERROR_CODE, ValaErrorCodeClass))
#define VALA_IS_ERROR_CODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ERROR_CODE))
#define VALA_IS_ERROR_CODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ERROR_CODE))
#define VALA_ERROR_CODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ERROR_CODE, ValaErrorCodeClass))

typedef struct _ValaErrorCode ValaErrorCode;
typedef struct _ValaErrorCodeClass ValaErrorCodeClass;

#define VALA_TYPE_DELEGATE (vala_delegate_get_type ())
#define VALA_DELEGATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DELEGATE, ValaDelegate))
#define VALA_DELEGATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DELEGATE, ValaDelegateClass))
#define VALA_IS_DELEGATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DELEGATE))
#define VALA_IS_DELEGATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DELEGATE))
#define VALA_DELEGATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DELEGATE, ValaDelegateClass))

typedef struct _ValaDelegate ValaDelegate;
typedef struct _ValaDelegateClass ValaDelegateClass;

#define VALA_TYPE_VARIABLE (vala_variable_get_type ())
#define VALA_VARIABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_VARIABLE, ValaVariable))
#define VALA_VARIABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_VARIABLE, ValaVariableClass))
#define VALA_IS_VARIABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_VARIABLE))
#define VALA_IS_VARIABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_VARIABLE))
#define VALA_VARIABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_VARIABLE, ValaVariableClass))

typedef struct _ValaVariable ValaVariable;
typedef struct _ValaVariableClass ValaVariableClass;

#define VALA_TYPE_FIELD (vala_field_get_type ())
#define VALA_FIELD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_FIELD, ValaField))
#define VALA_FIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_FIELD, ValaFieldClass))
#define VALA_IS_FIELD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_FIELD))
#define VALA_IS_FIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_FIELD))
#define VALA_FIELD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_FIELD, ValaFieldClass))

typedef struct _ValaField ValaField;
typedef struct _ValaFieldClass ValaFieldClass;

#define VALA_TYPE_METHOD (vala_method_get_type ())
#define VALA_METHOD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_METHOD, ValaMethod))
#define VALA_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_METHOD, ValaMethodClass))
#define VALA_IS_METHOD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_METHOD))
#define VALA_IS_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_METHOD))
#define VALA_METHOD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_METHOD, ValaMethodClass))

typedef struct _ValaMethod ValaMethod;
typedef struct _ValaMethodClass ValaMethodClass;

#define VALA_TYPE_CREATION_METHOD (vala_creation_method_get_type ())
#define VALA_CREATION_METHOD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CREATION_METHOD, ValaCreationMethod))
#define VALA_CREATION_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CREATION_METHOD, ValaCreationMethodClass))
#define VALA_IS_CREATION_METHOD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CREATION_METHOD))
#define VALA_IS_CREATION_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CREATION_METHOD))
#define VALA_CREATION_METHOD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CREATION_METHOD, ValaCreationMethodClass))

typedef struct _ValaCreationMethod ValaCreationMethod;
typedef struct _ValaCreationMethodClass ValaCreationMethodClass;

#define VALA_TYPE_FORMAL_PARAMETER (vala_formal_parameter_get_type ())
#define VALA_FORMAL_PARAMETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_FORMAL_PARAMETER, ValaFormalParameter))
#define VALA_FORMAL_PARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_FORMAL_PARAMETER, ValaFormalParameterClass))
#define VALA_IS_FORMAL_PARAMETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_FORMAL_PARAMETER))
#define VALA_IS_FORMAL_PARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_FORMAL_PARAMETER))
#define VALA_FORMAL_PARAMETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_FORMAL_PARAMETER, ValaFormalParameterClass))

typedef struct _ValaFormalParameter ValaFormalParameter;
typedef struct _ValaFormalParameterClass ValaFormalParameterClass;

#define VALA_TYPE_PROPERTY (vala_property_get_type ())
#define VALA_PROPERTY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_PROPERTY, ValaProperty))
#define VALA_PROPERTY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_PROPERTY, ValaPropertyClass))
#define VALA_IS_PROPERTY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_PROPERTY))
#define VALA_IS_PROPERTY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_PROPERTY))
#define VALA_PROPERTY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_PROPERTY, ValaPropertyClass))

typedef struct _ValaProperty ValaProperty;
typedef struct _ValaPropertyClass ValaPropertyClass;

#define VALA_TYPE_PROPERTY_ACCESSOR (vala_property_accessor_get_type ())
#define VALA_PROPERTY_ACCESSOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_PROPERTY_ACCESSOR, ValaPropertyAccessor))
#define VALA_PROPERTY_ACCESSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_PROPERTY_ACCESSOR, ValaPropertyAccessorClass))
#define VALA_IS_PROPERTY_ACCESSOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_PROPERTY_ACCESSOR))
#define VALA_IS_PROPERTY_ACCESSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_PROPERTY_ACCESSOR))
#define VALA_PROPERTY_ACCESSOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_PROPERTY_ACCESSOR, ValaPropertyAccessorClass))

typedef struct _ValaPropertyAccessor ValaPropertyAccessor;
typedef struct _ValaPropertyAccessorClass ValaPropertyAccessorClass;

#define VALA_TYPE_SIGNAL (vala_signal_get_type ())
#define VALA_SIGNAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SIGNAL, ValaSignal))
#define VALA_SIGNAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SIGNAL, ValaSignalClass))
#define VALA_IS_SIGNAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SIGNAL))
#define VALA_IS_SIGNAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SIGNAL))
#define VALA_SIGNAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SIGNAL, ValaSignalClass))

typedef struct _ValaSignal ValaSignal;
typedef struct _ValaSignalClass ValaSignalClass;

#define VALA_TYPE_CONSTRUCTOR (vala_constructor_get_type ())
#define VALA_CONSTRUCTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CONSTRUCTOR, ValaConstructor))
#define VALA_CONSTRUCTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CONSTRUCTOR, ValaConstructorClass))
#define VALA_IS_CONSTRUCTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CONSTRUCTOR))
#define VALA_IS_CONSTRUCTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CONSTRUCTOR))
#define VALA_CONSTRUCTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CONSTRUCTOR, ValaConstructorClass))

typedef struct _ValaConstructor ValaConstructor;
typedef struct _ValaConstructorClass ValaConstructorClass;

#define VALA_TYPE_DESTRUCTOR (vala_destructor_get_type ())
#define VALA_DESTRUCTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DESTRUCTOR, ValaDestructor))
#define VALA_DESTRUCTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DESTRUCTOR, ValaDestructorClass))
#define VALA_IS_DESTRUCTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DESTRUCTOR))
#define VALA_IS_DESTRUCTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DESTRUCTOR))
#define VALA_DESTRUCTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DESTRUCTOR, ValaDestructorClass))

typedef struct _ValaDestructor ValaDestructor;
typedef struct _ValaDestructorClass ValaDestructorClass;

#define VALA_TYPE_TYPEPARAMETER (vala_typeparameter_get_type ())
#define VALA_TYPEPARAMETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPEPARAMETER, ValaTypeParameter))
#define VALA_TYPEPARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPEPARAMETER, ValaTypeParameterClass))
#define VALA_IS_TYPEPARAMETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPEPARAMETER))
#define VALA_IS_TYPEPARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPEPARAMETER))
#define VALA_TYPEPARAMETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPEPARAMETER, ValaTypeParameterClass))

typedef struct _ValaTypeParameter ValaTypeParameter;
typedef struct _ValaTypeParameterClass ValaTypeParameterClass;

#define VALA_TYPE_USING_DIRECTIVE (vala_using_directive_get_type ())
#define VALA_USING_DIRECTIVE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_USING_DIRECTIVE, ValaUsingDirective))
#define VALA_USING_DIRECTIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_USING_DIRECTIVE, ValaUsingDirectiveClass))
#define VALA_IS_USING_DIRECTIVE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_USING_DIRECTIVE))
#define VALA_IS_USING_DIRECTIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_USING_DIRECTIVE))
#define VALA_USING_DIRECTIVE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_USING_DIRECTIVE, ValaUsingDirectiveClass))

typedef struct _ValaUsingDirective ValaUsingDirective;
typedef struct _ValaUsingDirectiveClass ValaUsingDirectiveClass;

#define VALA_TYPE_DATA_TYPE (vala_data_type_get_type ())
#define VALA_DATA_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DATA_TYPE, ValaDataType))
#define VALA_DATA_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DATA_TYPE, ValaDataTypeClass))
#define VALA_IS_DATA_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DATA_TYPE))
#define VALA_IS_DATA_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DATA_TYPE))
#define VALA_DATA_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DATA_TYPE, ValaDataTypeClass))

typedef struct _ValaDataType ValaDataType;
typedef struct _ValaDataTypeClass ValaDataTypeClass;

#define VALA_TYPE_BLOCK (vala_block_get_type ())
#define VALA_BLOCK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BLOCK, ValaBlock))
#define VALA_BLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BLOCK, ValaBlockClass))
#define VALA_IS_BLOCK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BLOCK))
#define VALA_IS_BLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BLOCK))
#define VALA_BLOCK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BLOCK, ValaBlockClass))

typedef struct _ValaBlock ValaBlock;
typedef struct _ValaBlockClass ValaBlockClass;

#define VALA_TYPE_EMPTY_STATEMENT (vala_empty_statement_get_type ())
#define VALA_EMPTY_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_EMPTY_STATEMENT, ValaEmptyStatement))
#define VALA_EMPTY_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_EMPTY_STATEMENT, ValaEmptyStatementClass))
#define VALA_IS_EMPTY_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_EMPTY_STATEMENT))
#define VALA_IS_EMPTY_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_EMPTY_STATEMENT))
#define VALA_EMPTY_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_EMPTY_STATEMENT, ValaEmptyStatementClass))

typedef struct _ValaEmptyStatement ValaEmptyStatement;
typedef struct _ValaEmptyStatementClass ValaEmptyStatementClass;

#define VALA_TYPE_DECLARATION_STATEMENT (vala_declaration_statement_get_type ())
#define VALA_DECLARATION_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DECLARATION_STATEMENT, ValaDeclarationStatement))
#define VALA_DECLARATION_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DECLARATION_STATEMENT, ValaDeclarationStatementClass))
#define VALA_IS_DECLARATION_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DECLARATION_STATEMENT))
#define VALA_IS_DECLARATION_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DECLARATION_STATEMENT))
#define VALA_DECLARATION_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DECLARATION_STATEMENT, ValaDeclarationStatementClass))

typedef struct _ValaDeclarationStatement ValaDeclarationStatement;
typedef struct _ValaDeclarationStatementClass ValaDeclarationStatementClass;

#define VALA_TYPE_LOCAL_VARIABLE (vala_local_variable_get_type ())
#define VALA_LOCAL_VARIABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LOCAL_VARIABLE, ValaLocalVariable))
#define VALA_LOCAL_VARIABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LOCAL_VARIABLE, ValaLocalVariableClass))
#define VALA_IS_LOCAL_VARIABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LOCAL_VARIABLE))
#define VALA_IS_LOCAL_VARIABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LOCAL_VARIABLE))
#define VALA_LOCAL_VARIABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LOCAL_VARIABLE, ValaLocalVariableClass))

typedef struct _ValaLocalVariable ValaLocalVariable;
typedef struct _ValaLocalVariableClass ValaLocalVariableClass;

#define VALA_TYPE_EXPRESSION (vala_expression_get_type ())
#define VALA_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_EXPRESSION, ValaExpression))
#define VALA_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_EXPRESSION, ValaExpressionClass))
#define VALA_IS_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_EXPRESSION))
#define VALA_IS_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_EXPRESSION))
#define VALA_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_EXPRESSION, ValaExpressionClass))

typedef struct _ValaExpression ValaExpression;
typedef struct _ValaExpressionClass ValaExpressionClass;

#define VALA_TYPE_INITIALIZER_LIST (vala_initializer_list_get_type ())
#define VALA_INITIALIZER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_INITIALIZER_LIST, ValaInitializerList))
#define VALA_INITIALIZER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_INITIALIZER_LIST, ValaInitializerListClass))
#define VALA_IS_INITIALIZER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_INITIALIZER_LIST))
#define VALA_IS_INITIALIZER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_INITIALIZER_LIST))
#define VALA_INITIALIZER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_INITIALIZER_LIST, ValaInitializerListClass))

typedef struct _ValaInitializerList ValaInitializerList;
typedef struct _ValaInitializerListClass ValaInitializerListClass;

#define VALA_TYPE_EXPRESSION_STATEMENT (vala_expression_statement_get_type ())
#define VALA_EXPRESSION_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_EXPRESSION_STATEMENT, ValaExpressionStatement))
#define VALA_EXPRESSION_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_EXPRESSION_STATEMENT, ValaExpressionStatementClass))
#define VALA_IS_EXPRESSION_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_EXPRESSION_STATEMENT))
#define VALA_IS_EXPRESSION_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_EXPRESSION_STATEMENT))
#define VALA_EXPRESSION_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_EXPRESSION_STATEMENT, ValaExpressionStatementClass))

typedef struct _ValaExpressionStatement ValaExpressionStatement;
typedef struct _ValaExpressionStatementClass ValaExpressionStatementClass;

#define VALA_TYPE_IF_STATEMENT (vala_if_statement_get_type ())
#define VALA_IF_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_IF_STATEMENT, ValaIfStatement))
#define VALA_IF_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_IF_STATEMENT, ValaIfStatementClass))
#define VALA_IS_IF_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_IF_STATEMENT))
#define VALA_IS_IF_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_IF_STATEMENT))
#define VALA_IF_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_IF_STATEMENT, ValaIfStatementClass))

typedef struct _ValaIfStatement ValaIfStatement;
typedef struct _ValaIfStatementClass ValaIfStatementClass;

#define VALA_TYPE_SWITCH_STATEMENT (vala_switch_statement_get_type ())
#define VALA_SWITCH_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SWITCH_STATEMENT, ValaSwitchStatement))
#define VALA_SWITCH_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SWITCH_STATEMENT, ValaSwitchStatementClass))
#define VALA_IS_SWITCH_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SWITCH_STATEMENT))
#define VALA_IS_SWITCH_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SWITCH_STATEMENT))
#define VALA_SWITCH_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SWITCH_STATEMENT, ValaSwitchStatementClass))

typedef struct _ValaSwitchStatement ValaSwitchStatement;
typedef struct _ValaSwitchStatementClass ValaSwitchStatementClass;

#define VALA_TYPE_SWITCH_SECTION (vala_switch_section_get_type ())
#define VALA_SWITCH_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SWITCH_SECTION, ValaSwitchSection))
#define VALA_SWITCH_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SWITCH_SECTION, ValaSwitchSectionClass))
#define VALA_IS_SWITCH_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SWITCH_SECTION))
#define VALA_IS_SWITCH_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SWITCH_SECTION))
#define VALA_SWITCH_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SWITCH_SECTION, ValaSwitchSectionClass))

typedef struct _ValaSwitchSection ValaSwitchSection;
typedef struct _ValaSwitchSectionClass ValaSwitchSectionClass;

#define VALA_TYPE_SWITCH_LABEL (vala_switch_label_get_type ())
#define VALA_SWITCH_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SWITCH_LABEL, ValaSwitchLabel))
#define VALA_SWITCH_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SWITCH_LABEL, ValaSwitchLabelClass))
#define VALA_IS_SWITCH_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SWITCH_LABEL))
#define VALA_IS_SWITCH_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SWITCH_LABEL))
#define VALA_SWITCH_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SWITCH_LABEL, ValaSwitchLabelClass))

typedef struct _ValaSwitchLabel ValaSwitchLabel;
typedef struct _ValaSwitchLabelClass ValaSwitchLabelClass;

#define VALA_TYPE_LOOP (vala_loop_get_type ())
#define VALA_LOOP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LOOP, ValaLoop))
#define VALA_LOOP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LOOP, ValaLoopClass))
#define VALA_IS_LOOP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LOOP))
#define VALA_IS_LOOP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LOOP))
#define VALA_LOOP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LOOP, ValaLoopClass))

typedef struct _ValaLoop ValaLoop;
typedef struct _ValaLoopClass ValaLoopClass;

#define VALA_TYPE_WHILE_STATEMENT (vala_while_statement_get_type ())
#define VALA_WHILE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_WHILE_STATEMENT, ValaWhileStatement))
#define VALA_WHILE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_WHILE_STATEMENT, ValaWhileStatementClass))
#define VALA_IS_WHILE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_WHILE_STATEMENT))
#define VALA_IS_WHILE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_WHILE_STATEMENT))
#define VALA_WHILE_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_WHILE_STATEMENT, ValaWhileStatementClass))

typedef struct _ValaWhileStatement ValaWhileStatement;
typedef struct _ValaWhileStatementClass ValaWhileStatementClass;

#define VALA_TYPE_DO_STATEMENT (vala_do_statement_get_type ())
#define VALA_DO_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DO_STATEMENT, ValaDoStatement))
#define VALA_DO_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DO_STATEMENT, ValaDoStatementClass))
#define VALA_IS_DO_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DO_STATEMENT))
#define VALA_IS_DO_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DO_STATEMENT))
#define VALA_DO_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DO_STATEMENT, ValaDoStatementClass))

typedef struct _ValaDoStatement ValaDoStatement;
typedef struct _ValaDoStatementClass ValaDoStatementClass;

#define VALA_TYPE_FOR_STATEMENT (vala_for_statement_get_type ())
#define VALA_FOR_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_FOR_STATEMENT, ValaForStatement))
#define VALA_FOR_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_FOR_STATEMENT, ValaForStatementClass))
#define VALA_IS_FOR_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_FOR_STATEMENT))
#define VALA_IS_FOR_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_FOR_STATEMENT))
#define VALA_FOR_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_FOR_STATEMENT, ValaForStatementClass))

typedef struct _ValaForStatement ValaForStatement;
typedef struct _ValaForStatementClass ValaForStatementClass;

#define VALA_TYPE_FOREACH_STATEMENT (vala_foreach_statement_get_type ())
#define VALA_FOREACH_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_FOREACH_STATEMENT, ValaForeachStatement))
#define VALA_FOREACH_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_FOREACH_STATEMENT, ValaForeachStatementClass))
#define VALA_IS_FOREACH_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_FOREACH_STATEMENT))
#define VALA_IS_FOREACH_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_FOREACH_STATEMENT))
#define VALA_FOREACH_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_FOREACH_STATEMENT, ValaForeachStatementClass))

typedef struct _ValaForeachStatement ValaForeachStatement;
typedef struct _ValaForeachStatementClass ValaForeachStatementClass;

#define VALA_TYPE_BREAK_STATEMENT (vala_break_statement_get_type ())
#define VALA_BREAK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BREAK_STATEMENT, ValaBreakStatement))
#define VALA_BREAK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BREAK_STATEMENT, ValaBreakStatementClass))
#define VALA_IS_BREAK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BREAK_STATEMENT))
#define VALA_IS_BREAK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BREAK_STATEMENT))
#define VALA_BREAK_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BREAK_STATEMENT, ValaBreakStatementClass))

typedef struct _ValaBreakStatement ValaBreakStatement;
typedef struct _ValaBreakStatementClass ValaBreakStatementClass;

#define VALA_TYPE_CONTINUE_STATEMENT (vala_continue_statement_get_type ())
#define VALA_CONTINUE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CONTINUE_STATEMENT, ValaContinueStatement))
#define VALA_CONTINUE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CONTINUE_STATEMENT, ValaContinueStatementClass))
#define VALA_IS_CONTINUE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CONTINUE_STATEMENT))
#define VALA_IS_CONTINUE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CONTINUE_STATEMENT))
#define VALA_CONTINUE_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CONTINUE_STATEMENT, ValaContinueStatementClass))

typedef struct _ValaContinueStatement ValaContinueStatement;
typedef struct _ValaContinueStatementClass ValaContinueStatementClass;

#define VALA_TYPE_RETURN_STATEMENT (vala_return_statement_get_type ())
#define VALA_RETURN_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_RETURN_STATEMENT, ValaReturnStatement))
#define VALA_RETURN_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_RETURN_STATEMENT, ValaReturnStatementClass))
#define VALA_IS_RETURN_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_RETURN_STATEMENT))
#define VALA_IS_RETURN_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_RETURN_STATEMENT))
#define VALA_RETURN_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_RETURN_STATEMENT, ValaReturnStatementClass))

typedef struct _ValaReturnStatement ValaReturnStatement;
typedef struct _ValaReturnStatementClass ValaReturnStatementClass;

#define VALA_TYPE_YIELD_STATEMENT (vala_yield_statement_get_type ())
#define VALA_YIELD_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_YIELD_STATEMENT, ValaYieldStatement))
#define VALA_YIELD_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_YIELD_STATEMENT, ValaYieldStatementClass))
#define VALA_IS_YIELD_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_YIELD_STATEMENT))
#define VALA_IS_YIELD_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_YIELD_STATEMENT))
#define VALA_YIELD_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_YIELD_STATEMENT, ValaYieldStatementClass))

typedef struct _ValaYieldStatement ValaYieldStatement;
typedef struct _ValaYieldStatementClass ValaYieldStatementClass;

#define VALA_TYPE_THROW_STATEMENT (vala_throw_statement_get_type ())
#define VALA_THROW_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_THROW_STATEMENT, ValaThrowStatement))
#define VALA_THROW_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_THROW_STATEMENT, ValaThrowStatementClass))
#define VALA_IS_THROW_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_THROW_STATEMENT))
#define VALA_IS_THROW_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_THROW_STATEMENT))
#define VALA_THROW_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_THROW_STATEMENT, ValaThrowStatementClass))

typedef struct _ValaThrowStatement ValaThrowStatement;
typedef struct _ValaThrowStatementClass ValaThrowStatementClass;

#define VALA_TYPE_TRY_STATEMENT (vala_try_statement_get_type ())
#define VALA_TRY_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TRY_STATEMENT, ValaTryStatement))
#define VALA_TRY_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TRY_STATEMENT, ValaTryStatementClass))
#define VALA_IS_TRY_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TRY_STATEMENT))
#define VALA_IS_TRY_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TRY_STATEMENT))
#define VALA_TRY_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TRY_STATEMENT, ValaTryStatementClass))

typedef struct _ValaTryStatement ValaTryStatement;
typedef struct _ValaTryStatementClass ValaTryStatementClass;

#define VALA_TYPE_CATCH_CLAUSE (vala_catch_clause_get_type ())
#define VALA_CATCH_CLAUSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CATCH_CLAUSE, ValaCatchClause))
#define VALA_CATCH_CLAUSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CATCH_CLAUSE, ValaCatchClauseClass))
#define VALA_IS_CATCH_CLAUSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CATCH_CLAUSE))
#define VALA_IS_CATCH_CLAUSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CATCH_CLAUSE))
#define VALA_CATCH_CLAUSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CATCH_CLAUSE, ValaCatchClauseClass))

typedef struct _ValaCatchClause ValaCatchClause;
typedef struct _ValaCatchClauseClass ValaCatchClauseClass;

#define VALA_TYPE_LOCK_STATEMENT (vala_lock_statement_get_type ())
#define VALA_LOCK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LOCK_STATEMENT, ValaLockStatement))
#define VALA_LOCK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LOCK_STATEMENT, ValaLockStatementClass))
#define VALA_IS_LOCK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LOCK_STATEMENT))
#define VALA_IS_LOCK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LOCK_STATEMENT))
#define VALA_LOCK_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LOCK_STATEMENT, ValaLockStatementClass))

typedef struct _ValaLockStatement ValaLockStatement;
typedef struct _ValaLockStatementClass ValaLockStatementClass;

#define VALA_TYPE_UNLOCK_STATEMENT (vala_unlock_statement_get_type ())
#define VALA_UNLOCK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_UNLOCK_STATEMENT, ValaUnlockStatement))
#define VALA_UNLOCK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_UNLOCK_STATEMENT, ValaUnlockStatementClass))
#define VALA_IS_UNLOCK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_UNLOCK_STATEMENT))
#define VALA_IS_UNLOCK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_UNLOCK_STATEMENT))
#define VALA_UNLOCK_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_UNLOCK_STATEMENT, ValaUnlockStatementClass))

typedef struct _ValaUnlockStatement ValaUnlockStatement;
typedef struct _ValaUnlockStatementClass ValaUnlockStatementClass;

#define VALA_TYPE_DELETE_STATEMENT (vala_delete_statement_get_type ())
#define VALA_DELETE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DELETE_STATEMENT, ValaDeleteStatement))
#define VALA_DELETE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DELETE_STATEMENT, ValaDeleteStatementClass))
#define VALA_IS_DELETE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DELETE_STATEMENT))
#define VALA_IS_DELETE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DELETE_STATEMENT))
#define VALA_DELETE_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DELETE_STATEMENT, ValaDeleteStatementClass))

typedef struct _ValaDeleteStatement ValaDeleteStatement;
typedef struct _ValaDeleteStatementClass ValaDeleteStatementClass;

#define VALA_TYPE_ARRAY_CREATION_EXPRESSION (vala_array_creation_expression_get_type ())
#define VALA_ARRAY_CREATION_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ARRAY_CREATION_EXPRESSION, ValaArrayCreationExpression))
#define VALA_ARRAY_CREATION_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ARRAY_CREATION_EXPRESSION, ValaArrayCreationExpressionClass))
#define VALA_IS_ARRAY_CREATION_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ARRAY_CREATION_EXPRESSION))
#define VALA_IS_ARRAY_CREATION_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ARRAY_CREATION_EXPRESSION))
#define VALA_ARRAY_CREATION_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ARRAY_CREATION_EXPRESSION, ValaArrayCreationExpressionClass))

typedef struct _ValaArrayCreationExpression ValaArrayCreationExpression;
typedef struct _ValaArrayCreationExpressionClass ValaArrayCreationExpressionClass;

#define VALA_TYPE_LITERAL (vala_literal_get_type ())
#define VALA_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LITERAL, ValaLiteral))
#define VALA_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LITERAL, ValaLiteralClass))
#define VALA_IS_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LITERAL))
#define VALA_IS_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LITERAL))
#define VALA_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LITERAL, ValaLiteralClass))

typedef struct _ValaLiteral ValaLiteral;
typedef struct _ValaLiteralClass ValaLiteralClass;

#define VALA_TYPE_BOOLEAN_LITERAL (vala_boolean_literal_get_type ())
#define VALA_BOOLEAN_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BOOLEAN_LITERAL, ValaBooleanLiteral))
#define VALA_BOOLEAN_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BOOLEAN_LITERAL, ValaBooleanLiteralClass))
#define VALA_IS_BOOLEAN_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BOOLEAN_LITERAL))
#define VALA_IS_BOOLEAN_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BOOLEAN_LITERAL))
#define VALA_BOOLEAN_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BOOLEAN_LITERAL, ValaBooleanLiteralClass))

typedef struct _ValaBooleanLiteral ValaBooleanLiteral;
typedef struct _ValaBooleanLiteralClass ValaBooleanLiteralClass;

#define VALA_TYPE_CHARACTER_LITERAL (vala_character_literal_get_type ())
#define VALA_CHARACTER_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CHARACTER_LITERAL, ValaCharacterLiteral))
#define VALA_CHARACTER_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CHARACTER_LITERAL, ValaCharacterLiteralClass))
#define VALA_IS_CHARACTER_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CHARACTER_LITERAL))
#define VALA_IS_CHARACTER_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CHARACTER_LITERAL))
#define VALA_CHARACTER_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CHARACTER_LITERAL, ValaCharacterLiteralClass))

typedef struct _ValaCharacterLiteral ValaCharacterLiteral;
typedef struct _ValaCharacterLiteralClass ValaCharacterLiteralClass;

#define VALA_TYPE_INTEGER_LITERAL (vala_integer_literal_get_type ())
#define VALA_INTEGER_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_INTEGER_LITERAL, ValaIntegerLiteral))
#define VALA_INTEGER_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_INTEGER_LITERAL, ValaIntegerLiteralClass))
#define VALA_IS_INTEGER_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_INTEGER_LITERAL))
#define VALA_IS_INTEGER_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_INTEGER_LITERAL))
#define VALA_INTEGER_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_INTEGER_LITERAL, ValaIntegerLiteralClass))

typedef struct _ValaIntegerLiteral ValaIntegerLiteral;
typedef struct _ValaIntegerLiteralClass ValaIntegerLiteralClass;

#define VALA_TYPE_REAL_LITERAL (vala_real_literal_get_type ())
#define VALA_REAL_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REAL_LITERAL, ValaRealLiteral))
#define VALA_REAL_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REAL_LITERAL, ValaRealLiteralClass))
#define VALA_IS_REAL_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REAL_LITERAL))
#define VALA_IS_REAL_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REAL_LITERAL))
#define VALA_REAL_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REAL_LITERAL, ValaRealLiteralClass))

typedef struct _ValaRealLiteral ValaRealLiteral;
typedef struct _ValaRealLiteralClass ValaRealLiteralClass;

#define VALA_TYPE_REGEX_LITERAL (vala_regex_literal_get_type ())
#define VALA_REGEX_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REGEX_LITERAL, ValaRegexLiteral))
#define VALA_REGEX_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REGEX_LITERAL, ValaRegexLiteralClass))
#define VALA_IS_REGEX_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REGEX_LITERAL))
#define VALA_IS_REGEX_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REGEX_LITERAL))
#define VALA_REGEX_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REGEX_LITERAL, ValaRegexLiteralClass))

typedef struct _ValaRegexLiteral ValaRegexLiteral;
typedef struct _ValaRegexLiteralClass ValaRegexLiteralClass;

#define VALA_TYPE_STRING_LITERAL (vala_string_literal_get_type ())
#define VALA_STRING_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_STRING_LITERAL, ValaStringLiteral))
#define VALA_STRING_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_STRING_LITERAL, ValaStringLiteralClass))
#define VALA_IS_STRING_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_STRING_LITERAL))
#define VALA_IS_STRING_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_STRING_LITERAL))
#define VALA_STRING_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_STRING_LITERAL, ValaStringLiteralClass))

typedef struct _ValaStringLiteral ValaStringLiteral;
typedef struct _ValaStringLiteralClass ValaStringLiteralClass;

#define VALA_TYPE_TEMPLATE (vala_template_get_type ())
#define VALA_TEMPLATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TEMPLATE, ValaTemplate))
#define VALA_TEMPLATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TEMPLATE, ValaTemplateClass))
#define VALA_IS_TEMPLATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TEMPLATE))
#define VALA_IS_TEMPLATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TEMPLATE))
#define VALA_TEMPLATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TEMPLATE, ValaTemplateClass))

typedef struct _ValaTemplate ValaTemplate;
typedef struct _ValaTemplateClass ValaTemplateClass;

#define VALA_TYPE_LIST_LITERAL (vala_list_literal_get_type ())
#define VALA_LIST_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LIST_LITERAL, ValaListLiteral))
#define VALA_LIST_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LIST_LITERAL, ValaListLiteralClass))
#define VALA_IS_LIST_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LIST_LITERAL))
#define VALA_IS_LIST_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LIST_LITERAL))
#define VALA_LIST_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LIST_LITERAL, ValaListLiteralClass))

typedef struct _ValaListLiteral ValaListLiteral;
typedef struct _ValaListLiteralClass ValaListLiteralClass;

#define VALA_TYPE_SET_LITERAL (vala_set_literal_get_type ())
#define VALA_SET_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SET_LITERAL, ValaSetLiteral))
#define VALA_SET_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SET_LITERAL, ValaSetLiteralClass))
#define VALA_IS_SET_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SET_LITERAL))
#define VALA_IS_SET_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SET_LITERAL))
#define VALA_SET_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SET_LITERAL, ValaSetLiteralClass))

typedef struct _ValaSetLiteral ValaSetLiteral;
typedef struct _ValaSetLiteralClass ValaSetLiteralClass;

#define VALA_TYPE_MAP_LITERAL (vala_map_literal_get_type ())
#define VALA_MAP_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_MAP_LITERAL, ValaMapLiteral))
#define VALA_MAP_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_MAP_LITERAL, ValaMapLiteralClass))
#define VALA_IS_MAP_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_MAP_LITERAL))
#define VALA_IS_MAP_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_MAP_LITERAL))
#define VALA_MAP_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_MAP_LITERAL, ValaMapLiteralClass))

typedef struct _ValaMapLiteral ValaMapLiteral;
typedef struct _ValaMapLiteralClass ValaMapLiteralClass;

#define VALA_TYPE_TUPLE (vala_tuple_get_type ())
#define VALA_TUPLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TUPLE, ValaTuple))
#define VALA_TUPLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TUPLE, ValaTupleClass))
#define VALA_IS_TUPLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TUPLE))
#define VALA_IS_TUPLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TUPLE))
#define VALA_TUPLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TUPLE, ValaTupleClass))

typedef struct _ValaTuple ValaTuple;
typedef struct _ValaTupleClass ValaTupleClass;

#define VALA_TYPE_NULL_LITERAL (vala_null_literal_get_type ())
#define VALA_NULL_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_NULL_LITERAL, ValaNullLiteral))
#define VALA_NULL_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_NULL_LITERAL, ValaNullLiteralClass))
#define VALA_IS_NULL_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_NULL_LITERAL))
#define VALA_IS_NULL_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_NULL_LITERAL))
#define VALA_NULL_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_NULL_LITERAL, ValaNullLiteralClass))

typedef struct _ValaNullLiteral ValaNullLiteral;
typedef struct _ValaNullLiteralClass ValaNullLiteralClass;

#define VALA_TYPE_MEMBER_ACCESS (vala_member_access_get_type ())
#define VALA_MEMBER_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_MEMBER_ACCESS, ValaMemberAccess))
#define VALA_MEMBER_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_MEMBER_ACCESS, ValaMemberAccessClass))
#define VALA_IS_MEMBER_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_MEMBER_ACCESS))
#define VALA_IS_MEMBER_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_MEMBER_ACCESS))
#define VALA_MEMBER_ACCESS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_MEMBER_ACCESS, ValaMemberAccessClass))

typedef struct _ValaMemberAccess ValaMemberAccess;
typedef struct _ValaMemberAccessClass ValaMemberAccessClass;

#define VALA_TYPE_METHOD_CALL (vala_method_call_get_type ())
#define VALA_METHOD_CALL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_METHOD_CALL, ValaMethodCall))
#define VALA_METHOD_CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_METHOD_CALL, ValaMethodCallClass))
#define VALA_IS_METHOD_CALL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_METHOD_CALL))
#define VALA_IS_METHOD_CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_METHOD_CALL))
#define VALA_METHOD_CALL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_METHOD_CALL, ValaMethodCallClass))

typedef struct _ValaMethodCall ValaMethodCall;
typedef struct _ValaMethodCallClass ValaMethodCallClass;

#define VALA_TYPE_ELEMENT_ACCESS (vala_element_access_get_type ())
#define VALA_ELEMENT_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ELEMENT_ACCESS, ValaElementAccess))
#define VALA_ELEMENT_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ELEMENT_ACCESS, ValaElementAccessClass))
#define VALA_IS_ELEMENT_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ELEMENT_ACCESS))
#define VALA_IS_ELEMENT_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ELEMENT_ACCESS))
#define VALA_ELEMENT_ACCESS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ELEMENT_ACCESS, ValaElementAccessClass))

typedef struct _ValaElementAccess ValaElementAccess;
typedef struct _ValaElementAccessClass ValaElementAccessClass;

#define VALA_TYPE_SLICE_EXPRESSION (vala_slice_expression_get_type ())
#define VALA_SLICE_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SLICE_EXPRESSION, ValaSliceExpression))
#define VALA_SLICE_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SLICE_EXPRESSION, ValaSliceExpressionClass))
#define VALA_IS_SLICE_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SLICE_EXPRESSION))
#define VALA_IS_SLICE_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SLICE_EXPRESSION))
#define VALA_SLICE_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SLICE_EXPRESSION, ValaSliceExpressionClass))

typedef struct _ValaSliceExpression ValaSliceExpression;
typedef struct _ValaSliceExpressionClass ValaSliceExpressionClass;

#define VALA_TYPE_BASE_ACCESS (vala_base_access_get_type ())
#define VALA_BASE_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BASE_ACCESS, ValaBaseAccess))
#define VALA_BASE_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BASE_ACCESS, ValaBaseAccessClass))
#define VALA_IS_BASE_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BASE_ACCESS))
#define VALA_IS_BASE_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BASE_ACCESS))
#define VALA_BASE_ACCESS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BASE_ACCESS, ValaBaseAccessClass))

typedef struct _ValaBaseAccess ValaBaseAccess;
typedef struct _ValaBaseAccessClass ValaBaseAccessClass;

#define VALA_TYPE_POSTFIX_EXPRESSION (vala_postfix_expression_get_type ())
#define VALA_POSTFIX_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_POSTFIX_EXPRESSION, ValaPostfixExpression))
#define VALA_POSTFIX_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_POSTFIX_EXPRESSION, ValaPostfixExpressionClass))
#define VALA_IS_POSTFIX_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_POSTFIX_EXPRESSION))
#define VALA_IS_POSTFIX_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_POSTFIX_EXPRESSION))
#define VALA_POSTFIX_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_POSTFIX_EXPRESSION, ValaPostfixExpressionClass))

typedef struct _ValaPostfixExpression ValaPostfixExpression;
typedef struct _ValaPostfixExpressionClass ValaPostfixExpressionClass;

#define VALA_TYPE_OBJECT_CREATION_EXPRESSION (vala_object_creation_expression_get_type ())
#define VALA_OBJECT_CREATION_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_OBJECT_CREATION_EXPRESSION, ValaObjectCreationExpression))
#define VALA_OBJECT_CREATION_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_OBJECT_CREATION_EXPRESSION, ValaObjectCreationExpressionClass))
#define VALA_IS_OBJECT_CREATION_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_OBJECT_CREATION_EXPRESSION))
#define VALA_IS_OBJECT_CREATION_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_OBJECT_CREATION_EXPRESSION))
#define VALA_OBJECT_CREATION_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_OBJECT_CREATION_EXPRESSION, ValaObjectCreationExpressionClass))

typedef struct _ValaObjectCreationExpression ValaObjectCreationExpression;
typedef struct _ValaObjectCreationExpressionClass ValaObjectCreationExpressionClass;

#define VALA_TYPE_SIZEOF_EXPRESSION (vala_sizeof_expression_get_type ())
#define VALA_SIZEOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SIZEOF_EXPRESSION, ValaSizeofExpression))
#define VALA_SIZEOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SIZEOF_EXPRESSION, ValaSizeofExpressionClass))
#define VALA_IS_SIZEOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SIZEOF_EXPRESSION))
#define VALA_IS_SIZEOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SIZEOF_EXPRESSION))
#define VALA_SIZEOF_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SIZEOF_EXPRESSION, ValaSizeofExpressionClass))

typedef struct _ValaSizeofExpression ValaSizeofExpression;
typedef struct _ValaSizeofExpressionClass ValaSizeofExpressionClass;

#define VALA_TYPE_TYPEOF_EXPRESSION (vala_typeof_expression_get_type ())
#define VALA_TYPEOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPEOF_EXPRESSION, ValaTypeofExpression))
#define VALA_TYPEOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPEOF_EXPRESSION, ValaTypeofExpressionClass))
#define VALA_IS_TYPEOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPEOF_EXPRESSION))
#define VALA_IS_TYPEOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPEOF_EXPRESSION))
#define VALA_TYPEOF_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPEOF_EXPRESSION, ValaTypeofExpressionClass))

typedef struct _ValaTypeofExpression ValaTypeofExpression;
typedef struct _ValaTypeofExpressionClass ValaTypeofExpressionClass;

#define VALA_TYPE_UNARY_EXPRESSION (vala_unary_expression_get_type ())
#define VALA_UNARY_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_UNARY_EXPRESSION, ValaUnaryExpression))
#define VALA_UNARY_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_UNARY_EXPRESSION, ValaUnaryExpressionClass))
#define VALA_IS_UNARY_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_UNARY_EXPRESSION))
#define VALA_IS_UNARY_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_UNARY_EXPRESSION))
#define VALA_UNARY_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_UNARY_EXPRESSION, ValaUnaryExpressionClass))

typedef struct _ValaUnaryExpression ValaUnaryExpression;
typedef struct _ValaUnaryExpressionClass ValaUnaryExpressionClass;

#define VALA_TYPE_CAST_EXPRESSION (vala_cast_expression_get_type ())
#define VALA_CAST_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CAST_EXPRESSION, ValaCastExpression))
#define VALA_CAST_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CAST_EXPRESSION, ValaCastExpressionClass))
#define VALA_IS_CAST_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CAST_EXPRESSION))
#define VALA_IS_CAST_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CAST_EXPRESSION))
#define VALA_CAST_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CAST_EXPRESSION, ValaCastExpressionClass))

typedef struct _ValaCastExpression ValaCastExpression;
typedef struct _ValaCastExpressionClass ValaCastExpressionClass;

#define VALA_TYPE_NAMED_ARGUMENT (vala_named_argument_get_type ())
#define VALA_NAMED_ARGUMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_NAMED_ARGUMENT, ValaNamedArgument))
#define VALA_NAMED_ARGUMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_NAMED_ARGUMENT, ValaNamedArgumentClass))
#define VALA_IS_NAMED_ARGUMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_NAMED_ARGUMENT))
#define VALA_IS_NAMED_ARGUMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_NAMED_ARGUMENT))
#define VALA_NAMED_ARGUMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_NAMED_ARGUMENT, ValaNamedArgumentClass))

typedef struct _ValaNamedArgument ValaNamedArgument;
typedef struct _ValaNamedArgumentClass ValaNamedArgumentClass;

#define VALA_TYPE_POINTER_INDIRECTION (vala_pointer_indirection_get_type ())
#define VALA_POINTER_INDIRECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_POINTER_INDIRECTION, ValaPointerIndirection))
#define VALA_POINTER_INDIRECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_POINTER_INDIRECTION, ValaPointerIndirectionClass))
#define VALA_IS_POINTER_INDIRECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_POINTER_INDIRECTION))
#define VALA_IS_POINTER_INDIRECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_POINTER_INDIRECTION))
#define VALA_POINTER_INDIRECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_POINTER_INDIRECTION, ValaPointerIndirectionClass))

typedef struct _ValaPointerIndirection ValaPointerIndirection;
typedef struct _ValaPointerIndirectionClass ValaPointerIndirectionClass;

#define VALA_TYPE_ADDRESSOF_EXPRESSION (vala_addressof_expression_get_type ())
#define VALA_ADDRESSOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ADDRESSOF_EXPRESSION, ValaAddressofExpression))
#define VALA_ADDRESSOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ADDRESSOF_EXPRESSION, ValaAddressofExpressionClass))
#define VALA_IS_ADDRESSOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ADDRESSOF_EXPRESSION))
#define VALA_IS_ADDRESSOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ADDRESSOF_EXPRESSION))
#define VALA_ADDRESSOF_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ADDRESSOF_EXPRESSION, ValaAddressofExpressionClass))

typedef struct _ValaAddressofExpression ValaAddressofExpression;
typedef struct _ValaAddressofExpressionClass ValaAddressofExpressionClass;

#define VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION (vala_reference_transfer_expression_get_type ())
#define VALA_REFERENCE_TRANSFER_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION, ValaReferenceTransferExpression))
#define VALA_REFERENCE_TRANSFER_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION, ValaReferenceTransferExpressionClass))
#define VALA_IS_REFERENCE_TRANSFER_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION))
#define VALA_IS_REFERENCE_TRANSFER_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION))
#define VALA_REFERENCE_TRANSFER_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION, ValaReferenceTransferExpressionClass))

typedef struct _ValaReferenceTransferExpression ValaReferenceTransferExpression;
typedef struct _ValaReferenceTransferExpressionClass ValaReferenceTransferExpressionClass;

#define VALA_TYPE_BINARY_EXPRESSION (vala_binary_expression_get_type ())
#define VALA_BINARY_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BINARY_EXPRESSION, ValaBinaryExpression))
#define VALA_BINARY_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BINARY_EXPRESSION, ValaBinaryExpressionClass))
#define VALA_IS_BINARY_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BINARY_EXPRESSION))
#define VALA_IS_BINARY_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BINARY_EXPRESSION))
#define VALA_BINARY_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BINARY_EXPRESSION, ValaBinaryExpressionClass))

typedef struct _ValaBinaryExpression ValaBinaryExpression;
typedef struct _ValaBinaryExpressionClass ValaBinaryExpressionClass;

#define VALA_TYPE_TYPECHECK (vala_typecheck_get_type ())
#define VALA_TYPECHECK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPECHECK, ValaTypeCheck))
#define VALA_TYPECHECK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPECHECK, ValaTypeCheckClass))
#define VALA_IS_TYPECHECK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPECHECK))
#define VALA_IS_TYPECHECK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPECHECK))
#define VALA_TYPECHECK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPECHECK, ValaTypeCheckClass))

typedef struct _ValaTypeCheck ValaTypeCheck;
typedef struct _ValaTypeCheckClass ValaTypeCheckClass;

#define VALA_TYPE_CONDITIONAL_EXPRESSION (vala_conditional_expression_get_type ())
#define VALA_CONDITIONAL_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CONDITIONAL_EXPRESSION, ValaConditionalExpression))
#define VALA_CONDITIONAL_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CONDITIONAL_EXPRESSION, ValaConditionalExpressionClass))
#define VALA_IS_CONDITIONAL_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CONDITIONAL_EXPRESSION))
#define VALA_IS_CONDITIONAL_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CONDITIONAL_EXPRESSION))
#define VALA_CONDITIONAL_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CONDITIONAL_EXPRESSION, ValaConditionalExpressionClass))

typedef struct _ValaConditionalExpression ValaConditionalExpression;
typedef struct _ValaConditionalExpressionClass ValaConditionalExpressionClass;

#define VALA_TYPE_LAMBDA_EXPRESSION (vala_lambda_expression_get_type ())
#define VALA_LAMBDA_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LAMBDA_EXPRESSION, ValaLambdaExpression))
#define VALA_LAMBDA_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LAMBDA_EXPRESSION, ValaLambdaExpressionClass))
#define VALA_IS_LAMBDA_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LAMBDA_EXPRESSION))
#define VALA_IS_LAMBDA_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LAMBDA_EXPRESSION))
#define VALA_LAMBDA_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LAMBDA_EXPRESSION, ValaLambdaExpressionClass))

typedef struct _ValaLambdaExpression ValaLambdaExpression;
typedef struct _ValaLambdaExpressionClass ValaLambdaExpressionClass;

#define VALA_TYPE_ASSIGNMENT (vala_assignment_get_type ())
#define VALA_ASSIGNMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ASSIGNMENT, ValaAssignment))
#define VALA_ASSIGNMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ASSIGNMENT, ValaAssignmentClass))
#define VALA_IS_ASSIGNMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ASSIGNMENT))
#define VALA_IS_ASSIGNMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ASSIGNMENT))
#define VALA_ASSIGNMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ASSIGNMENT, ValaAssignmentClass))

typedef struct _ValaAssignment ValaAssignment;
typedef struct _ValaAssignmentClass ValaAssignmentClass;

#define VALA_GENIE_TYPE_PARSER (vala_genie_parser_get_type ())
#define VALA_GENIE_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_GENIE_TYPE_PARSER, ValaGenieParser))
#define VALA_GENIE_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_GENIE_TYPE_PARSER, ValaGenieParserClass))
#define VALA_GENIE_IS_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_GENIE_TYPE_PARSER))
#define VALA_GENIE_IS_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_GENIE_TYPE_PARSER))
#define VALA_GENIE_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_GENIE_TYPE_PARSER, ValaGenieParserClass))

typedef struct _ValaGenieParser ValaGenieParser;
typedef struct _ValaGenieParserClass ValaGenieParserClass;
typedef struct _ValaGenieParserPrivate ValaGenieParserPrivate;

#define VALA_GENIE_TYPE_SCANNER (vala_genie_scanner_get_type ())
#define VALA_GENIE_SCANNER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_GENIE_TYPE_SCANNER, ValaGenieScanner))
#define VALA_GENIE_SCANNER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_GENIE_TYPE_SCANNER, ValaGenieScannerClass))
#define VALA_GENIE_IS_SCANNER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_GENIE_TYPE_SCANNER))
#define VALA_GENIE_IS_SCANNER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_GENIE_TYPE_SCANNER))
#define VALA_GENIE_SCANNER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_GENIE_TYPE_SCANNER, ValaGenieScannerClass))

typedef struct _ValaGenieScanner ValaGenieScanner;
typedef struct _ValaGenieScannerClass ValaGenieScannerClass;

#define VALA_TYPE_CODE_CONTEXT (vala_code_context_get_type ())
#define VALA_CODE_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_CONTEXT, ValaCodeContext))
#define VALA_CODE_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_CONTEXT, ValaCodeContextClass))
#define VALA_IS_CODE_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_CONTEXT))
#define VALA_IS_CODE_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_CONTEXT))
#define VALA_CODE_CONTEXT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_CONTEXT, ValaCodeContextClass))

typedef struct _ValaCodeContext ValaCodeContext;
typedef struct _ValaCodeContextClass ValaCodeContextClass;

#define VALA_GENIE_PARSER_TYPE_TOKEN_INFO (vala_genie_parser_token_info_get_type ())

#define VALA_GENIE_TYPE_TOKEN_TYPE (vala_genie_token_type_get_type ())

#define VALA_TYPE_SOURCE_LOCATION (vala_source_location_get_type ())
typedef struct _ValaSourceLocation ValaSourceLocation;
typedef struct _ValaGenieParserTokenInfo ValaGenieParserTokenInfo;

#define VALA_TYPE_COMMENT (vala_comment_get_type ())
#define VALA_COMMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_COMMENT, ValaComment))
#define VALA_COMMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_COMMENT, ValaCommentClass))
#define VALA_IS_COMMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_COMMENT))
#define VALA_IS_COMMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_COMMENT))
#define VALA_COMMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_COMMENT, ValaCommentClass))

typedef struct _ValaComment ValaComment;
typedef struct _ValaCommentClass ValaCommentClass;

#define VALA_GENIE_PARSER_TYPE_MODIFIER_FLAGS (vala_genie_parser_modifier_flags_get_type ())

#define VALA_GENIE_PARSER_TYPE_RECOVERY_STATE (vala_genie_parser_recovery_state_get_type ())
#define _vala_genie_scanner_unref0(var) ((var == NULL) ? NULL : (var = (vala_genie_scanner_unref (var), NULL)))
#define _vala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_context_unref (var), NULL)))
#define _vala_comment_unref0(var) ((var == NULL) ? NULL : (var = (vala_comment_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define VALA_TYPE_SOURCE_REFERENCE (vala_source_reference_get_type ())
#define VALA_SOURCE_REFERENCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SOURCE_REFERENCE, ValaSourceReference))
#define VALA_SOURCE_REFERENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SOURCE_REFERENCE, ValaSourceReferenceClass))
#define VALA_IS_SOURCE_REFERENCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SOURCE_REFERENCE))
#define VALA_IS_SOURCE_REFERENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SOURCE_REFERENCE))
#define VALA_SOURCE_REFERENCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SOURCE_REFERENCE, ValaSourceReferenceClass))

typedef struct _ValaSourceReference ValaSourceReference;
typedef struct _ValaSourceReferenceClass ValaSourceReferenceClass;
#define _vala_source_reference_unref0(var) ((var == NULL) ? NULL : (var = (vala_source_reference_unref (var), NULL)))

#define VALA_TYPE_SYMBOL_ACCESSIBILITY (vala_symbol_accessibility_get_type ())
#define _vala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_node_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define VALA_TYPE_UNRESOLVED_SYMBOL (vala_unresolved_symbol_get_type ())
#define VALA_UNRESOLVED_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_UNRESOLVED_SYMBOL, ValaUnresolvedSymbol))
#define VALA_UNRESOLVED_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_UNRESOLVED_SYMBOL, ValaUnresolvedSymbolClass))
#define VALA_IS_UNRESOLVED_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_UNRESOLVED_SYMBOL))
#define VALA_IS_UNRESOLVED_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_UNRESOLVED_SYMBOL))
#define VALA_UNRESOLVED_SYMBOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_UNRESOLVED_SYMBOL, ValaUnresolvedSymbolClass))

typedef struct _ValaUnresolvedSymbol ValaUnresolvedSymbol;
typedef struct _ValaUnresolvedSymbolClass ValaUnresolvedSymbolClass;

#define VALA_TYPE_VOID_TYPE (vala_void_type_get_type ())
#define VALA_VOID_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_VOID_TYPE, ValaVoidType))
#define VALA_VOID_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_VOID_TYPE, ValaVoidTypeClass))
#define VALA_IS_VOID_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_VOID_TYPE))
#define VALA_IS_VOID_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_VOID_TYPE))
#define VALA_VOID_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_VOID_TYPE, ValaVoidTypeClass))

typedef struct _ValaVoidType ValaVoidType;
typedef struct _ValaVoidTypeClass ValaVoidTypeClass;

#define VALA_TYPE_POINTER_TYPE (vala_pointer_type_get_type ())
#define VALA_POINTER_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_POINTER_TYPE, ValaPointerType))
#define VALA_POINTER_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_POINTER_TYPE, ValaPointerTypeClass))
#define VALA_IS_POINTER_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_POINTER_TYPE))
#define VALA_IS_POINTER_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_POINTER_TYPE))
#define VALA_POINTER_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_POINTER_TYPE, ValaPointerTypeClass))

typedef struct _ValaPointerType ValaPointerType;
typedef struct _ValaPointerTypeClass ValaPointerTypeClass;
#define _vala_collection_object_unref0(var) ((var == NULL) ? NULL : (var = (vala_collection_object_unref (var), NULL)))

#define VALA_TYPE_UNRESOLVED_TYPE (vala_unresolved_type_get_type ())
#define VALA_UNRESOLVED_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_UNRESOLVED_TYPE, ValaUnresolvedType))
#define VALA_UNRESOLVED_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_UNRESOLVED_TYPE, ValaUnresolvedTypeClass))
#define VALA_IS_UNRESOLVED_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_UNRESOLVED_TYPE))
#define VALA_IS_UNRESOLVED_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_UNRESOLVED_TYPE))
#define VALA_UNRESOLVED_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_UNRESOLVED_TYPE, ValaUnresolvedTypeClass))

typedef struct _ValaUnresolvedType ValaUnresolvedType;
typedef struct _ValaUnresolvedTypeClass ValaUnresolvedTypeClass;

#define VALA_TYPE_REFERENCE_TYPE (vala_reference_type_get_type ())
#define VALA_REFERENCE_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REFERENCE_TYPE, ValaReferenceType))
#define VALA_REFERENCE_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REFERENCE_TYPE, ValaReferenceTypeClass))
#define VALA_IS_REFERENCE_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REFERENCE_TYPE))
#define VALA_IS_REFERENCE_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REFERENCE_TYPE))
#define VALA_REFERENCE_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REFERENCE_TYPE, ValaReferenceTypeClass))

typedef struct _ValaReferenceType ValaReferenceType;
typedef struct _ValaReferenceTypeClass ValaReferenceTypeClass;

#define VALA_TYPE_ARRAY_TYPE (vala_array_type_get_type ())
#define VALA_ARRAY_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ARRAY_TYPE, ValaArrayType))
#define VALA_ARRAY_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ARRAY_TYPE, ValaArrayTypeClass))
#define VALA_IS_ARRAY_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ARRAY_TYPE))
#define VALA_IS_ARRAY_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ARRAY_TYPE))
#define VALA_ARRAY_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ARRAY_TYPE, ValaArrayTypeClass))

typedef struct _ValaArrayType ValaArrayType;
typedef struct _ValaArrayTypeClass ValaArrayTypeClass;

#define VALA_TYPE_UNARY_OPERATOR (vala_unary_operator_get_type ())

#define VALA_TYPE_BINARY_OPERATOR (vala_binary_operator_get_type ())

#define VALA_TYPE_MEMBER_INITIALIZER (vala_member_initializer_get_type ())
#define VALA_MEMBER_INITIALIZER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_MEMBER_INITIALIZER, ValaMemberInitializer))
#define VALA_MEMBER_INITIALIZER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_MEMBER_INITIALIZER, ValaMemberInitializerClass))
#define VALA_IS_MEMBER_INITIALIZER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_MEMBER_INITIALIZER))
#define VALA_IS_MEMBER_INITIALIZER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_MEMBER_INITIALIZER))
#define VALA_MEMBER_INITIALIZER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_MEMBER_INITIALIZER, ValaMemberInitializerClass))

typedef struct _ValaMemberInitializer ValaMemberInitializer;
typedef struct _ValaMemberInitializerClass ValaMemberInitializerClass;

#define VALA_TYPE_ASSIGNMENT_OPERATOR (vala_assignment_operator_get_type ())

#define VALA_TYPE_STATEMENT (vala_statement_get_type ())
#define VALA_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_STATEMENT, ValaStatement))
#define VALA_IS_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_STATEMENT))
#define VALA_STATEMENT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), VALA_TYPE_STATEMENT, ValaStatementIface))

typedef struct _ValaStatement ValaStatement;
typedef struct _ValaStatementIface ValaStatementIface;

#define VALA_TYPE_REPORT (vala_report_get_type ())
#define VALA_REPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REPORT, ValaReport))
#define VALA_REPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REPORT, ValaReportClass))
#define VALA_IS_REPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REPORT))
#define VALA_IS_REPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REPORT))
#define VALA_REPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REPORT, ValaReportClass))

typedef struct _ValaReport ValaReport;
typedef struct _ValaReportClass ValaReportClass;

#define VALA_TYPE_ATTRIBUTE (vala_attribute_get_type ())
#define VALA_ATTRIBUTE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ATTRIBUTE, ValaAttribute))
#define VALA_ATTRIBUTE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ATTRIBUTE, ValaAttributeClass))
#define VALA_IS_ATTRIBUTE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ATTRIBUTE))
#define VALA_IS_ATTRIBUTE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ATTRIBUTE))
#define VALA_ATTRIBUTE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ATTRIBUTE, ValaAttributeClass))

typedef struct _ValaAttribute ValaAttribute;
typedef struct _ValaAttributeClass ValaAttributeClass;
typedef struct _ValaCodeNodePrivate ValaCodeNodePrivate;

#define VALA_TYPE_SEMANTIC_ANALYZER (vala_semantic_analyzer_get_type ())
#define VALA_SEMANTIC_ANALYZER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SEMANTIC_ANALYZER, ValaSemanticAnalyzer))
#define VALA_SEMANTIC_ANALYZER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SEMANTIC_ANALYZER, ValaSemanticAnalyzerClass))
#define VALA_IS_SEMANTIC_ANALYZER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SEMANTIC_ANALYZER))
#define VALA_IS_SEMANTIC_ANALYZER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SEMANTIC_ANALYZER))
#define VALA_SEMANTIC_ANALYZER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SEMANTIC_ANALYZER, ValaSemanticAnalyzerClass))

typedef struct _ValaSemanticAnalyzer ValaSemanticAnalyzer;
typedef struct _ValaSemanticAnalyzerClass ValaSemanticAnalyzerClass;

#define VALA_TYPE_CODE_GENERATOR (vala_code_generator_get_type ())
#define VALA_CODE_GENERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_GENERATOR, ValaCodeGenerator))
#define VALA_CODE_GENERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_GENERATOR, ValaCodeGeneratorClass))
#define VALA_IS_CODE_GENERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_GENERATOR))
#define VALA_IS_CODE_GENERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_GENERATOR))
#define VALA_CODE_GENERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_GENERATOR, ValaCodeGeneratorClass))

typedef struct _ValaCodeGenerator ValaCodeGenerator;
typedef struct _ValaCodeGeneratorClass ValaCodeGeneratorClass;

#define VALA_TYPE_PROFILE (vala_profile_get_type ())

#define TYPE_MEMBER_BINDING (member_binding_get_type ())

#define VALA_TYPE_PARAMETER_DIRECTION (vala_parameter_direction_get_type ())

struct _ValaCodeVisitor {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ValaCodeVisitorPrivate * priv;
};

struct _ValaCodeVisitorClass {
	GTypeClass parent_class;
	void (*finalize) (ValaCodeVisitor *self);
	void (*visit_source_file) (ValaCodeVisitor* self, ValaSourceFile* source_file);
	void (*visit_namespace) (ValaCodeVisitor* self, ValaNamespace* ns);
	void (*visit_class) (ValaCodeVisitor* self, ValaClass* cl);
	void (*visit_struct) (ValaCodeVisitor* self, ValaStruct* st);
	void (*visit_interface) (ValaCodeVisitor* self, ValaInterface* iface);
	void (*visit_enum) (ValaCodeVisitor* self, ValaEnum* en);
	void (*visit_enum_value) (ValaCodeVisitor* self, ValaEnumValue* ev);
	void (*visit_error_domain) (ValaCodeVisitor* self, ValaErrorDomain* edomain);
	void (*visit_error_code) (ValaCodeVisitor* self, ValaErrorCode* ecode);
	void (*visit_delegate) (ValaCodeVisitor* self, ValaDelegate* d);
	void (*visit_constant) (ValaCodeVisitor* self, ValaConstant* c);
	void (*visit_field) (ValaCodeVisitor* self, ValaField* f);
	void (*visit_method) (ValaCodeVisitor* self, ValaMethod* m);
	void (*visit_creation_method) (ValaCodeVisitor* self, ValaCreationMethod* m);
	void (*visit_formal_parameter) (ValaCodeVisitor* self, ValaFormalParameter* p);
	void (*visit_property) (ValaCodeVisitor* self, ValaProperty* prop);
	void (*visit_property_accessor) (ValaCodeVisitor* self, ValaPropertyAccessor* acc);
	void (*visit_signal) (ValaCodeVisitor* self, ValaSignal* sig);
	void (*visit_constructor) (ValaCodeVisitor* self, ValaConstructor* c);
	void (*visit_destructor) (ValaCodeVisitor* self, ValaDestructor* d);
	void (*visit_type_parameter) (ValaCodeVisitor* self, ValaTypeParameter* p);
	void (*visit_using_directive) (ValaCodeVisitor* self, ValaUsingDirective* ns);
	void (*visit_data_type) (ValaCodeVisitor* self, ValaDataType* type);
	void (*visit_block) (ValaCodeVisitor* self, ValaBlock* b);
	void (*visit_empty_statement) (ValaCodeVisitor* self, ValaEmptyStatement* stmt);
	void (*visit_declaration_statement) (ValaCodeVisitor* self, ValaDeclarationStatement* stmt);
	void (*visit_local_variable) (ValaCodeVisitor* self, ValaLocalVariable* local);
	void (*visit_initializer_list) (ValaCodeVisitor* self, ValaInitializerList* list);
	void (*visit_expression_statement) (ValaCodeVisitor* self, ValaExpressionStatement* stmt);
	void (*visit_if_statement) (ValaCodeVisitor* self, ValaIfStatement* stmt);
	void (*visit_switch_statement) (ValaCodeVisitor* self, ValaSwitchStatement* stmt);
	void (*visit_switch_section) (ValaCodeVisitor* self, ValaSwitchSection* section);
	void (*visit_switch_label) (ValaCodeVisitor* self, ValaSwitchLabel* label);
	void (*visit_loop) (ValaCodeVisitor* self, ValaLoop* stmt);
	void (*visit_while_statement) (ValaCodeVisitor* self, ValaWhileStatement* stmt);
	void (*visit_do_statement) (ValaCodeVisitor* self, ValaDoStatement* stmt);
	void (*visit_for_statement) (ValaCodeVisitor* self, ValaForStatement* stmt);
	void (*visit_foreach_statement) (ValaCodeVisitor* self, ValaForeachStatement* stmt);
	void (*visit_break_statement) (ValaCodeVisitor* self, ValaBreakStatement* stmt);
	void (*visit_continue_statement) (ValaCodeVisitor* self, ValaContinueStatement* stmt);
	void (*visit_return_statement) (ValaCodeVisitor* self, ValaReturnStatement* stmt);
	void (*visit_yield_statement) (ValaCodeVisitor* self, ValaYieldStatement* y);
	void (*visit_throw_statement) (ValaCodeVisitor* self, ValaThrowStatement* stmt);
	void (*visit_try_statement) (ValaCodeVisitor* self, ValaTryStatement* stmt);
	void (*visit_catch_clause) (ValaCodeVisitor* self, ValaCatchClause* clause);
	void (*visit_lock_statement) (ValaCodeVisitor* self, ValaLockStatement* stmt);
	void (*visit_unlock_statement) (ValaCodeVisitor* self, ValaUnlockStatement* stmt);
	void (*visit_delete_statement) (ValaCodeVisitor* self, ValaDeleteStatement* stmt);
	void (*visit_expression) (ValaCodeVisitor* self, ValaExpression* expr);
	void (*visit_array_creation_expression) (ValaCodeVisitor* self, ValaArrayCreationExpression* expr);
	void (*visit_boolean_literal) (ValaCodeVisitor* self, ValaBooleanLiteral* lit);
	void (*visit_character_literal) (ValaCodeVisitor* self, ValaCharacterLiteral* lit);
	void (*visit_integer_literal) (ValaCodeVisitor* self, ValaIntegerLiteral* lit);
	void (*visit_real_literal) (ValaCodeVisitor* self, ValaRealLiteral* lit);
	void (*visit_regex_literal) (ValaCodeVisitor* self, ValaRegexLiteral* lit);
	void (*visit_string_literal) (ValaCodeVisitor* self, ValaStringLiteral* lit);
	void (*visit_template) (ValaCodeVisitor* self, ValaTemplate* tmpl);
	void (*visit_list_literal) (ValaCodeVisitor* self, ValaListLiteral* lit);
	void (*visit_set_literal) (ValaCodeVisitor* self, ValaSetLiteral* lit);
	void (*visit_map_literal) (ValaCodeVisitor* self, ValaMapLiteral* lit);
	void (*visit_tuple) (ValaCodeVisitor* self, ValaTuple* tuple);
	void (*visit_null_literal) (ValaCodeVisitor* self, ValaNullLiteral* lit);
	void (*visit_member_access) (ValaCodeVisitor* self, ValaMemberAccess* expr);
	void (*visit_method_call) (ValaCodeVisitor* self, ValaMethodCall* expr);
	void (*visit_element_access) (ValaCodeVisitor* self, ValaElementAccess* expr);
	void (*visit_slice_expression) (ValaCodeVisitor* self, ValaSliceExpression* expr);
	void (*visit_base_access) (ValaCodeVisitor* self, ValaBaseAccess* expr);
	void (*visit_postfix_expression) (ValaCodeVisitor* self, ValaPostfixExpression* expr);
	void (*visit_object_creation_expression) (ValaCodeVisitor* self, ValaObjectCreationExpression* expr);
	void (*visit_sizeof_expression) (ValaCodeVisitor* self, ValaSizeofExpression* expr);
	void (*visit_typeof_expression) (ValaCodeVisitor* self, ValaTypeofExpression* expr);
	void (*visit_unary_expression) (ValaCodeVisitor* self, ValaUnaryExpression* expr);
	void (*visit_cast_expression) (ValaCodeVisitor* self, ValaCastExpression* expr);
	void (*visit_named_argument) (ValaCodeVisitor* self, ValaNamedArgument* expr);
	void (*visit_pointer_indirection) (ValaCodeVisitor* self, ValaPointerIndirection* expr);
	void (*visit_addressof_expression) (ValaCodeVisitor* self, ValaAddressofExpression* expr);
	void (*visit_reference_transfer_expression) (ValaCodeVisitor* self, ValaReferenceTransferExpression* expr);
	void (*visit_binary_expression) (ValaCodeVisitor* self, ValaBinaryExpression* expr);
	void (*visit_type_check) (ValaCodeVisitor* self, ValaTypeCheck* expr);
	void (*visit_conditional_expression) (ValaCodeVisitor* self, ValaConditionalExpression* expr);
	void (*visit_lambda_expression) (ValaCodeVisitor* self, ValaLambdaExpression* expr);
	void (*visit_assignment) (ValaCodeVisitor* self, ValaAssignment* a);
	void (*visit_end_full_expression) (ValaCodeVisitor* self, ValaExpression* expr);
};

struct _ValaGenieParser {
	ValaCodeVisitor parent_instance;
	ValaGenieParserPrivate * priv;
};

struct _ValaGenieParserClass {
	ValaCodeVisitorClass parent_class;
};

typedef enum  {
	VALA_GENIE_TOKEN_TYPE_NONE,
	VALA_GENIE_TOKEN_TYPE_ABSTRACT,
	VALA_GENIE_TOKEN_TYPE_ARRAY,
	VALA_GENIE_TOKEN_TYPE_AS,
	VALA_GENIE_TOKEN_TYPE_ASSERT,
	VALA_GENIE_TOKEN_TYPE_ASSIGN,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_ADD,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_AND,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_OR,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_XOR,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_DIV,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_MUL,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_PERCENT,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_SHIFT_LEFT,
	VALA_GENIE_TOKEN_TYPE_ASSIGN_SUB,
	VALA_GENIE_TOKEN_TYPE_ASYNC,
	VALA_GENIE_TOKEN_TYPE_BITWISE_AND,
	VALA_GENIE_TOKEN_TYPE_BITWISE_OR,
	VALA_GENIE_TOKEN_TYPE_BREAK,
	VALA_GENIE_TOKEN_TYPE_CARRET,
	VALA_GENIE_TOKEN_TYPE_CASE,
	VALA_GENIE_TOKEN_TYPE_CHARACTER_LITERAL,
	VALA_GENIE_TOKEN_TYPE_CLASS,
	VALA_GENIE_TOKEN_TYPE_CLOSE_BRACE,
	VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET,
	VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS,
	VALA_GENIE_TOKEN_TYPE_CLOSE_REGEX_LITERAL,
	VALA_GENIE_TOKEN_TYPE_CLOSE_TEMPLATE,
	VALA_GENIE_TOKEN_TYPE_COLON,
	VALA_GENIE_TOKEN_TYPE_COMMA,
	VALA_GENIE_TOKEN_TYPE_CONST,
	VALA_GENIE_TOKEN_TYPE_CONSTRUCT,
	VALA_GENIE_TOKEN_TYPE_CONTINUE,
	VALA_GENIE_TOKEN_TYPE_DEDENT,
	VALA_GENIE_TOKEN_TYPE_DEF,
	VALA_GENIE_TOKEN_TYPE_DEFAULT,
	VALA_GENIE_TOKEN_TYPE_DELEGATE,
	VALA_GENIE_TOKEN_TYPE_DELETE,
	VALA_GENIE_TOKEN_TYPE_DICT,
	VALA_GENIE_TOKEN_TYPE_DIV,
	VALA_GENIE_TOKEN_TYPE_DO,
	VALA_GENIE_TOKEN_TYPE_DOT,
	VALA_GENIE_TOKEN_TYPE_DOWNTO,
	VALA_GENIE_TOKEN_TYPE_DYNAMIC,
	VALA_GENIE_TOKEN_TYPE_ELLIPSIS,
	VALA_GENIE_TOKEN_TYPE_ELSE,
	VALA_GENIE_TOKEN_TYPE_ENUM,
	VALA_GENIE_TOKEN_TYPE_ENSURES,
	VALA_GENIE_TOKEN_TYPE_ERRORDOMAIN,
	VALA_GENIE_TOKEN_TYPE_EOF,
	VALA_GENIE_TOKEN_TYPE_EOL,
	VALA_GENIE_TOKEN_TYPE_EVENT,
	VALA_GENIE_TOKEN_TYPE_EXCEPT,
	VALA_GENIE_TOKEN_TYPE_EXTERN,
	VALA_GENIE_TOKEN_TYPE_FALSE,
	VALA_GENIE_TOKEN_TYPE_FINAL,
	VALA_GENIE_TOKEN_TYPE_FINALLY,
	VALA_GENIE_TOKEN_TYPE_FOR,
	VALA_GENIE_TOKEN_TYPE_GET,
	VALA_GENIE_TOKEN_TYPE_HASH,
	VALA_GENIE_TOKEN_TYPE_IDENTIFIER,
	VALA_GENIE_TOKEN_TYPE_IF,
	VALA_GENIE_TOKEN_TYPE_IMPLEMENTS,
	VALA_GENIE_TOKEN_TYPE_IN,
	VALA_GENIE_TOKEN_TYPE_INDENT,
	VALA_GENIE_TOKEN_TYPE_INIT,
	VALA_GENIE_TOKEN_TYPE_INLINE,
	VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL,
	VALA_GENIE_TOKEN_TYPE_INTERFACE,
	VALA_GENIE_TOKEN_TYPE_INTERNAL,
	VALA_GENIE_TOKEN_TYPE_INTERR,
	VALA_GENIE_TOKEN_TYPE_IS,
	VALA_GENIE_TOKEN_TYPE_ISA,
	VALA_GENIE_TOKEN_TYPE_LAMBDA,
	VALA_GENIE_TOKEN_TYPE_LIST,
	VALA_GENIE_TOKEN_TYPE_LOCK,
	VALA_GENIE_TOKEN_TYPE_MINUS,
	VALA_GENIE_TOKEN_TYPE_NAMESPACE,
	VALA_GENIE_TOKEN_TYPE_NEW,
	VALA_GENIE_TOKEN_TYPE_NULL,
	VALA_GENIE_TOKEN_TYPE_OF,
	VALA_GENIE_TOKEN_TYPE_OUT,
	VALA_GENIE_TOKEN_TYPE_OP_AND,
	VALA_GENIE_TOKEN_TYPE_OP_DEC,
	VALA_GENIE_TOKEN_TYPE_OP_EQ,
	VALA_GENIE_TOKEN_TYPE_OP_GE,
	VALA_GENIE_TOKEN_TYPE_OP_GT,
	VALA_GENIE_TOKEN_TYPE_OP_INC,
	VALA_GENIE_TOKEN_TYPE_OP_LE,
	VALA_GENIE_TOKEN_TYPE_OP_LT,
	VALA_GENIE_TOKEN_TYPE_OP_NE,
	VALA_GENIE_TOKEN_TYPE_OP_NEG,
	VALA_GENIE_TOKEN_TYPE_OP_OR,
	VALA_GENIE_TOKEN_TYPE_OP_PTR,
	VALA_GENIE_TOKEN_TYPE_OP_SHIFT_LEFT,
	VALA_GENIE_TOKEN_TYPE_OPEN_BRACE,
	VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET,
	VALA_GENIE_TOKEN_TYPE_OPEN_PARENS,
	VALA_GENIE_TOKEN_TYPE_OPEN_REGEX_LITERAL,
	VALA_GENIE_TOKEN_TYPE_OPEN_TEMPLATE,
	VALA_GENIE_TOKEN_TYPE_OVERRIDE,
	VALA_GENIE_TOKEN_TYPE_OWNED,
	VALA_GENIE_TOKEN_TYPE_PARAMS,
	VALA_GENIE_TOKEN_TYPE_PASS,
	VALA_GENIE_TOKEN_TYPE_PERCENT,
	VALA_GENIE_TOKEN_TYPE_PLUS,
	VALA_GENIE_TOKEN_TYPE_PRINT,
	VALA_GENIE_TOKEN_TYPE_PRIVATE,
	VALA_GENIE_TOKEN_TYPE_PROP,
	VALA_GENIE_TOKEN_TYPE_PROTECTED,
	VALA_GENIE_TOKEN_TYPE_PUBLIC,
	VALA_GENIE_TOKEN_TYPE_RAISE,
	VALA_GENIE_TOKEN_TYPE_RAISES,
	VALA_GENIE_TOKEN_TYPE_REAL_LITERAL,
	VALA_GENIE_TOKEN_TYPE_READONLY,
	VALA_GENIE_TOKEN_TYPE_REF,
	VALA_GENIE_TOKEN_TYPE_REGEX_LITERAL,
	VALA_GENIE_TOKEN_TYPE_REQUIRES,
	VALA_GENIE_TOKEN_TYPE_RETURN,
	VALA_GENIE_TOKEN_TYPE_SEMICOLON,
	VALA_GENIE_TOKEN_TYPE_SET,
	VALA_GENIE_TOKEN_TYPE_SIZEOF,
	VALA_GENIE_TOKEN_TYPE_STAR,
	VALA_GENIE_TOKEN_TYPE_STATIC,
	VALA_GENIE_TOKEN_TYPE_STRING_LITERAL,
	VALA_GENIE_TOKEN_TYPE_STRUCT,
	VALA_GENIE_TOKEN_TYPE_SUPER,
	VALA_GENIE_TOKEN_TYPE_TEMPLATE_STRING_LITERAL,
	VALA_GENIE_TOKEN_TYPE_THIS,
	VALA_GENIE_TOKEN_TYPE_TILDE,
	VALA_GENIE_TOKEN_TYPE_TO,
	VALA_GENIE_TOKEN_TYPE_TRUE,
	VALA_GENIE_TOKEN_TYPE_TRY,
	VALA_GENIE_TOKEN_TYPE_TYPEOF,
	VALA_GENIE_TOKEN_TYPE_UNOWNED,
	VALA_GENIE_TOKEN_TYPE_USES,
	VALA_GENIE_TOKEN_TYPE_VAR,
	VALA_GENIE_TOKEN_TYPE_VERBATIM_STRING_LITERAL,
	VALA_GENIE_TOKEN_TYPE_VIRTUAL,
	VALA_GENIE_TOKEN_TYPE_VOID,
	VALA_GENIE_TOKEN_TYPE_VOLATILE,
	VALA_GENIE_TOKEN_TYPE_WEAK,
	VALA_GENIE_TOKEN_TYPE_WHEN,
	VALA_GENIE_TOKEN_TYPE_WHILE,
	VALA_GENIE_TOKEN_TYPE_WRITEONLY,
	VALA_GENIE_TOKEN_TYPE_YIELD
} ValaGenieTokenType;

struct _ValaSourceLocation {
	gchar* pos;
	gint line;
	gint column;
};

struct _ValaGenieParserTokenInfo {
	ValaGenieTokenType type;
	ValaSourceLocation begin;
	ValaSourceLocation end;
};

struct _ValaGenieParserPrivate {
	ValaGenieScanner* scanner;
	ValaCodeContext* context;
	ValaGenieParserTokenInfo* tokens;
	gint tokens_length1;
	gint _tokens_size_;
	gint index;
	gint size;
	ValaComment* comment;
	char* class_name;
	gboolean current_expr_is_lambda;
};

typedef enum  {
	VALA_GENIE_PARSER_MODIFIER_FLAGS_NONE,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT = 1 << 0,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS = 1 << 1,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN = 1 << 2,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_INLINE = 1 << 3,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW = 1 << 4,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE = 1 << 5,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC = 1 << 6,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL = 1 << 7,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE = 1 << 8,
	VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC = 1 << 9
} ValaGenieParserModifierFlags;

typedef enum  {
	VALA_GENIE_PARSER_RECOVERY_STATE_EOF,
	VALA_GENIE_PARSER_RECOVERY_STATE_DECLARATION_BEGIN,
	VALA_GENIE_PARSER_RECOVERY_STATE_STATEMENT_BEGIN
} ValaGenieParserRecoveryState;

typedef enum  {
	VALA_PARSE_ERROR_FAILED,
	VALA_PARSE_ERROR_SYNTAX
} ValaParseError;
#define VALA_PARSE_ERROR vala_parse_error_quark ()
typedef enum  {
	VALA_SYMBOL_ACCESSIBILITY_PRIVATE,
	VALA_SYMBOL_ACCESSIBILITY_INTERNAL,
	VALA_SYMBOL_ACCESSIBILITY_PROTECTED,
	VALA_SYMBOL_ACCESSIBILITY_PUBLIC
} ValaSymbolAccessibility;

typedef enum  {
	VALA_UNARY_OPERATOR_NONE,
	VALA_UNARY_OPERATOR_PLUS,
	VALA_UNARY_OPERATOR_MINUS,
	VALA_UNARY_OPERATOR_LOGICAL_NEGATION,
	VALA_UNARY_OPERATOR_BITWISE_COMPLEMENT,
	VALA_UNARY_OPERATOR_INCREMENT,
	VALA_UNARY_OPERATOR_DECREMENT,
	VALA_UNARY_OPERATOR_REF,
	VALA_UNARY_OPERATOR_OUT
} ValaUnaryOperator;

typedef enum  {
	VALA_BINARY_OPERATOR_NONE,
	VALA_BINARY_OPERATOR_PLUS,
	VALA_BINARY_OPERATOR_MINUS,
	VALA_BINARY_OPERATOR_MUL,
	VALA_BINARY_OPERATOR_DIV,
	VALA_BINARY_OPERATOR_MOD,
	VALA_BINARY_OPERATOR_SHIFT_LEFT,
	VALA_BINARY_OPERATOR_SHIFT_RIGHT,
	VALA_BINARY_OPERATOR_LESS_THAN,
	VALA_BINARY_OPERATOR_GREATER_THAN,
	VALA_BINARY_OPERATOR_LESS_THAN_OR_EQUAL,
	VALA_BINARY_OPERATOR_GREATER_THAN_OR_EQUAL,
	VALA_BINARY_OPERATOR_EQUALITY,
	VALA_BINARY_OPERATOR_INEQUALITY,
	VALA_BINARY_OPERATOR_BITWISE_AND,
	VALA_BINARY_OPERATOR_BITWISE_OR,
	VALA_BINARY_OPERATOR_BITWISE_XOR,
	VALA_BINARY_OPERATOR_AND,
	VALA_BINARY_OPERATOR_OR,
	VALA_BINARY_OPERATOR_IN,
	VALA_BINARY_OPERATOR_COALESCE
} ValaBinaryOperator;

typedef enum  {
	VALA_ASSIGNMENT_OPERATOR_NONE,
	VALA_ASSIGNMENT_OPERATOR_SIMPLE,
	VALA_ASSIGNMENT_OPERATOR_BITWISE_OR,
	VALA_ASSIGNMENT_OPERATOR_BITWISE_AND,
	VALA_ASSIGNMENT_OPERATOR_BITWISE_XOR,
	VALA_ASSIGNMENT_OPERATOR_ADD,
	VALA_ASSIGNMENT_OPERATOR_SUB,
	VALA_ASSIGNMENT_OPERATOR_MUL,
	VALA_ASSIGNMENT_OPERATOR_DIV,
	VALA_ASSIGNMENT_OPERATOR_PERCENT,
	VALA_ASSIGNMENT_OPERATOR_SHIFT_LEFT,
	VALA_ASSIGNMENT_OPERATOR_SHIFT_RIGHT
} ValaAssignmentOperator;

struct _ValaStatementIface {
	GTypeInterface parent_iface;
};

struct _ValaCodeNode {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ValaCodeNodePrivate * priv;
	GList* attributes;
};

struct _ValaCodeNodeClass {
	GTypeClass parent_class;
	void (*finalize) (ValaCodeNode *self);
	void (*accept) (ValaCodeNode* self, ValaCodeVisitor* visitor);
	void (*accept_children) (ValaCodeNode* self, ValaCodeVisitor* visitor);
	gboolean (*check) (ValaCodeNode* self, ValaSemanticAnalyzer* analyzer);
	void (*emit) (ValaCodeNode* self, ValaCodeGenerator* codegen);
	void (*replace_type) (ValaCodeNode* self, ValaDataType* old_type, ValaDataType* new_type);
	void (*replace_expression) (ValaCodeNode* self, ValaExpression* old_node, ValaExpression* new_node);
	char* (*to_string) (ValaCodeNode* self);
	void (*get_defined_variables) (ValaCodeNode* self, ValaCollection* collection);
	void (*get_used_variables) (ValaCodeNode* self, ValaCollection* collection);
};

typedef enum  {
	VALA_PROFILE_POSIX,
	VALA_PROFILE_GOBJECT,
	VALA_PROFILE_DOVA
} ValaProfile;

typedef enum  {
	MEMBER_BINDING_INSTANCE,
	MEMBER_BINDING_CLASS,
	MEMBER_BINDING_STATIC
} MemberBinding;

typedef enum  {
	VALA_PARAMETER_DIRECTION_IN,
	VALA_PARAMETER_DIRECTION_OUT,
	VALA_PARAMETER_DIRECTION_REF
} ValaParameterDirection;


static gpointer vala_genie_parser_parent_class = NULL;

gpointer vala_code_visitor_ref (gpointer instance);
void vala_code_visitor_unref (gpointer instance);
GParamSpec* vala_param_spec_code_visitor (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_code_visitor (GValue* value, gpointer v_object);
void vala_value_take_code_visitor (GValue* value, gpointer v_object);
gpointer vala_value_get_code_visitor (const GValue* value);
GType vala_code_visitor_get_type (void) G_GNUC_CONST;
gpointer vala_source_file_ref (gpointer instance);
void vala_source_file_unref (gpointer instance);
GParamSpec* vala_param_spec_source_file (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_source_file (GValue* value, gpointer v_object);
void vala_value_take_source_file (GValue* value, gpointer v_object);
gpointer vala_value_get_source_file (const GValue* value);
GType vala_source_file_get_type (void) G_GNUC_CONST;
gpointer vala_code_node_ref (gpointer instance);
void vala_code_node_unref (gpointer instance);
GParamSpec* vala_param_spec_code_node (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_code_node (GValue* value, gpointer v_object);
void vala_value_take_code_node (GValue* value, gpointer v_object);
gpointer vala_value_get_code_node (const GValue* value);
GType vala_code_node_get_type (void) G_GNUC_CONST;
GType vala_symbol_get_type (void) G_GNUC_CONST;
GType vala_namespace_get_type (void) G_GNUC_CONST;
GType vala_typesymbol_get_type (void) G_GNUC_CONST;
GType vala_object_type_symbol_get_type (void) G_GNUC_CONST;
GType vala_class_get_type (void) G_GNUC_CONST;
GType vala_struct_get_type (void) G_GNUC_CONST;
GType vala_interface_get_type (void) G_GNUC_CONST;
GType vala_enum_get_type (void) G_GNUC_CONST;
GType vala_constant_get_type (void) G_GNUC_CONST;
GType vala_enum_value_get_type (void) G_GNUC_CONST;
GType vala_error_domain_get_type (void) G_GNUC_CONST;
GType vala_error_code_get_type (void) G_GNUC_CONST;
GType vala_delegate_get_type (void) G_GNUC_CONST;
GType vala_variable_get_type (void) G_GNUC_CONST;
GType vala_field_get_type (void) G_GNUC_CONST;
GType vala_method_get_type (void) G_GNUC_CONST;
GType vala_creation_method_get_type (void) G_GNUC_CONST;
GType vala_formal_parameter_get_type (void) G_GNUC_CONST;
GType vala_property_get_type (void) G_GNUC_CONST;
GType vala_property_accessor_get_type (void) G_GNUC_CONST;
GType vala_signal_get_type (void) G_GNUC_CONST;
GType vala_constructor_get_type (void) G_GNUC_CONST;
GType vala_destructor_get_type (void) G_GNUC_CONST;
GType vala_typeparameter_get_type (void) G_GNUC_CONST;
GType vala_using_directive_get_type (void) G_GNUC_CONST;
GType vala_data_type_get_type (void) G_GNUC_CONST;
GType vala_block_get_type (void) G_GNUC_CONST;
GType vala_empty_statement_get_type (void) G_GNUC_CONST;
GType vala_declaration_statement_get_type (void) G_GNUC_CONST;
GType vala_local_variable_get_type (void) G_GNUC_CONST;
GType vala_expression_get_type (void) G_GNUC_CONST;
GType vala_initializer_list_get_type (void) G_GNUC_CONST;
GType vala_expression_statement_get_type (void) G_GNUC_CONST;
GType vala_if_statement_get_type (void) G_GNUC_CONST;
GType vala_switch_statement_get_type (void) G_GNUC_CONST;
GType vala_switch_section_get_type (void) G_GNUC_CONST;
GType vala_switch_label_get_type (void) G_GNUC_CONST;
GType vala_loop_get_type (void) G_GNUC_CONST;
GType vala_while_statement_get_type (void) G_GNUC_CONST;
GType vala_do_statement_get_type (void) G_GNUC_CONST;
GType vala_for_statement_get_type (void) G_GNUC_CONST;
GType vala_foreach_statement_get_type (void) G_GNUC_CONST;
GType vala_break_statement_get_type (void) G_GNUC_CONST;
GType vala_continue_statement_get_type (void) G_GNUC_CONST;
GType vala_return_statement_get_type (void) G_GNUC_CONST;
GType vala_yield_statement_get_type (void) G_GNUC_CONST;
GType vala_throw_statement_get_type (void) G_GNUC_CONST;
GType vala_try_statement_get_type (void) G_GNUC_CONST;
GType vala_catch_clause_get_type (void) G_GNUC_CONST;
GType vala_lock_statement_get_type (void) G_GNUC_CONST;
GType vala_unlock_statement_get_type (void) G_GNUC_CONST;
GType vala_delete_statement_get_type (void) G_GNUC_CONST;
GType vala_array_creation_expression_get_type (void) G_GNUC_CONST;
GType vala_literal_get_type (void) G_GNUC_CONST;
GType vala_boolean_literal_get_type (void) G_GNUC_CONST;
GType vala_character_literal_get_type (void) G_GNUC_CONST;
GType vala_integer_literal_get_type (void) G_GNUC_CONST;
GType vala_real_literal_get_type (void) G_GNUC_CONST;
GType vala_regex_literal_get_type (void) G_GNUC_CONST;
GType vala_string_literal_get_type (void) G_GNUC_CONST;
GType vala_template_get_type (void) G_GNUC_CONST;
GType vala_list_literal_get_type (void) G_GNUC_CONST;
GType vala_set_literal_get_type (void) G_GNUC_CONST;
GType vala_map_literal_get_type (void) G_GNUC_CONST;
GType vala_tuple_get_type (void) G_GNUC_CONST;
GType vala_null_literal_get_type (void) G_GNUC_CONST;
GType vala_member_access_get_type (void) G_GNUC_CONST;
GType vala_method_call_get_type (void) G_GNUC_CONST;
GType vala_element_access_get_type (void) G_GNUC_CONST;
GType vala_slice_expression_get_type (void) G_GNUC_CONST;
GType vala_base_access_get_type (void) G_GNUC_CONST;
GType vala_postfix_expression_get_type (void) G_GNUC_CONST;
GType vala_object_creation_expression_get_type (void) G_GNUC_CONST;
GType vala_sizeof_expression_get_type (void) G_GNUC_CONST;
GType vala_typeof_expression_get_type (void) G_GNUC_CONST;
GType vala_unary_expression_get_type (void) G_GNUC_CONST;
GType vala_cast_expression_get_type (void) G_GNUC_CONST;
GType vala_named_argument_get_type (void) G_GNUC_CONST;
GType vala_pointer_indirection_get_type (void) G_GNUC_CONST;
GType vala_addressof_expression_get_type (void) G_GNUC_CONST;
GType vala_reference_transfer_expression_get_type (void) G_GNUC_CONST;
GType vala_binary_expression_get_type (void) G_GNUC_CONST;
GType vala_typecheck_get_type (void) G_GNUC_CONST;
GType vala_conditional_expression_get_type (void) G_GNUC_CONST;
GType vala_lambda_expression_get_type (void) G_GNUC_CONST;
GType vala_assignment_get_type (void) G_GNUC_CONST;
GType vala_genie_parser_get_type (void) G_GNUC_CONST;
gpointer vala_genie_scanner_ref (gpointer instance);
void vala_genie_scanner_unref (gpointer instance);
GParamSpec* vala_genie_param_spec_scanner (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_genie_value_set_scanner (GValue* value, gpointer v_object);
void vala_genie_value_take_scanner (GValue* value, gpointer v_object);
gpointer vala_genie_value_get_scanner (const GValue* value);
GType vala_genie_scanner_get_type (void) G_GNUC_CONST;
gpointer vala_code_context_ref (gpointer instance);
void vala_code_context_unref (gpointer instance);
GParamSpec* vala_param_spec_code_context (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_code_context (GValue* value, gpointer v_object);
void vala_value_take_code_context (GValue* value, gpointer v_object);
gpointer vala_value_get_code_context (const GValue* value);
GType vala_code_context_get_type (void) G_GNUC_CONST;
static GType vala_genie_parser_token_info_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
GType vala_genie_token_type_get_type (void) G_GNUC_CONST;
GType vala_source_location_get_type (void) G_GNUC_CONST;
ValaSourceLocation* vala_source_location_dup (const ValaSourceLocation* self);
void vala_source_location_free (ValaSourceLocation* self);
static ValaGenieParserTokenInfo* vala_genie_parser_token_info_dup (const ValaGenieParserTokenInfo* self);
static void vala_genie_parser_token_info_free (ValaGenieParserTokenInfo* self);
gpointer vala_comment_ref (gpointer instance);
void vala_comment_unref (gpointer instance);
GParamSpec* vala_param_spec_comment (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_comment (GValue* value, gpointer v_object);
void vala_value_take_comment (GValue* value, gpointer v_object);
gpointer vala_value_get_comment (const GValue* value);
GType vala_comment_get_type (void) G_GNUC_CONST;
#define VALA_GENIE_PARSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), VALA_GENIE_TYPE_PARSER, ValaGenieParserPrivate))
enum  {
	VALA_GENIE_PARSER_DUMMY_PROPERTY
};
static GType vala_genie_parser_modifier_flags_get_type (void) G_GNUC_UNUSED;
static GType vala_genie_parser_recovery_state_get_type (void) G_GNUC_UNUSED;
#define VALA_GENIE_PARSER_BUFFER_SIZE 32
ValaGenieParser* vala_genie_parser_new (void);
ValaGenieParser* vala_genie_parser_construct (GType object_type);
ValaCodeVisitor* vala_code_visitor_construct (GType object_type);
void vala_genie_parser_parse (ValaGenieParser* self, ValaCodeContext* context);
void vala_code_context_accept (ValaCodeContext* self, ValaCodeVisitor* visitor);
static void vala_genie_parser_real_visit_source_file (ValaCodeVisitor* base, ValaSourceFile* source_file);
const char* vala_source_file_get_filename (ValaSourceFile* self);
void vala_genie_parser_parse_file (ValaGenieParser* self, ValaSourceFile* source_file);
static inline gboolean vala_genie_parser_next (ValaGenieParser* self);
ValaGenieTokenType vala_genie_scanner_read_token (ValaGenieScanner* self, ValaSourceLocation* token_begin, ValaSourceLocation* token_end);
static inline void vala_genie_parser_prev (ValaGenieParser* self);
static inline ValaGenieTokenType vala_genie_parser_current (ValaGenieParser* self);
static inline gboolean vala_genie_parser_accept (ValaGenieParser* self, ValaGenieTokenType type);
static inline gboolean vala_genie_parser_accept_terminator (ValaGenieParser* self);
static inline gboolean vala_genie_parser_accept_block (ValaGenieParser* self);
static char* vala_genie_parser_get_error (ValaGenieParser* self, const char* msg);
static inline void vala_genie_parser_get_location (ValaGenieParser* self, ValaSourceLocation* result);
gpointer vala_source_reference_ref (gpointer instance);
void vala_source_reference_unref (gpointer instance);
GParamSpec* vala_param_spec_source_reference (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_source_reference (GValue* value, gpointer v_object);
void vala_value_take_source_reference (GValue* value, gpointer v_object);
gpointer vala_value_get_source_reference (const GValue* value);
GType vala_source_reference_get_type (void) G_GNUC_CONST;
void vala_report_error (ValaSourceReference* source, const char* message);
static ValaSourceReference* vala_genie_parser_get_src (ValaGenieParser* self, ValaSourceLocation* begin);
GQuark vala_parse_error_quark (void);
static inline gboolean vala_genie_parser_expect (ValaGenieParser* self, ValaGenieTokenType type, GError** error);
const char* vala_genie_token_type_to_string (ValaGenieTokenType self);
static inline gboolean vala_genie_parser_expect_terminator (ValaGenieParser* self, GError** error);
static char* vala_genie_parser_get_current_string (ValaGenieParser* self);
static char* vala_genie_parser_get_last_string (ValaGenieParser* self);
ValaSourceFile* vala_genie_scanner_get_source_file (ValaGenieScanner* self);
ValaSourceReference* vala_source_reference_new (ValaSourceFile* _file, gint _first_line, gint _first_column, gint _last_line, gint _last_column);
ValaSourceReference* vala_source_reference_construct (GType object_type, ValaSourceFile* _file, gint _first_line, gint _first_column, gint _last_line, gint _last_column);
static ValaSourceReference* vala_genie_parser_get_current_src (ValaGenieParser* self);
static void vala_genie_parser_rollback (ValaGenieParser* self, ValaSourceLocation* location);
void vala_genie_scanner_seek (ValaGenieScanner* self, ValaSourceLocation* location);
GType vala_symbol_accessibility_get_type (void) G_GNUC_CONST;
static inline ValaSymbolAccessibility vala_genie_parser_get_access (ValaGenieParser* self, const char* s);
static void vala_genie_parser_skip_identifier (ValaGenieParser* self, GError** error);
static char* vala_genie_parser_parse_identifier (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_literal (ValaGenieParser* self, GError** error);
ValaBooleanLiteral* vala_boolean_literal_new (gboolean b, ValaSourceReference* source);
ValaBooleanLiteral* vala_boolean_literal_construct (GType object_type, gboolean b, ValaSourceReference* source);
ValaIntegerLiteral* vala_integer_literal_new (const char* i, ValaSourceReference* source);
ValaIntegerLiteral* vala_integer_literal_construct (GType object_type, const char* i, ValaSourceReference* source);
ValaRealLiteral* vala_real_literal_new (const char* r, ValaSourceReference* source);
ValaRealLiteral* vala_real_literal_construct (GType object_type, const char* r, ValaSourceReference* source);
ValaCharacterLiteral* vala_character_literal_new (const char* c, ValaSourceReference* source);
ValaCharacterLiteral* vala_character_literal_construct (GType object_type, const char* c, ValaSourceReference* source);
gboolean vala_code_node_get_error (ValaCodeNode* self);
ValaSourceReference* vala_code_node_get_source_reference (ValaCodeNode* self);
ValaRegexLiteral* vala_regex_literal_new (const char* value, ValaSourceReference* source_reference);
ValaRegexLiteral* vala_regex_literal_construct (GType object_type, const char* value, ValaSourceReference* source_reference);
ValaStringLiteral* vala_string_literal_new (const char* value, ValaSourceReference* source_reference);
ValaStringLiteral* vala_string_literal_construct (GType object_type, const char* value, ValaSourceReference* source_reference);
ValaNullLiteral* vala_null_literal_new (ValaSourceReference* source);
ValaNullLiteral* vala_null_literal_construct (GType object_type, ValaSourceReference* source);
ValaGenieScanner* vala_genie_scanner_new (ValaSourceFile* source_file);
ValaGenieScanner* vala_genie_scanner_construct (GType object_type, ValaSourceFile* source_file);
void vala_genie_scanner_parse_file_comments (ValaGenieScanner* self);
void vala_genie_scanner_set_indent_spaces (ValaGenieScanner* self, gint value);
static void vala_genie_parser_parse_using_directives (ValaGenieParser* self, ValaNamespace* ns, GError** error);
ValaNamespace* vala_code_context_get_root (ValaCodeContext* self);
static void vala_genie_parser_parse_declarations (ValaGenieParser* self, ValaSymbol* parent, gboolean root, GError** error);
static void vala_genie_parser_skip_symbol_name (ValaGenieParser* self, GError** error);
GType vala_unresolved_symbol_get_type (void) G_GNUC_CONST;
static ValaUnresolvedSymbol* vala_genie_parser_parse_symbol_name (ValaGenieParser* self, GError** error);
ValaUnresolvedSymbol* vala_unresolved_symbol_new (ValaUnresolvedSymbol* inner, const char* name, ValaSourceReference* source_reference);
ValaUnresolvedSymbol* vala_unresolved_symbol_construct (GType object_type, ValaUnresolvedSymbol* inner, const char* name, ValaSourceReference* source_reference);
static void vala_genie_parser_skip_type (ValaGenieParser* self, GError** error);
static void vala_genie_parser_skip_type_argument_list (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_regex_literal (ValaGenieParser* self, GError** error);
static ValaDataType* vala_genie_parser_parse_type (ValaGenieParser* self, gboolean owned_by_default, GError** error);
ValaVoidType* vala_void_type_new (ValaSourceReference* source_reference);
ValaVoidType* vala_void_type_construct (GType object_type, ValaSourceReference* source_reference);
GType vala_void_type_get_type (void) G_GNUC_CONST;
ValaPointerType* vala_pointer_type_new (ValaDataType* base_type, ValaSourceReference* source_reference);
ValaPointerType* vala_pointer_type_construct (GType object_type, ValaDataType* base_type, ValaSourceReference* source_reference);
GType vala_pointer_type_get_type (void) G_GNUC_CONST;
static ValaList* vala_genie_parser_parse_type_argument_list (ValaGenieParser* self, gboolean maybe_expression, GError** error);
ValaUnresolvedType* vala_unresolved_type_new_from_symbol (ValaUnresolvedSymbol* symbol, ValaSourceReference* source);
ValaUnresolvedType* vala_unresolved_type_construct_from_symbol (GType object_type, ValaUnresolvedSymbol* symbol, ValaSourceReference* source);
GType vala_unresolved_type_get_type (void) G_GNUC_CONST;
void vala_data_type_add_type_argument (ValaDataType* self, ValaDataType* arg);
void vala_data_type_set_nullable (ValaDataType* self, gboolean value);
void vala_data_type_set_value_owned (ValaDataType* self, gboolean value);
ValaArrayType* vala_array_type_new (ValaDataType* element_type, gint rank, ValaSourceReference* source_reference);
ValaArrayType* vala_array_type_construct (GType object_type, ValaDataType* element_type, gint rank, ValaSourceReference* source_reference);
GType vala_reference_type_get_type (void) G_GNUC_CONST;
GType vala_array_type_get_type (void) G_GNUC_CONST;
void vala_array_type_set_invalid_syntax (ValaArrayType* self, gboolean value);
void vala_data_type_set_is_dynamic (ValaDataType* self, gboolean value);
static ValaDataType* vala_genie_parser_parse_inline_array_type (ValaGenieParser* self, ValaDataType* type, GError** error);
const char* vala_integer_literal_get_value (ValaIntegerLiteral* self);
void vala_array_type_set_inline_allocated (ValaArrayType* self, gboolean value);
void vala_array_type_set_fixed_length (ValaArrayType* self, gboolean value);
void vala_array_type_set_length (ValaArrayType* self, gint value);
static ValaList* vala_genie_parser_parse_argument_list (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_argument (ValaGenieParser* self, GError** error);
GType vala_unary_operator_get_type (void) G_GNUC_CONST;
ValaUnaryExpression* vala_unary_expression_new (ValaUnaryOperator op, ValaExpression* _inner, ValaSourceReference* source);
ValaUnaryExpression* vala_unary_expression_construct (GType object_type, ValaUnaryOperator op, ValaExpression* _inner, ValaSourceReference* source);
ValaExpression* vala_member_access_get_inner (ValaMemberAccess* self);
const char* vala_member_access_get_member_name (ValaMemberAccess* self);
ValaNamedArgument* vala_named_argument_new (const char* name, ValaExpression* inner, ValaSourceReference* source_reference);
ValaNamedArgument* vala_named_argument_construct (GType object_type, const char* name, ValaExpression* inner, ValaSourceReference* source_reference);
static ValaExpression* vala_genie_parser_parse_primary_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_assert_expression (ValaGenieParser* self, GError** error);
static ValaInitializerList* vala_genie_parser_parse_initializer (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_tuple (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_template (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_this_access (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_base_access (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_object_or_array_creation_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_print_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_sizeof_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_typeof_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_yield_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_simple_name (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_member_access (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_genie_parser_parse_pointer_member_access (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_genie_parser_parse_method_call (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_genie_parser_parse_element_access (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_genie_parser_parse_post_increment_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_genie_parser_parse_post_decrement_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
ValaMemberAccess* vala_member_access_new (ValaExpression* inner, const char* member_name, ValaSourceReference* source_reference);
ValaMemberAccess* vala_member_access_construct (GType object_type, ValaExpression* inner, const char* member_name, ValaSourceReference* source_reference);
void vala_member_access_add_type_argument (ValaMemberAccess* self, ValaDataType* arg);
ValaTemplate* vala_template_new (ValaSourceReference* source_reference);
ValaTemplate* vala_template_construct (GType object_type, ValaSourceReference* source_reference);
void vala_template_add_expression (ValaTemplate* self, ValaExpression* expr);
void vala_code_node_set_source_reference (ValaCodeNode* self, ValaSourceReference* value);
ValaTuple* vala_tuple_new (ValaSourceReference* source_reference);
ValaTuple* vala_tuple_construct (GType object_type, ValaSourceReference* source_reference);
void vala_tuple_add_expression (ValaTuple* self, ValaExpression* expr);
ValaMemberAccess* vala_member_access_new_pointer (ValaExpression* inner, const char* member_name, ValaSourceReference* source_reference);
ValaMemberAccess* vala_member_access_construct_pointer (GType object_type, ValaExpression* inner, const char* member_name, ValaSourceReference* source_reference);
static ValaList* vala_genie_parser_parse_print_argument_list (ValaGenieParser* self, GError** error);
const char* vala_string_literal_get_value (ValaStringLiteral* self);
void vala_string_literal_set_value (ValaStringLiteral* self, const char* value);
GType vala_binary_operator_get_type (void) G_GNUC_CONST;
ValaBinaryExpression* vala_binary_expression_new (ValaBinaryOperator op, ValaExpression* _left, ValaExpression* _right, ValaSourceReference* source);
ValaBinaryExpression* vala_binary_expression_construct (GType object_type, ValaBinaryOperator op, ValaExpression* _left, ValaExpression* _right, ValaSourceReference* source);
ValaMethodCall* vala_method_call_new (ValaExpression* call, ValaSourceReference* source_reference);
ValaMethodCall* vala_method_call_construct (GType object_type, ValaExpression* call, ValaSourceReference* source_reference);
void vala_method_call_add_argument (ValaMethodCall* self, ValaExpression* arg);
GType vala_member_initializer_get_type (void) G_GNUC_CONST;
static ValaList* vala_genie_parser_parse_object_initializer (ValaGenieParser* self, GError** error);
void vala_member_access_set_creation_member (ValaMemberAccess* self, gboolean value);
ValaObjectCreationExpression* vala_object_creation_expression_new (ValaMemberAccess* member_name, ValaSourceReference* source_reference);
ValaObjectCreationExpression* vala_object_creation_expression_construct (GType object_type, ValaMemberAccess* member_name, ValaSourceReference* source_reference);
void vala_object_creation_expression_set_struct_creation (ValaObjectCreationExpression* self, gboolean value);
void vala_object_creation_expression_add_argument (ValaObjectCreationExpression* self, ValaExpression* arg);
void vala_object_creation_expression_add_member_initializer (ValaObjectCreationExpression* self, ValaMemberInitializer* init);
static ValaList* vala_genie_parser_parse_expression_list (ValaGenieParser* self, GError** error);
ValaElementAccess* vala_element_access_new (ValaExpression* container, ValaSourceReference* source_reference);
ValaElementAccess* vala_element_access_construct (GType object_type, ValaExpression* container, ValaSourceReference* source_reference);
void vala_element_access_append_index (ValaElementAccess* self, ValaExpression* index);
ValaSliceExpression* vala_slice_expression_new (ValaExpression* container, ValaExpression* start, ValaExpression* stop, ValaSourceReference* source_reference);
ValaSliceExpression* vala_slice_expression_construct (GType object_type, ValaExpression* container, ValaExpression* start, ValaExpression* stop, ValaSourceReference* source_reference);
ValaBaseAccess* vala_base_access_new (ValaSourceReference* source);
ValaBaseAccess* vala_base_access_construct (GType object_type, ValaSourceReference* source);
ValaPostfixExpression* vala_postfix_expression_new (ValaExpression* _inner, gboolean inc, ValaSourceReference* source);
ValaPostfixExpression* vala_postfix_expression_construct (GType object_type, ValaExpression* _inner, gboolean inc, ValaSourceReference* source);
static ValaExpression* vala_genie_parser_parse_array_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaDataType* element_type, GError** error);
static ValaExpression* vala_genie_parser_parse_list_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaDataType* element_type, GError** error);
static ValaExpression* vala_genie_parser_parse_dict_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaDataType* key_type, ValaDataType* value_type, GError** error);
static ValaMemberAccess* vala_genie_parser_parse_member_name (ValaGenieParser* self, ValaExpression* base_expr, GError** error);
static ValaExpression* vala_genie_parser_parse_object_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaMemberAccess* member, GError** error);
ValaDataType* vala_data_type_copy (ValaDataType* self);
ValaArrayCreationExpression* vala_array_creation_expression_new (ValaDataType* element_type, gint rank, ValaInitializerList* initializer_list, ValaSourceReference* source_reference);
ValaArrayCreationExpression* vala_array_creation_expression_construct (GType object_type, ValaDataType* element_type, gint rank, ValaInitializerList* initializer_list, ValaSourceReference* source_reference);
void vala_array_creation_expression_append_size (ValaArrayCreationExpression* self, ValaExpression* size);
static ValaMemberInitializer* vala_genie_parser_parse_member_initializer (ValaGenieParser* self, GError** error);
ValaMemberInitializer* vala_member_initializer_new (const char* name, ValaExpression* initializer, ValaSourceReference* source_reference);
ValaMemberInitializer* vala_member_initializer_construct (GType object_type, const char* name, ValaExpression* initializer, ValaSourceReference* source_reference);
void vala_method_call_set_is_yield_expression (ValaMethodCall* self, gboolean value);
ValaSizeofExpression* vala_sizeof_expression_new (ValaDataType* type, ValaSourceReference* source);
ValaSizeofExpression* vala_sizeof_expression_construct (GType object_type, ValaDataType* type, ValaSourceReference* source);
ValaTypeofExpression* vala_typeof_expression_new (ValaDataType* type, ValaSourceReference* source);
ValaTypeofExpression* vala_typeof_expression_construct (GType object_type, ValaDataType* type, ValaSourceReference* source);
static ValaUnaryOperator vala_genie_parser_get_unary_operator (ValaGenieParser* self, ValaGenieTokenType token_type);
static ValaExpression* vala_genie_parser_parse_unary_expression (ValaGenieParser* self, GError** error);
ValaReferenceTransferExpression* vala_reference_transfer_expression_new (ValaExpression* inner, ValaSourceReference* source_reference);
ValaReferenceTransferExpression* vala_reference_transfer_expression_construct (GType object_type, ValaExpression* inner, ValaSourceReference* source_reference);
ValaCastExpression* vala_cast_expression_new (ValaExpression* inner, ValaDataType* type_reference, ValaSourceReference* source_reference, gboolean is_silent_cast);
ValaCastExpression* vala_cast_expression_construct (GType object_type, ValaExpression* inner, ValaDataType* type_reference, ValaSourceReference* source_reference, gboolean is_silent_cast);
ValaCastExpression* vala_cast_expression_new_non_null (ValaExpression* inner, ValaSourceReference* source_reference);
ValaCastExpression* vala_cast_expression_construct_non_null (GType object_type, ValaExpression* inner, ValaSourceReference* source_reference);
ValaPointerIndirection* vala_pointer_indirection_new (ValaExpression* inner, ValaSourceReference* source_reference);
ValaPointerIndirection* vala_pointer_indirection_construct (GType object_type, ValaExpression* inner, ValaSourceReference* source_reference);
ValaAddressofExpression* vala_addressof_expression_new (ValaExpression* inner, ValaSourceReference* source_reference);
ValaAddressofExpression* vala_addressof_expression_construct (GType object_type, ValaExpression* inner, ValaSourceReference* source_reference);
static ValaBinaryOperator vala_genie_parser_get_binary_operator (ValaGenieParser* self, ValaGenieTokenType token_type);
static ValaExpression* vala_genie_parser_parse_multiplicative_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_additive_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_shift_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_relational_expression (ValaGenieParser* self, GError** error);
ValaTypeCheck* vala_typecheck_new (ValaExpression* expr, ValaDataType* type, ValaSourceReference* source);
ValaTypeCheck* vala_typecheck_construct (GType object_type, ValaExpression* expr, ValaDataType* type, ValaSourceReference* source);
static ValaExpression* vala_genie_parser_parse_equality_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_and_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_exclusive_or_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_inclusive_or_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_in_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_conditional_and_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_conditional_or_expression (ValaGenieParser* self, GError** error);
static ValaExpression* vala_genie_parser_parse_conditional_expression (ValaGenieParser* self, GError** error);
ValaConditionalExpression* vala_conditional_expression_new (ValaExpression* cond, ValaExpression* true_expr, ValaExpression* false_expr, ValaSourceReference* source);
ValaConditionalExpression* vala_conditional_expression_construct (GType object_type, ValaExpression* cond, ValaExpression* true_expr, ValaExpression* false_expr, ValaSourceReference* source);
static ValaExpression* vala_genie_parser_parse_lambda_expression (ValaGenieParser* self, GError** error);
static ValaBlock* vala_genie_parser_parse_block (ValaGenieParser* self, GError** error);
ValaLambdaExpression* vala_lambda_expression_new_with_statement_body (ValaBlock* statement_body, ValaSourceReference* source_reference);
ValaLambdaExpression* vala_lambda_expression_construct_with_statement_body (GType object_type, ValaBlock* statement_body, ValaSourceReference* source_reference);
ValaLambdaExpression* vala_lambda_expression_new (ValaExpression* expression_body, ValaSourceReference* source_reference);
ValaLambdaExpression* vala_lambda_expression_construct (GType object_type, ValaExpression* expression_body, ValaSourceReference* source_reference);
void vala_lambda_expression_add_parameter (ValaLambdaExpression* self, const char* param);
GType vala_assignment_operator_get_type (void) G_GNUC_CONST;
static ValaAssignmentOperator vala_genie_parser_get_assignment_operator (ValaGenieParser* self, ValaGenieTokenType token_type);
ValaAssignment* vala_assignment_new (ValaExpression* left, ValaExpression* right, ValaAssignmentOperator operator, ValaSourceReference* source_reference);
ValaAssignment* vala_assignment_construct (GType object_type, ValaExpression* left, ValaExpression* right, ValaAssignmentOperator operator, ValaSourceReference* source_reference);
GType vala_statement_get_type (void) G_GNUC_CONST;
static ValaStatement* vala_genie_parser_get_for_statement_type (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_foreach_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_for_statement (ValaGenieParser* self, GError** error);
static void vala_genie_parser_parse_statements (ValaGenieParser* self, ValaBlock* block, GError** error);
ValaComment* vala_genie_scanner_pop_comment (ValaGenieScanner* self);
ValaEmptyStatement* vala_empty_statement_new (ValaSourceReference* source);
ValaEmptyStatement* vala_empty_statement_construct (GType object_type, ValaSourceReference* source);
static ValaStatement* vala_genie_parser_parse_empty_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_expression_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_if_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_switch_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_while_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_do_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_break_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_continue_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_return_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_throw_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_try_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_lock_statement (ValaGenieParser* self, GError** error);
static ValaStatement* vala_genie_parser_parse_delete_statement (ValaGenieParser* self, GError** error);
static void vala_genie_parser_parse_local_variable_declarations (ValaGenieParser* self, ValaBlock* block, GError** error);
static ValaStatement* vala_genie_parser_parse_yield_statement (ValaGenieParser* self, GError** error);
static gboolean vala_genie_parser_is_expression (ValaGenieParser* self, GError** error);
void vala_block_add_statement (ValaBlock* self, ValaStatement* stmt);
static ValaGenieParserRecoveryState vala_genie_parser_recover (ValaGenieParser* self);
static ValaBlock* vala_genie_parser_parse_embedded_statement (ValaGenieParser* self, GError** error);
ValaBlock* vala_block_new (ValaSourceReference* source_reference);
ValaBlock* vala_block_construct (GType object_type, ValaSourceReference* source_reference);
static ValaStatement* vala_genie_parser_parse_embedded_statement_without_block (ValaGenieParser* self, GError** error);
GType vala_report_get_type (void) G_GNUC_CONST;
ValaReport* vala_code_context_get_report (ValaCodeContext* self);
gint vala_report_get_errors (ValaReport* self);
gint vala_source_reference_get_last_line (ValaSourceReference* self);
void vala_source_reference_set_last_line (ValaSourceReference* self, gint value);
gint vala_source_reference_get_last_column (ValaSourceReference* self);
void vala_source_reference_set_last_column (ValaSourceReference* self, gint value);
static void vala_genie_parser_add_local_var_variable (ValaGenieParser* self, ValaBlock* block, const char* id, GError** error);
static ValaLocalVariable* vala_genie_parser_parse_local_variable (ValaGenieParser* self, ValaDataType* variable_type, const char* id, GError** error);
ValaDeclarationStatement* vala_declaration_statement_new (ValaSymbol* declaration, ValaSourceReference* source_reference);
ValaDeclarationStatement* vala_declaration_statement_construct (GType object_type, ValaSymbol* declaration, ValaSourceReference* source_reference);
ValaLocalVariable* vala_local_variable_new (ValaDataType* variable_type, const char* name, ValaExpression* initializer, ValaSourceReference* source_reference);
ValaLocalVariable* vala_local_variable_construct (GType object_type, ValaDataType* variable_type, const char* name, ValaExpression* initializer, ValaSourceReference* source_reference);
static ValaExpression* vala_genie_parser_parse_statement_expression (ValaGenieParser* self, GError** error);
ValaExpressionStatement* vala_expression_statement_new (ValaExpression* expression, ValaSourceReference* source_reference);
ValaExpressionStatement* vala_expression_statement_construct (GType object_type, ValaExpression* expression, ValaSourceReference* source_reference);
ValaIfStatement* vala_if_statement_new (ValaExpression* cond, ValaBlock* true_stmt, ValaBlock* false_stmt, ValaSourceReference* source);
ValaIfStatement* vala_if_statement_construct (GType object_type, ValaExpression* cond, ValaBlock* true_stmt, ValaBlock* false_stmt, ValaSourceReference* source);
ValaSwitchStatement* vala_switch_statement_new (ValaExpression* expression, ValaSourceReference* source_reference);
ValaSwitchStatement* vala_switch_statement_construct (GType object_type, ValaExpression* expression, ValaSourceReference* source_reference);
ValaSwitchSection* vala_switch_section_new (ValaSourceReference* source_reference);
ValaSwitchSection* vala_switch_section_construct (GType object_type, ValaSourceReference* source_reference);
void vala_switch_section_add_label (ValaSwitchSection* self, ValaSwitchLabel* label);
ValaSwitchLabel* vala_switch_label_new (ValaExpression* expr, ValaSourceReference* source);
ValaSwitchLabel* vala_switch_label_construct (GType object_type, ValaExpression* expr, ValaSourceReference* source);
ValaSwitchLabel* vala_switch_label_new_with_default (ValaSourceReference* source);
ValaSwitchLabel* vala_switch_label_construct_with_default (GType object_type, ValaSourceReference* source);
ValaBreakStatement* vala_break_statement_new (ValaSourceReference* source);
ValaBreakStatement* vala_break_statement_construct (GType object_type, ValaSourceReference* source);
void vala_switch_statement_add_section (ValaSwitchStatement* self, ValaSwitchSection* section);
ValaWhileStatement* vala_while_statement_new (ValaExpression* condition, ValaBlock* body, ValaSourceReference* source_reference);
ValaWhileStatement* vala_while_statement_construct (GType object_type, ValaExpression* condition, ValaBlock* body, ValaSourceReference* source_reference);
ValaDoStatement* vala_do_statement_new (ValaBlock* body, ValaExpression* condition, ValaSourceReference* source_reference);
ValaDoStatement* vala_do_statement_construct (GType object_type, ValaBlock* body, ValaExpression* condition, ValaSourceReference* source_reference);
ValaForStatement* vala_for_statement_new (ValaExpression* condition, ValaBlock* body, ValaSourceReference* source_reference);
ValaForStatement* vala_for_statement_construct (GType object_type, ValaExpression* condition, ValaBlock* body, ValaSourceReference* source_reference);
void vala_for_statement_add_initializer (ValaForStatement* self, ValaExpression* init);
void vala_for_statement_add_iterator (ValaForStatement* self, ValaExpression* iter);
ValaForeachStatement* vala_foreach_statement_new (ValaDataType* type_reference, const char* variable_name, ValaExpression* collection, ValaBlock* body, ValaSourceReference* source_reference);
ValaForeachStatement* vala_foreach_statement_construct (GType object_type, ValaDataType* type_reference, const char* variable_name, ValaExpression* collection, ValaBlock* body, ValaSourceReference* source_reference);
ValaContinueStatement* vala_continue_statement_new (ValaSourceReference* source);
ValaContinueStatement* vala_continue_statement_construct (GType object_type, ValaSourceReference* source);
ValaReturnStatement* vala_return_statement_new (ValaExpression* return_expression, ValaSourceReference* source_reference);
ValaReturnStatement* vala_return_statement_construct (GType object_type, ValaExpression* return_expression, ValaSourceReference* source_reference);
ValaYieldStatement* vala_yield_statement_new (ValaExpression* yield_expression, ValaSourceReference* source_reference);
ValaYieldStatement* vala_yield_statement_construct (GType object_type, ValaExpression* yield_expression, ValaSourceReference* source_reference);
ValaThrowStatement* vala_throw_statement_new (ValaExpression* error_expression, ValaSourceReference* source_reference);
ValaThrowStatement* vala_throw_statement_construct (GType object_type, ValaExpression* error_expression, ValaSourceReference* source_reference);
static void vala_genie_parser_parse_catch_clauses (ValaGenieParser* self, ValaList* catch_clauses, GError** error);
static ValaBlock* vala_genie_parser_parse_finally_clause (ValaGenieParser* self, GError** error);
ValaTryStatement* vala_try_statement_new (ValaBlock* body, ValaBlock* finally_body, ValaSourceReference* source_reference);
ValaTryStatement* vala_try_statement_construct (GType object_type, ValaBlock* body, ValaBlock* finally_body, ValaSourceReference* source_reference);
void vala_try_statement_add_catch_clause (ValaTryStatement* self, ValaCatchClause* clause);
ValaCatchClause* vala_catch_clause_new (ValaDataType* error_type, const char* variable_name, ValaBlock* body, ValaSourceReference* source_reference);
ValaCatchClause* vala_catch_clause_construct (GType object_type, ValaDataType* error_type, const char* variable_name, ValaBlock* body, ValaSourceReference* source_reference);
ValaLockStatement* vala_lock_statement_new (ValaExpression* resource, ValaBlock* body, ValaSourceReference* source_reference);
ValaLockStatement* vala_lock_statement_construct (GType object_type, ValaExpression* resource, ValaBlock* body, ValaSourceReference* source_reference);
ValaDeleteStatement* vala_delete_statement_new (ValaExpression* expression, ValaSourceReference* source_reference);
ValaDeleteStatement* vala_delete_statement_construct (GType object_type, ValaExpression* expression, ValaSourceReference* source_reference);
GType vala_attribute_get_type (void) G_GNUC_CONST;
static ValaList* vala_genie_parser_parse_attributes (ValaGenieParser* self, GError** error);
ValaAttribute* vala_attribute_new (const char* name, ValaSourceReference* source_reference);
ValaAttribute* vala_attribute_construct (GType object_type, const char* name, ValaSourceReference* source_reference);
void vala_attribute_add_argument (ValaAttribute* self, const char* key, ValaExpression* value);
static void vala_genie_parser_set_attributes (ValaGenieParser* self, ValaCodeNode* node, ValaList* attributes);
GType vala_semantic_analyzer_get_type (void) G_GNUC_CONST;
GType vala_code_generator_get_type (void) G_GNUC_CONST;
static ValaSymbol* vala_genie_parser_parse_declaration (ValaGenieParser* self, gboolean is_root, GError** error);
static ValaConstant* vala_genie_parser_parse_constant_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaCreationMethod* vala_genie_parser_parse_creation_method_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_genie_parser_parse_class_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaMethod* vala_genie_parser_parse_main_method_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
GType vala_profile_get_type (void) G_GNUC_CONST;
ValaProfile vala_code_context_get_profile (ValaCodeContext* self);
static ValaConstructor* vala_genie_parser_parse_constructor_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_genie_parser_parse_delegate_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaMethod* vala_genie_parser_parse_method_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_genie_parser_parse_enum_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_genie_parser_parse_errordomain_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaDestructor* vala_genie_parser_parse_destructor_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_genie_parser_parse_interface_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaNamespace* vala_genie_parser_parse_namespace_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaProperty* vala_genie_parser_parse_property_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSignal* vala_genie_parser_parse_signal_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_genie_parser_parse_struct_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static ValaField* vala_genie_parser_parse_field_declaration (ValaGenieParser* self, ValaList* attrs, GError** error);
static void vala_genie_parser_parse_namespace_member (ValaGenieParser* self, ValaNamespace* ns, GError** error);
static void vala_genie_parser_parse_class_member (ValaGenieParser* self, ValaClass* cl, GError** error);
static void vala_genie_parser_parse_struct_member (ValaGenieParser* self, ValaStruct* st, GError** error);
static void vala_genie_parser_parse_interface_member (ValaGenieParser* self, ValaInterface* iface, GError** error);
const char* vala_symbol_get_name (ValaSymbol* self);
ValaNamespace* vala_namespace_new (const char* name, ValaSourceReference* source_reference);
ValaNamespace* vala_namespace_construct (GType object_type, const char* name, ValaSourceReference* source_reference);
void vala_namespace_add_comment (ValaNamespace* self, ValaComment* comment);
ValaUnresolvedSymbol* vala_unresolved_symbol_get_inner (ValaUnresolvedSymbol* self);
void vala_namespace_add_namespace (ValaNamespace* self, ValaNamespace* ns);
void vala_namespace_add_class (ValaNamespace* self, ValaClass* cl);
void vala_namespace_add_interface (ValaNamespace* self, ValaInterface* iface);
void vala_namespace_add_struct (ValaNamespace* self, ValaStruct* st);
void vala_namespace_add_enum (ValaNamespace* self, ValaEnum* en);
void vala_namespace_add_error_domain (ValaNamespace* self, ValaErrorDomain* edomain);
void vala_namespace_add_delegate (ValaNamespace* self, ValaDelegate* d);
GType member_binding_get_type (void) G_GNUC_CONST;
MemberBinding vala_method_get_binding (ValaMethod* self);
void vala_method_set_binding (ValaMethod* self, MemberBinding value);
void vala_namespace_add_method (ValaNamespace* self, ValaMethod* m);
MemberBinding vala_field_get_binding (ValaField* self);
void vala_field_set_binding (ValaField* self, MemberBinding value);
void vala_namespace_add_field (ValaNamespace* self, ValaField* f);
void vala_namespace_add_constant (ValaNamespace* self, ValaConstant* constant);
void vala_source_file_add_node (ValaSourceFile* self, ValaCodeNode* node);
static void vala_genie_parser_add_uses_clause (ValaGenieParser* self, ValaNamespace* ns, GError** error);
ValaUsingDirective* vala_using_directive_new (ValaSymbol* namespace_symbol, ValaSourceReference* source_reference);
ValaUsingDirective* vala_using_directive_construct (GType object_type, ValaSymbol* namespace_symbol, ValaSourceReference* source_reference);
void vala_source_file_add_using_directive (ValaSourceFile* self, ValaUsingDirective* ns);
void vala_namespace_add_using_directive (ValaNamespace* self, ValaUsingDirective* ns);
static ValaGenieParserModifierFlags vala_genie_parser_parse_type_declaration_modifiers (ValaGenieParser* self);
static ValaList* vala_genie_parser_parse_type_parameter_list (ValaGenieParser* self, GError** error);
ValaClass* vala_class_new (const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaClass* vala_class_construct (GType object_type, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_symbol_set_access (ValaSymbol* self, ValaSymbolAccessibility value);
void vala_class_set_is_abstract (ValaClass* self, gboolean value);
void vala_object_type_symbol_add_type_parameter (ValaObjectTypeSymbol* self, ValaTypeParameter* p);
void vala_class_add_base_type (ValaClass* self, ValaDataType* type);
gboolean vala_source_file_get_external_package (ValaSourceFile* self);
ValaMethod* vala_class_get_default_construction_method (ValaClass* self);
ValaCreationMethod* vala_creation_method_new (const char* class_name, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaCreationMethod* vala_creation_method_construct (GType object_type, const char* class_name, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_method_set_body (ValaMethod* self, ValaBlock* value);
void vala_class_add_method (ValaClass* self, ValaMethod* m);
void vala_class_add_class (ValaClass* self, ValaClass* cl);
void vala_class_add_struct (ValaClass* self, ValaStruct* st);
void vala_class_add_enum (ValaClass* self, ValaEnum* en);
void vala_class_add_delegate (ValaClass* self, ValaDelegate* d);
void vala_class_add_signal (ValaClass* self, ValaSignal* sig);
void vala_class_add_field (ValaClass* self, ValaField* f);
void vala_class_add_constant (ValaClass* self, ValaConstant* c);
void vala_class_add_property (ValaClass* self, ValaProperty* prop);
MemberBinding vala_constructor_get_binding (ValaConstructor* self);
ValaConstructor* vala_class_get_constructor (ValaClass* self);
void vala_class_set_constructor (ValaClass* self, ValaConstructor* value);
ValaConstructor* vala_class_get_class_constructor (ValaClass* self);
void vala_class_set_class_constructor (ValaClass* self, ValaConstructor* value);
ValaConstructor* vala_class_get_static_constructor (ValaClass* self);
void vala_class_set_static_constructor (ValaClass* self, ValaConstructor* value);
MemberBinding vala_destructor_get_binding (ValaDestructor* self);
ValaDestructor* vala_class_get_static_destructor (ValaClass* self);
void vala_class_set_static_destructor (ValaClass* self, ValaDestructor* value);
ValaDestructor* vala_class_get_class_destructor (ValaClass* self);
void vala_class_set_class_destructor (ValaClass* self, ValaDestructor* value);
ValaDestructor* vala_class_get_destructor (ValaClass* self);
void vala_class_set_destructor (ValaClass* self, ValaDestructor* value);
static ValaGenieParserModifierFlags vala_genie_parser_parse_member_declaration_modifiers (ValaGenieParser* self);
ValaDataType* vala_array_type_get_element_type (ValaArrayType* self);
ValaConstant* vala_constant_new (const char* name, ValaDataType* type_reference, ValaExpression* value, ValaSourceReference* source_reference, ValaComment* comment);
ValaConstant* vala_constant_construct (GType object_type, const char* name, ValaDataType* type_reference, ValaExpression* value, ValaSourceReference* source_reference, ValaComment* comment);
void vala_symbol_set_external (ValaSymbol* self, gboolean value);
void vala_symbol_set_hides (ValaSymbol* self, gboolean value);
ValaField* vala_field_new (const char* name, ValaDataType* variable_type, ValaExpression* initializer, ValaSourceReference* source_reference, ValaComment* comment);
ValaField* vala_field_construct (GType object_type, const char* name, ValaDataType* variable_type, ValaExpression* initializer, ValaSourceReference* source_reference, ValaComment* comment);
void vala_variable_set_initializer (ValaVariable* self, ValaExpression* value);
ValaInitializerList* vala_initializer_list_new (ValaSourceReference* source_reference);
ValaInitializerList* vala_initializer_list_construct (GType object_type, ValaSourceReference* source_reference);
void vala_initializer_list_append (ValaInitializerList* self, ValaExpression* expr);
ValaMethod* vala_method_new (const char* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
ValaMethod* vala_method_construct (GType object_type, const char* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
ValaFormalParameter* vala_formal_parameter_new (const char* name, ValaDataType* variable_type, ValaSourceReference* source_reference);
ValaFormalParameter* vala_formal_parameter_construct (GType object_type, const char* name, ValaDataType* variable_type, ValaSourceReference* source_reference);
void vala_method_add_parameter (ValaMethod* self, ValaFormalParameter* param);
static ValaFormalParameter* vala_genie_parser_parse_parameter (ValaGenieParser* self, GError** error);
void vala_method_add_type_parameter (ValaMethod* self, ValaTypeParameter* p);
void vala_code_node_add_error_type (ValaCodeNode* self, ValaDataType* error_type);
void vala_method_set_coroutine (ValaMethod* self, gboolean value);
void vala_method_set_is_abstract (ValaMethod* self, gboolean value);
void vala_method_set_is_virtual (ValaMethod* self, gboolean value);
void vala_method_set_overrides (ValaMethod* self, gboolean value);
gboolean vala_method_get_is_abstract (ValaMethod* self);
gboolean vala_method_get_is_virtual (ValaMethod* self);
gboolean vala_method_get_overrides (ValaMethod* self);
void vala_method_set_is_inline (ValaMethod* self, gboolean value);
void vala_method_add_precondition (ValaMethod* self, ValaExpression* precondition);
void vala_method_add_postcondition (ValaMethod* self, ValaExpression* postcondition);
ValaProperty* vala_property_new (const char* name, ValaDataType* property_type, ValaPropertyAccessor* get_accessor, ValaPropertyAccessor* set_accessor, ValaSourceReference* source_reference, ValaComment* comment);
ValaProperty* vala_property_construct (GType object_type, const char* name, ValaDataType* property_type, ValaPropertyAccessor* get_accessor, ValaPropertyAccessor* set_accessor, ValaSourceReference* source_reference, ValaComment* comment);
void vala_property_set_binding (ValaProperty* self, MemberBinding value);
void vala_property_set_is_abstract (ValaProperty* self, gboolean value);
void vala_property_set_is_virtual (ValaProperty* self, gboolean value);
void vala_property_set_overrides (ValaProperty* self, gboolean value);
void vala_property_set_initializer (ValaProperty* self, ValaExpression* value);
ValaPropertyAccessor* vala_property_get_get_accessor (ValaProperty* self);
ValaPropertyAccessor* vala_property_accessor_new (gboolean readable, gboolean writable, gboolean construction, ValaDataType* value_type, ValaBlock* body, ValaSourceReference* source_reference, ValaComment* comment);
ValaPropertyAccessor* vala_property_accessor_construct (GType object_type, gboolean readable, gboolean writable, gboolean construction, ValaDataType* value_type, ValaBlock* body, ValaSourceReference* source_reference, ValaComment* comment);
void vala_property_set_get_accessor (ValaProperty* self, ValaPropertyAccessor* value);
ValaPropertyAccessor* vala_property_get_set_accessor (ValaProperty* self);
void vala_property_set_set_accessor (ValaProperty* self, ValaPropertyAccessor* value);
gboolean vala_property_get_is_abstract (ValaProperty* self);
ValaBlock* vala_property_accessor_get_body (ValaPropertyAccessor* self);
ValaDataType* vala_property_get_property_type (ValaProperty* self);
ValaExpression* vala_property_get_initializer (ValaProperty* self);
void vala_property_set_field (ValaProperty* self, ValaField* value);
ValaField* vala_property_get_field (ValaProperty* self);
MemberBinding vala_property_get_binding (ValaProperty* self);
ValaSignal* vala_signal_new (const char* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
ValaSignal* vala_signal_construct (GType object_type, const char* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
void vala_signal_set_is_virtual (ValaSignal* self, gboolean value);
void vala_signal_add_parameter (ValaSignal* self, ValaFormalParameter* param);
void vala_signal_set_body (ValaSignal* self, ValaBlock* value);
ValaConstructor* vala_constructor_new (ValaSourceReference* source);
ValaConstructor* vala_constructor_construct (GType object_type, ValaSourceReference* source);
void vala_constructor_set_binding (ValaConstructor* self, MemberBinding value);
void vala_constructor_set_body (ValaConstructor* self, ValaBlock* value);
ValaDestructor* vala_destructor_new (ValaSourceReference* source_reference);
ValaDestructor* vala_destructor_construct (GType object_type, ValaSourceReference* source_reference);
void vala_destructor_set_body (ValaDestructor* self, ValaBlock* value);
ValaStruct* vala_struct_new (const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaStruct* vala_struct_construct (GType object_type, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_struct_add_type_parameter (ValaStruct* self, ValaTypeParameter* p);
void vala_struct_set_base_type (ValaStruct* self, ValaDataType* value);
void vala_struct_add_method (ValaStruct* self, ValaMethod* m);
void vala_struct_add_field (ValaStruct* self, ValaField* f);
void vala_struct_add_constant (ValaStruct* self, ValaConstant* c);
ValaInterface* vala_interface_new (const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaInterface* vala_interface_construct (GType object_type, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_interface_add_prerequisite (ValaInterface* self, ValaDataType* type);
void vala_interface_add_class (ValaInterface* self, ValaClass* cl);
void vala_interface_add_struct (ValaInterface* self, ValaStruct* st);
void vala_interface_add_enum (ValaInterface* self, ValaEnum* en);
void vala_interface_add_delegate (ValaInterface* self, ValaDelegate* d);
void vala_interface_add_method (ValaInterface* self, ValaMethod* m);
void vala_interface_add_signal (ValaInterface* self, ValaSignal* sig);
void vala_interface_add_field (ValaInterface* self, ValaField* f);
void vala_interface_add_constant (ValaInterface* self, ValaConstant* c);
void vala_interface_add_property (ValaInterface* self, ValaProperty* prop);
ValaEnum* vala_enum_new (const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaEnum* vala_enum_construct (GType object_type, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaEnumValue* vala_enum_value_new (const char* name, ValaExpression* value, ValaSourceReference* source_reference, ValaComment* comment);
ValaEnumValue* vala_enum_value_construct (GType object_type, const char* name, ValaExpression* value, ValaSourceReference* source_reference, ValaComment* comment);
void vala_enum_add_value (ValaEnum* self, ValaEnumValue* value);
ValaErrorDomain* vala_error_domain_new (const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaErrorDomain* vala_error_domain_construct (GType object_type, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaErrorCode* vala_error_code_new (const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaErrorCode* vala_error_code_construct (GType object_type, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_error_code_set_value (ValaErrorCode* self, ValaExpression* value);
void vala_error_domain_add_code (ValaErrorDomain* self, ValaErrorCode* ecode);
ValaFormalParameter* vala_formal_parameter_new_with_ellipsis (ValaSourceReference* source_reference);
ValaFormalParameter* vala_formal_parameter_construct_with_ellipsis (GType object_type, ValaSourceReference* source_reference);
GType vala_parameter_direction_get_type (void) G_GNUC_CONST;
void vala_formal_parameter_set_direction (ValaFormalParameter* self, ValaParameterDirection value);
void vala_formal_parameter_set_params_array (ValaFormalParameter* self, gboolean value);
ValaDelegate* vala_delegate_new (const char* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
ValaDelegate* vala_delegate_construct (GType object_type, const char* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
void vala_delegate_set_has_target (ValaDelegate* self, gboolean value);
void vala_delegate_add_type_parameter (ValaDelegate* self, ValaTypeParameter* p);
void vala_delegate_add_parameter (ValaDelegate* self, ValaFormalParameter* param);
ValaTypeParameter* vala_typeparameter_new (const char* name, ValaSourceReference* source_reference);
ValaTypeParameter* vala_typeparameter_construct (GType object_type, const char* name, ValaSourceReference* source_reference);
static void vala_genie_parser_finalize (ValaCodeVisitor* obj);
static int _vala_strcmp0 (const char * str1, const char * str2);



static GType vala_genie_parser_modifier_flags_get_type (void) {
	static volatile gsize vala_genie_parser_modifier_flags_type_id__volatile = 0;
	if (g_once_init_enter (&vala_genie_parser_modifier_flags_type_id__volatile)) {
		static const GEnumValue values[] = {{VALA_GENIE_PARSER_MODIFIER_FLAGS_NONE, "VALA_GENIE_PARSER_MODIFIER_FLAGS_NONE", "none"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT, "VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT", "abstract"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS, "VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS", "class"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN, "VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN", "extern"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_INLINE, "VALA_GENIE_PARSER_MODIFIER_FLAGS_INLINE", "inline"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW, "VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW", "new"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE, "VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE", "override"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC, "VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC", "static"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL, "VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL", "virtual"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE, "VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE", "private"}, {VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC, "VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC", "async"}, {0, NULL, NULL}};
		GType vala_genie_parser_modifier_flags_type_id;
		vala_genie_parser_modifier_flags_type_id = g_enum_register_static ("ValaGenieParserModifierFlags", values);
		g_once_init_leave (&vala_genie_parser_modifier_flags_type_id__volatile, vala_genie_parser_modifier_flags_type_id);
	}
	return vala_genie_parser_modifier_flags_type_id__volatile;
}


static GType vala_genie_parser_recovery_state_get_type (void) {
	static volatile gsize vala_genie_parser_recovery_state_type_id__volatile = 0;
	if (g_once_init_enter (&vala_genie_parser_recovery_state_type_id__volatile)) {
		static const GEnumValue values[] = {{VALA_GENIE_PARSER_RECOVERY_STATE_EOF, "VALA_GENIE_PARSER_RECOVERY_STATE_EOF", "eof"}, {VALA_GENIE_PARSER_RECOVERY_STATE_DECLARATION_BEGIN, "VALA_GENIE_PARSER_RECOVERY_STATE_DECLARATION_BEGIN", "declaration-begin"}, {VALA_GENIE_PARSER_RECOVERY_STATE_STATEMENT_BEGIN, "VALA_GENIE_PARSER_RECOVERY_STATE_STATEMENT_BEGIN", "statement-begin"}, {0, NULL, NULL}};
		GType vala_genie_parser_recovery_state_type_id;
		vala_genie_parser_recovery_state_type_id = g_enum_register_static ("ValaGenieParserRecoveryState", values);
		g_once_init_leave (&vala_genie_parser_recovery_state_type_id__volatile, vala_genie_parser_recovery_state_type_id);
	}
	return vala_genie_parser_recovery_state_type_id__volatile;
}


ValaGenieParser* vala_genie_parser_construct (GType object_type) {
	ValaGenieParser* self = NULL;
	ValaGenieParserTokenInfo* _tmp0_;
	char* _tmp1_;
	self = (ValaGenieParser*) vala_code_visitor_construct (object_type);
	self->priv->tokens = (_tmp0_ = g_new0 (ValaGenieParserTokenInfo, VALA_GENIE_PARSER_BUFFER_SIZE), self->priv->tokens = (g_free (self->priv->tokens), NULL), self->priv->tokens_length1 = VALA_GENIE_PARSER_BUFFER_SIZE, self->priv->_tokens_size_ = self->priv->tokens_length1, _tmp0_);
	self->priv->class_name = (_tmp1_ = NULL, _g_free0 (self->priv->class_name), _tmp1_);
	self->priv->current_expr_is_lambda = FALSE;
	return self;
}


ValaGenieParser* vala_genie_parser_new (void) {
	return vala_genie_parser_construct (VALA_GENIE_TYPE_PARSER);
}


/**
 * Parses all .gs source files in the specified code context and
 * builds a code tree.
 *
 * @param context a code context
 */
static gpointer _vala_code_context_ref0 (gpointer self) {
	return self ? vala_code_context_ref (self) : NULL;
}


void vala_genie_parser_parse (ValaGenieParser* self, ValaCodeContext* context) {
	ValaCodeContext* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	self->priv->context = (_tmp0_ = _vala_code_context_ref0 (context), _vala_code_context_unref0 (self->priv->context), _tmp0_);
	vala_code_context_accept (context, (ValaCodeVisitor*) self);
}


static void vala_genie_parser_real_visit_source_file (ValaCodeVisitor* base, ValaSourceFile* source_file) {
	ValaGenieParser * self;
	self = (ValaGenieParser*) base;
	g_return_if_fail (source_file != NULL);
	if (g_str_has_suffix (vala_source_file_get_filename (source_file), ".gs")) {
		vala_genie_parser_parse_file (self, source_file);
	}
}


static inline gboolean vala_genie_parser_next (ValaGenieParser* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	self->priv->index = (self->priv->index + 1) % VALA_GENIE_PARSER_BUFFER_SIZE;
	self->priv->size--;
	if (self->priv->size <= 0) {
		ValaSourceLocation begin = {0};
		ValaSourceLocation end = {0};
		ValaGenieTokenType type;
		type = vala_genie_scanner_read_token (self->priv->scanner, &begin, &end);
		self->priv->tokens[self->priv->index].type = type;
		self->priv->tokens[self->priv->index].begin = begin;
		self->priv->tokens[self->priv->index].end = end;
		self->priv->size = 1;
	}
	result = self->priv->tokens[self->priv->index].type != VALA_GENIE_TOKEN_TYPE_EOF;
	return result;
}


static inline void vala_genie_parser_prev (ValaGenieParser* self) {
	g_return_if_fail (self != NULL);
	self->priv->index = ((self->priv->index - 1) + VALA_GENIE_PARSER_BUFFER_SIZE) % VALA_GENIE_PARSER_BUFFER_SIZE;
	self->priv->size++;
	g_assert (self->priv->size <= VALA_GENIE_PARSER_BUFFER_SIZE);
}


static inline ValaGenieTokenType vala_genie_parser_current (ValaGenieParser* self) {
	ValaGenieTokenType result = 0;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->tokens[self->priv->index].type;
	return result;
}


static inline gboolean vala_genie_parser_accept (ValaGenieParser* self, ValaGenieTokenType type) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (vala_genie_parser_current (self) == type) {
		vala_genie_parser_next (self);
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static inline gboolean vala_genie_parser_accept_terminator (ValaGenieParser* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_SEMICOLON) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_EOL;
	}
	if (_tmp0_) {
		vala_genie_parser_next (self);
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static inline gboolean vala_genie_parser_accept_block (ValaGenieParser* self) {
	gboolean result = FALSE;
	gboolean has_term;
	g_return_val_if_fail (self != NULL, FALSE);
	has_term = vala_genie_parser_accept_terminator (self);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INDENT)) {
		vala_genie_parser_prev (self);
		result = TRUE;
		return result;
	}
	if (has_term) {
		vala_genie_parser_prev (self);
	}
	result = FALSE;
	return result;
}


static char* vala_genie_parser_get_error (ValaGenieParser* self, const char* msg) {
	char* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	char* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (msg != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_next (self);
	vala_report_error (_tmp1_ = vala_genie_parser_get_src (self, &begin), _tmp2_ = g_strconcat ("syntax error, ", msg, NULL));
	_g_free0 (_tmp2_);
	_vala_source_reference_unref0 (_tmp1_);
	result = g_strdup (msg);
	return result;
}


static inline gboolean vala_genie_parser_expect (ValaGenieParser* self, ValaGenieTokenType type, GError** error) {
	gboolean result = FALSE;
	ValaGenieTokenType cur;
	ValaGenieTokenType pre;
	char* _tmp0_;
	char* _tmp1_;
	GError* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	if (vala_genie_parser_accept (self, type)) {
		result = TRUE;
		return result;
	}
	cur = vala_genie_parser_current (self);
	pre = self->priv->tokens[self->priv->index - 1].type;
	_inner_error_ = (_tmp2_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp1_ = vala_genie_parser_get_error (self, _tmp0_ = g_strdup_printf ("expected %s but got %s with previous %s", vala_genie_token_type_to_string (type), vala_genie_token_type_to_string (cur), vala_genie_token_type_to_string (pre)))), _g_free0 (_tmp1_), _g_free0 (_tmp0_), _tmp2_);
	{
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
}


static inline gboolean vala_genie_parser_expect_terminator (ValaGenieParser* self, GError** error) {
	gboolean result = FALSE;
	ValaGenieTokenType cur;
	char* _tmp0_;
	char* _tmp1_;
	GError* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	if (vala_genie_parser_accept_terminator (self)) {
		result = TRUE;
		return result;
	}
	cur = vala_genie_parser_current (self);
	_inner_error_ = (_tmp2_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp1_ = vala_genie_parser_get_error (self, _tmp0_ = g_strdup_printf ("expected line end or semicolon but got %s", vala_genie_token_type_to_string (cur)))), _g_free0 (_tmp1_), _g_free0 (_tmp0_), _tmp2_);
	{
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
}


static inline void vala_genie_parser_get_location (ValaGenieParser* self, ValaSourceLocation* result) {
	g_return_if_fail (self != NULL);
	*result = self->priv->tokens[self->priv->index].begin;
	return;
}


static char* vala_genie_parser_get_current_string (ValaGenieParser* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = g_strndup ((const char*) self->priv->tokens[self->priv->index].begin.pos, self->priv->tokens[self->priv->index].end.pos - self->priv->tokens[self->priv->index].begin.pos);
	return result;
}


static char* vala_genie_parser_get_last_string (ValaGenieParser* self) {
	char* result = NULL;
	gint last_index;
	g_return_val_if_fail (self != NULL, NULL);
	last_index = ((self->priv->index + VALA_GENIE_PARSER_BUFFER_SIZE) - 1) % VALA_GENIE_PARSER_BUFFER_SIZE;
	result = g_strndup ((const char*) self->priv->tokens[last_index].begin.pos, self->priv->tokens[last_index].end.pos - self->priv->tokens[last_index].begin.pos);
	return result;
}


static ValaSourceReference* vala_genie_parser_get_src (ValaGenieParser* self, ValaSourceLocation* begin) {
	ValaSourceReference* result = NULL;
	gint last_index;
	g_return_val_if_fail (self != NULL, NULL);
	last_index = ((self->priv->index + VALA_GENIE_PARSER_BUFFER_SIZE) - 1) % VALA_GENIE_PARSER_BUFFER_SIZE;
	result = vala_source_reference_new (vala_genie_scanner_get_source_file (self->priv->scanner), (*begin).line, (*begin).column, self->priv->tokens[last_index].end.line, self->priv->tokens[last_index].end.column);
	return result;
}


static ValaSourceReference* vala_genie_parser_get_current_src (ValaGenieParser* self) {
	ValaSourceReference* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = vala_source_reference_new (vala_genie_scanner_get_source_file (self->priv->scanner), self->priv->tokens[self->priv->index].begin.line, self->priv->tokens[self->priv->index].begin.column, self->priv->tokens[self->priv->index].end.line, self->priv->tokens[self->priv->index].end.column);
	return result;
}


static void vala_genie_parser_rollback (ValaGenieParser* self, ValaSourceLocation* location) {
	g_return_if_fail (self != NULL);
	while (TRUE) {
		if (!(self->priv->tokens[self->priv->index].begin.pos != (*location).pos)) {
			break;
		}
		self->priv->index = ((self->priv->index - 1) + VALA_GENIE_PARSER_BUFFER_SIZE) % VALA_GENIE_PARSER_BUFFER_SIZE;
		self->priv->size++;
		if (self->priv->size > VALA_GENIE_PARSER_BUFFER_SIZE) {
			vala_genie_scanner_seek (self->priv->scanner, location);
			self->priv->size = 0;
			self->priv->index = 0;
			vala_genie_parser_next (self);
		}
	}
}


static inline ValaSymbolAccessibility vala_genie_parser_get_access (ValaGenieParser* self, const char* s) {
	ValaSymbolAccessibility result = 0;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (s != NULL, 0);
	if (g_utf8_get_char (g_utf8_offset_to_pointer (s, 0)) == '_') {
		result = VALA_SYMBOL_ACCESSIBILITY_PRIVATE;
		return result;
	}
	result = VALA_SYMBOL_ACCESSIBILITY_PUBLIC;
	return result;
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, (gssize) (-1));
	return result;
}


static gboolean string_contains (const char* self, const char* needle) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	result = strstr (self, needle) != NULL;
	return result;
}


static void vala_genie_parser_skip_identifier (ValaGenieParser* self, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	switch (vala_genie_parser_current (self)) {
		case VALA_GENIE_TOKEN_TYPE_ABSTRACT:
		case VALA_GENIE_TOKEN_TYPE_AS:
		case VALA_GENIE_TOKEN_TYPE_ASSERT:
		case VALA_GENIE_TOKEN_TYPE_ASYNC:
		case VALA_GENIE_TOKEN_TYPE_BREAK:
		case VALA_GENIE_TOKEN_TYPE_CLASS:
		case VALA_GENIE_TOKEN_TYPE_CONST:
		case VALA_GENIE_TOKEN_TYPE_CONTINUE:
		case VALA_GENIE_TOKEN_TYPE_DEDENT:
		case VALA_GENIE_TOKEN_TYPE_DEF:
		case VALA_GENIE_TOKEN_TYPE_DEFAULT:
		case VALA_GENIE_TOKEN_TYPE_DELEGATE:
		case VALA_GENIE_TOKEN_TYPE_DELETE:
		case VALA_GENIE_TOKEN_TYPE_DO:
		case VALA_GENIE_TOKEN_TYPE_DOWNTO:
		case VALA_GENIE_TOKEN_TYPE_DYNAMIC:
		case VALA_GENIE_TOKEN_TYPE_ELSE:
		case VALA_GENIE_TOKEN_TYPE_EOL:
		case VALA_GENIE_TOKEN_TYPE_ENUM:
		case VALA_GENIE_TOKEN_TYPE_ENSURES:
		case VALA_GENIE_TOKEN_TYPE_ERRORDOMAIN:
		case VALA_GENIE_TOKEN_TYPE_EVENT:
		case VALA_GENIE_TOKEN_TYPE_EXCEPT:
		case VALA_GENIE_TOKEN_TYPE_EXTERN:
		case VALA_GENIE_TOKEN_TYPE_FALSE:
		case VALA_GENIE_TOKEN_TYPE_FINAL:
		case VALA_GENIE_TOKEN_TYPE_FINALLY:
		case VALA_GENIE_TOKEN_TYPE_FOR:
		case VALA_GENIE_TOKEN_TYPE_GET:
		case VALA_GENIE_TOKEN_TYPE_IDENTIFIER:
		case VALA_GENIE_TOKEN_TYPE_IF:
		case VALA_GENIE_TOKEN_TYPE_IN:
		case VALA_GENIE_TOKEN_TYPE_INDENT:
		case VALA_GENIE_TOKEN_TYPE_INIT:
		case VALA_GENIE_TOKEN_TYPE_INLINE:
		case VALA_GENIE_TOKEN_TYPE_INTERFACE:
		case VALA_GENIE_TOKEN_TYPE_INTERNAL:
		case VALA_GENIE_TOKEN_TYPE_IS:
		case VALA_GENIE_TOKEN_TYPE_ISA:
		case VALA_GENIE_TOKEN_TYPE_LOCK:
		case VALA_GENIE_TOKEN_TYPE_NAMESPACE:
		case VALA_GENIE_TOKEN_TYPE_NEW:
		case VALA_GENIE_TOKEN_TYPE_NULL:
		case VALA_GENIE_TOKEN_TYPE_OF:
		case VALA_GENIE_TOKEN_TYPE_OUT:
		case VALA_GENIE_TOKEN_TYPE_OVERRIDE:
		case VALA_GENIE_TOKEN_TYPE_OWNED:
		case VALA_GENIE_TOKEN_TYPE_PASS:
		case VALA_GENIE_TOKEN_TYPE_PRINT:
		case VALA_GENIE_TOKEN_TYPE_PRIVATE:
		case VALA_GENIE_TOKEN_TYPE_PROP:
		case VALA_GENIE_TOKEN_TYPE_RAISE:
		case VALA_GENIE_TOKEN_TYPE_RAISES:
		case VALA_GENIE_TOKEN_TYPE_REF:
		case VALA_GENIE_TOKEN_TYPE_REQUIRES:
		case VALA_GENIE_TOKEN_TYPE_RETURN:
		case VALA_GENIE_TOKEN_TYPE_SET:
		case VALA_GENIE_TOKEN_TYPE_SIZEOF:
		case VALA_GENIE_TOKEN_TYPE_STATIC:
		case VALA_GENIE_TOKEN_TYPE_STRUCT:
		case VALA_GENIE_TOKEN_TYPE_SUPER:
		case VALA_GENIE_TOKEN_TYPE_THIS:
		case VALA_GENIE_TOKEN_TYPE_TO:
		case VALA_GENIE_TOKEN_TYPE_TRUE:
		case VALA_GENIE_TOKEN_TYPE_TRY:
		case VALA_GENIE_TOKEN_TYPE_TYPEOF:
		case VALA_GENIE_TOKEN_TYPE_UNOWNED:
		case VALA_GENIE_TOKEN_TYPE_USES:
		case VALA_GENIE_TOKEN_TYPE_VAR:
		case VALA_GENIE_TOKEN_TYPE_VIRTUAL:
		case VALA_GENIE_TOKEN_TYPE_VOID:
		case VALA_GENIE_TOKEN_TYPE_VOLATILE:
		case VALA_GENIE_TOKEN_TYPE_WEAK:
		case VALA_GENIE_TOKEN_TYPE_WHEN:
		case VALA_GENIE_TOKEN_TYPE_WHILE:
		case VALA_GENIE_TOKEN_TYPE_YIELD:
		{
			vala_genie_parser_next (self);
			return;
		}
		case VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_REAL_LITERAL:
		{
			char* id;
			gboolean _tmp0_ = FALSE;
			id = vala_genie_parser_get_current_string (self);
			if (g_unichar_isalpha (g_utf8_get_char (g_utf8_offset_to_pointer (id, string_get_length (id) - 1)))) {
				_tmp0_ = !string_contains (id, ".");
			} else {
				_tmp0_ = FALSE;
			}
			if (_tmp0_) {
				vala_genie_parser_next (self);
				_g_free0 (id);
				return;
			}
			_g_free0 (id);
			break;
		}
		default:
		{
			char* _tmp1_;
			GError* _tmp2_;
			_inner_error_ = (_tmp2_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp1_ = vala_genie_parser_get_error (self, "expected identifier")), _g_free0 (_tmp1_), _tmp2_);
			{
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


static char* vala_genie_parser_parse_identifier (ValaGenieParser* self, GError** error) {
	char* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_skip_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = vala_genie_parser_get_last_string (self);
	return result;
}


static char* string_substring (const char* self, glong offset, glong len) {
	char* result = NULL;
	glong string_length;
	const char* start;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = string_get_length (self);
	if (offset < 0) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= 0, NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < 0) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	start = g_utf8_offset_to_pointer (self, offset);
	result = g_strndup (start, ((gchar*) g_utf8_offset_to_pointer (start, len)) - ((gchar*) start));
	return result;
}


static ValaExpression* vala_genie_parser_parse_literal (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	switch (vala_genie_parser_current (self)) {
		case VALA_GENIE_TOKEN_TYPE_TRUE:
		{
			ValaSourceReference* _tmp1_;
			ValaExpression* _tmp2_;
			vala_genie_parser_next (self);
			result = (_tmp2_ = (ValaExpression*) vala_boolean_literal_new (TRUE, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_FALSE:
		{
			ValaSourceReference* _tmp3_;
			ValaExpression* _tmp4_;
			vala_genie_parser_next (self);
			result = (_tmp4_ = (ValaExpression*) vala_boolean_literal_new (FALSE, _tmp3_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL:
		{
			char* _tmp5_;
			ValaSourceReference* _tmp6_;
			ValaExpression* _tmp7_;
			vala_genie_parser_next (self);
			result = (_tmp7_ = (ValaExpression*) vala_integer_literal_new (_tmp5_ = vala_genie_parser_get_last_string (self), _tmp6_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp6_), _g_free0 (_tmp5_), _tmp7_);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_REAL_LITERAL:
		{
			char* _tmp8_;
			ValaSourceReference* _tmp9_;
			ValaExpression* _tmp10_;
			vala_genie_parser_next (self);
			result = (_tmp10_ = (ValaExpression*) vala_real_literal_new (_tmp8_ = vala_genie_parser_get_last_string (self), _tmp9_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp9_), _g_free0 (_tmp8_), _tmp10_);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_CHARACTER_LITERAL:
		{
			char* _tmp11_;
			ValaSourceReference* _tmp12_;
			ValaCharacterLiteral* _tmp13_;
			ValaCharacterLiteral* lit;
			vala_genie_parser_next (self);
			lit = (_tmp13_ = vala_character_literal_new (_tmp11_ = vala_genie_parser_get_last_string (self), _tmp12_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp12_), _g_free0 (_tmp11_), _tmp13_);
			if (vala_code_node_get_error ((ValaCodeNode*) lit)) {
				vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) lit), "invalid character literal");
			}
			result = (ValaExpression*) lit;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_REGEX_LITERAL:
		{
			char* match_part;
			ValaSourceReference* src_begin;
			char* close_token;
			char* _tmp14_;
			ValaExpression* _tmp15_;
			vala_genie_parser_next (self);
			match_part = vala_genie_parser_get_last_string (self);
			src_begin = vala_genie_parser_get_src (self, &begin);
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_REGEX_LITERAL, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_source_reference_unref0 (src_begin);
					_g_free0 (match_part);
					return NULL;
				} else {
					_vala_source_reference_unref0 (src_begin);
					_g_free0 (match_part);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			close_token = vala_genie_parser_get_last_string (self);
			result = (_tmp15_ = (ValaExpression*) vala_regex_literal_new (_tmp14_ = g_strdup_printf ("%s/%s", close_token, match_part), src_begin), _g_free0 (_tmp14_), _tmp15_);
			_g_free0 (close_token);
			_vala_source_reference_unref0 (src_begin);
			_g_free0 (match_part);
			return result;
			_g_free0 (close_token);
			_vala_source_reference_unref0 (src_begin);
			_g_free0 (match_part);
		}
		case VALA_GENIE_TOKEN_TYPE_STRING_LITERAL:
		{
			char* _tmp16_;
			ValaSourceReference* _tmp17_;
			ValaExpression* _tmp18_;
			vala_genie_parser_next (self);
			result = (_tmp18_ = (ValaExpression*) vala_string_literal_new (_tmp16_ = vala_genie_parser_get_last_string (self), _tmp17_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp17_), _g_free0 (_tmp16_), _tmp18_);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_TEMPLATE_STRING_LITERAL:
		{
			char* _tmp19_;
			char* _tmp20_;
			ValaSourceReference* _tmp21_;
			ValaExpression* _tmp22_;
			vala_genie_parser_next (self);
			result = (_tmp22_ = (ValaExpression*) vala_string_literal_new (_tmp20_ = g_strdup_printf ("\"%s\"", _tmp19_ = vala_genie_parser_get_last_string (self)), _tmp21_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp21_), _g_free0 (_tmp20_), _g_free0 (_tmp19_), _tmp22_);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_VERBATIM_STRING_LITERAL:
		{
			char* raw_string;
			char* _tmp23_;
			char* _tmp24_;
			char* escaped_string;
			char* _tmp25_;
			ValaSourceReference* _tmp26_;
			ValaExpression* _tmp27_;
			vala_genie_parser_next (self);
			raw_string = vala_genie_parser_get_last_string (self);
			escaped_string = (_tmp24_ = g_strescape (_tmp23_ = string_substring (raw_string, (glong) 3, string_get_length (raw_string) - 6), ""), _g_free0 (_tmp23_), _tmp24_);
			result = (_tmp27_ = (ValaExpression*) vala_string_literal_new (_tmp25_ = g_strdup_printf ("\"%s\"", escaped_string), _tmp26_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp26_), _g_free0 (_tmp25_), _tmp27_);
			_g_free0 (escaped_string);
			_g_free0 (raw_string);
			return result;
			_g_free0 (escaped_string);
			_g_free0 (raw_string);
		}
		case VALA_GENIE_TOKEN_TYPE_NULL:
		{
			ValaSourceReference* _tmp28_;
			ValaExpression* _tmp29_;
			vala_genie_parser_next (self);
			result = (_tmp29_ = (ValaExpression*) vala_null_literal_new (_tmp28_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp28_), _tmp29_);
			return result;
		}
		default:
		{
			char* _tmp30_;
			GError* _tmp31_;
			_inner_error_ = (_tmp31_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp30_ = vala_genie_parser_get_error (self, "expected literal")), _g_free0 (_tmp30_), _tmp31_);
			{
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	}
}


void vala_genie_parser_parse_file (ValaGenieParser* self, ValaSourceFile* source_file) {
	ValaGenieScanner* _tmp0_;
	ValaGenieScanner* _tmp3_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source_file != NULL);
	self->priv->scanner = (_tmp0_ = vala_genie_scanner_new (source_file), _vala_genie_scanner_unref0 (self->priv->scanner), _tmp0_);
	vala_genie_scanner_parse_file_comments (self->priv->scanner);
	vala_genie_scanner_set_indent_spaces (self->priv->scanner, 0);
	self->priv->index = -1;
	self->priv->size = 0;
	vala_genie_parser_next (self);
	{
		ValaSourceLocation _tmp1_ = {0};
		ValaSourceLocation begin;
		begin = (vala_genie_parser_get_location (self, &_tmp1_), _tmp1_);
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET)) {
			char* id;
			id = vala_genie_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					goto __catch1_vala_parse_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
			if (_vala_strcmp0 (id, "indent") == 0) {
				char* _tmp2_;
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_ASSIGN, &_inner_error_);
				if (_inner_error_ != NULL) {
					_g_free0 (id);
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						goto __catch1_vala_parse_error;
					}
					_g_free0 (id);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL, &_inner_error_);
				if (_inner_error_ != NULL) {
					_g_free0 (id);
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						goto __catch1_vala_parse_error;
					}
					_g_free0 (id);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				vala_genie_scanner_set_indent_spaces (self->priv->scanner, atoi (_tmp2_ = vala_genie_parser_get_last_string (self)));
				_g_free0 (_tmp2_);
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
				if (_inner_error_ != NULL) {
					_g_free0 (id);
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						goto __catch1_vala_parse_error;
					}
					_g_free0 (id);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
				if (_inner_error_ != NULL) {
					_g_free0 (id);
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						goto __catch1_vala_parse_error;
					}
					_g_free0 (id);
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			} else {
				vala_genie_parser_rollback (self, &begin);
			}
			_g_free0 (id);
		}
		vala_genie_parser_parse_using_directives (self, vala_code_context_get_root (self->priv->context), &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				goto __catch1_vala_parse_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		vala_genie_parser_parse_declarations (self, (ValaSymbol*) vala_code_context_get_root (self->priv->context), TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				goto __catch1_vala_parse_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	goto __finally1;
	__catch1_vala_parse_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	self->priv->scanner = (_tmp3_ = NULL, _vala_genie_scanner_unref0 (self->priv->scanner), _tmp3_);
}


static void vala_genie_parser_skip_symbol_name (ValaGenieParser* self, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		gboolean _tmp0_;
		_tmp0_ = TRUE;
		while (TRUE) {
			if (!_tmp0_) {
				if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DOT)) {
					break;
				}
			}
			_tmp0_ = FALSE;
			vala_genie_parser_skip_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


static ValaUnresolvedSymbol* vala_genie_parser_parse_symbol_name (ValaGenieParser* self, GError** error) {
	ValaUnresolvedSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaUnresolvedSymbol* sym;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	sym = NULL;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			char* name;
			ValaSourceReference* _tmp2_;
			ValaUnresolvedSymbol* _tmp3_;
			if (!_tmp1_) {
				if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DOT)) {
					break;
				}
			}
			_tmp1_ = FALSE;
			name = vala_genie_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			sym = (_tmp3_ = vala_unresolved_symbol_new (sym, name, _tmp2_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (sym), _tmp3_);
			_vala_source_reference_unref0 (_tmp2_);
			_g_free0 (name);
		}
	}
	result = sym;
	return result;
}


static void vala_genie_parser_skip_type (ValaGenieParser* self, GError** error) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_VOID)) {
		while (TRUE) {
			if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_STAR)) {
				break;
			}
		}
		return;
	}
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DYNAMIC);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OWNED);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_UNOWNED);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_WEAK);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ARRAY)) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_LIST);
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DICT);
	}
	if (_tmp0_) {
		vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OF);
	}
	vala_genie_parser_skip_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	vala_genie_parser_skip_type_argument_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	while (TRUE) {
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET)) {
			break;
		}
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				gboolean _tmp3_ = FALSE;
				if (!_tmp2_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp2_ = FALSE;
				if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_COMMA) {
					_tmp3_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET;
				} else {
					_tmp3_ = FALSE;
				}
				if (_tmp3_) {
					ValaExpression* _tmp4_;
					_tmp4_ = vala_genie_parser_parse_expression (self, &_inner_error_);
					_vala_code_node_unref0 (_tmp4_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							return;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
				}
			}
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OP_NEG);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INTERR);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_HASH);
}


static ValaExpression* vala_genie_parser_parse_regex_literal (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_REGEX_LITERAL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = vala_genie_parser_parse_literal (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = expr;
	return result;
}


static gpointer _vala_code_node_ref0 (gpointer self) {
	return self ? vala_code_node_ref (self) : NULL;
}


static ValaDataType* vala_genie_parser_parse_type (ValaGenieParser* self, gboolean owned_by_default, GError** error) {
	ValaDataType* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaList* type_arg_list;
	ValaUnresolvedSymbol* sym;
	gboolean is_dynamic;
	gboolean value_owned;
	gboolean is_array;
	gboolean is_list;
	gboolean is_dict;
	ValaList* _tmp13_;
	ValaList* _tmp14_;
	ValaSourceReference* _tmp15_;
	ValaDataType* _tmp16_;
	ValaDataType* type;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_VOID)) {
		ValaDataType* type;
		type = (ValaDataType*) vala_void_type_new (NULL);
		while (TRUE) {
			ValaDataType* _tmp1_;
			if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_STAR)) {
				break;
			}
			type = (_tmp1_ = (ValaDataType*) vala_pointer_type_new (type, NULL), _vala_code_node_unref0 (type), _tmp1_);
		}
		result = type;
		return result;
	}
	type_arg_list = NULL;
	sym = NULL;
	is_dynamic = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DYNAMIC);
	value_owned = owned_by_default;
	if (owned_by_default) {
		gboolean _tmp2_ = FALSE;
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_UNOWNED)) {
			_tmp2_ = TRUE;
		} else {
			_tmp2_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_WEAK);
		}
		if (_tmp2_) {
			value_owned = FALSE;
		}
	} else {
		value_owned = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OWNED);
	}
	is_array = FALSE;
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ARRAY)) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OF, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sym);
				_vala_collection_object_unref0 (type_arg_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (sym);
				_vala_collection_object_unref0 (type_arg_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		is_array = TRUE;
	}
	is_list = FALSE;
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_LIST)) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OF, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sym);
				_vala_collection_object_unref0 (type_arg_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (sym);
				_vala_collection_object_unref0 (type_arg_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_genie_parser_prev (self);
		is_list = TRUE;
	}
	is_dict = FALSE;
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DICT)) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OF, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sym);
				_vala_collection_object_unref0 (type_arg_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (sym);
				_vala_collection_object_unref0 (type_arg_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_genie_parser_prev (self);
		is_dict = TRUE;
	}
	if (is_list) {
		ValaSourceReference* _tmp3_;
		ValaUnresolvedSymbol* _tmp4_;
		ValaUnresolvedSymbol* sym_parent;
		ValaSourceReference* _tmp5_;
		ValaUnresolvedSymbol* _tmp6_;
		sym_parent = (_tmp4_ = vala_unresolved_symbol_new (NULL, "Gee", _tmp3_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
		sym = (_tmp6_ = vala_unresolved_symbol_new (sym_parent, "ArrayList", _tmp5_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (sym), _tmp6_);
		_vala_source_reference_unref0 (_tmp5_);
		_vala_code_node_unref0 (sym_parent);
	} else {
		if (is_dict) {
			ValaSourceReference* _tmp7_;
			ValaUnresolvedSymbol* _tmp8_;
			ValaUnresolvedSymbol* sym_parent;
			ValaSourceReference* _tmp9_;
			ValaUnresolvedSymbol* _tmp10_;
			sym_parent = (_tmp8_ = vala_unresolved_symbol_new (NULL, "Gee", _tmp7_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp7_), _tmp8_);
			sym = (_tmp10_ = vala_unresolved_symbol_new (sym_parent, "HashMap", _tmp9_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (sym), _tmp10_);
			_vala_source_reference_unref0 (_tmp9_);
			_vala_code_node_unref0 (sym_parent);
		} else {
			ValaUnresolvedSymbol* _tmp11_;
			ValaUnresolvedSymbol* _tmp12_;
			_tmp11_ = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (sym);
					_vala_collection_object_unref0 (type_arg_list);
					return NULL;
				} else {
					_vala_code_node_unref0 (sym);
					_vala_collection_object_unref0 (type_arg_list);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			sym = (_tmp12_ = _tmp11_, _vala_code_node_unref0 (sym), _tmp12_);
		}
	}
	_tmp13_ = vala_genie_parser_parse_type_argument_list (self, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			_vala_collection_object_unref0 (type_arg_list);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			_vala_collection_object_unref0 (type_arg_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_arg_list = (_tmp14_ = _tmp13_, _vala_collection_object_unref0 (type_arg_list), _tmp14_);
	type = (_tmp16_ = (ValaDataType*) vala_unresolved_type_new_from_symbol (sym, _tmp15_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp15_), _tmp16_);
	if (type_arg_list != NULL) {
		{
			ValaIterator* _type_arg_it;
			_type_arg_it = vala_iterable_iterator ((ValaIterable*) type_arg_list);
			while (TRUE) {
				ValaDataType* type_arg;
				if (!vala_iterator_next (_type_arg_it)) {
					break;
				}
				type_arg = (ValaDataType*) vala_iterator_get (_type_arg_it);
				vala_data_type_add_type_argument (type, type_arg);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_collection_object_unref0 (_type_arg_it);
		}
	}
	while (TRUE) {
		ValaSourceReference* _tmp17_;
		ValaDataType* _tmp18_;
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_STAR)) {
			break;
		}
		type = (_tmp18_ = (ValaDataType*) vala_pointer_type_new (type, _tmp17_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (type), _tmp18_);
		_vala_source_reference_unref0 (_tmp17_);
	}
	if (!VALA_IS_POINTER_TYPE (type)) {
		vala_data_type_set_nullable (type, vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INTERR));
	}
	if (is_array) {
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET)) {
			ValaSourceReference* _tmp19_;
			ValaDataType* _tmp20_;
			vala_data_type_set_value_owned (type, TRUE);
			type = (_tmp20_ = (ValaDataType*) vala_array_type_new (type, 1, _tmp19_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (type), _tmp20_);
			_vala_source_reference_unref0 (_tmp19_);
			vala_data_type_set_nullable (type, vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INTERR));
		} else {
			vala_genie_parser_prev (self);
			while (TRUE) {
				gboolean invalid_array;
				gint array_rank;
				ValaSourceReference* _tmp24_;
				ValaArrayType* _tmp25_;
				ValaArrayType* array_type;
				ValaDataType* _tmp26_;
				if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET)) {
					break;
				}
				invalid_array = FALSE;
				array_rank = 0;
				{
					gboolean _tmp21_;
					_tmp21_ = TRUE;
					while (TRUE) {
						gboolean _tmp22_ = FALSE;
						if (!_tmp21_) {
							if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
								break;
							}
						}
						_tmp21_ = FALSE;
						array_rank++;
						if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_COMMA) {
							_tmp22_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET;
						} else {
							_tmp22_ = FALSE;
						}
						if (_tmp22_) {
							ValaExpression* _tmp23_;
							_tmp23_ = vala_genie_parser_parse_expression (self, &_inner_error_);
							_vala_code_node_unref0 (_tmp23_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									g_propagate_error (error, _inner_error_);
									_vala_code_node_unref0 (type);
									_vala_code_node_unref0 (sym);
									_vala_collection_object_unref0 (type_arg_list);
									return NULL;
								} else {
									_vala_code_node_unref0 (type);
									_vala_code_node_unref0 (sym);
									_vala_collection_object_unref0 (type_arg_list);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return NULL;
								}
							}
							invalid_array = TRUE;
						}
					}
				}
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (type);
						_vala_code_node_unref0 (sym);
						_vala_collection_object_unref0 (type_arg_list);
						return NULL;
					} else {
						_vala_code_node_unref0 (type);
						_vala_code_node_unref0 (sym);
						_vala_collection_object_unref0 (type_arg_list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_data_type_set_value_owned (type, TRUE);
				array_type = (_tmp25_ = vala_array_type_new (type, array_rank, _tmp24_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp24_), _tmp25_);
				vala_data_type_set_nullable ((ValaDataType*) array_type, vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INTERR));
				vala_array_type_set_invalid_syntax (array_type, invalid_array);
				type = (_tmp26_ = _vala_code_node_ref0 ((ValaDataType*) array_type), _vala_code_node_unref0 (type), _tmp26_);
				_vala_code_node_unref0 (array_type);
			}
		}
	}
	if (!owned_by_default) {
		value_owned = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_HASH);
	}
	vala_data_type_set_is_dynamic (type, is_dynamic);
	vala_data_type_set_value_owned (type, value_owned);
	result = type;
	_vala_code_node_unref0 (sym);
	_vala_collection_object_unref0 (type_arg_list);
	return result;
}


static ValaDataType* vala_genie_parser_parse_inline_array_type (ValaGenieParser* self, ValaDataType* type, GError** error) {
	ValaDataType* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	gboolean _tmp1_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	if (type != NULL) {
		_tmp1_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		gint array_length;
		ValaSourceReference* _tmp5_;
		ValaArrayType* _tmp6_;
		ValaArrayType* array_type;
		array_length = -1;
		if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET) {
			ValaExpression* _tmp4_;
			ValaIntegerLiteral* length_literal;
			if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL) {
				char* _tmp2_;
				GError* _tmp3_;
				_inner_error_ = (_tmp3_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp2_ = vala_genie_parser_get_error (self, "expected `]' or integer literal")), _g_free0 (_tmp2_), _tmp3_);
				{
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return NULL;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
			_tmp4_ = vala_genie_parser_parse_literal (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			length_literal = VALA_INTEGER_LITERAL (_tmp4_);
			array_length = atoi (vala_integer_literal_get_value (length_literal));
			_vala_code_node_unref0 (length_literal);
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		array_type = (_tmp6_ = vala_array_type_new (type, 1, _tmp5_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp5_), _tmp6_);
		vala_array_type_set_inline_allocated (array_type, TRUE);
		if (array_length > 0) {
			vala_array_type_set_fixed_length (array_type, TRUE);
			vala_array_type_set_length (array_type, array_length);
		}
		result = (ValaDataType*) array_type;
		return result;
	}
	result = _vala_code_node_ref0 (type);
	return result;
}


static ValaList* vala_genie_parser_parse_argument_list (ValaGenieParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	list = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				ValaExpression* _tmp1_;
				ValaExpression* _tmp2_;
				if (!_tmp0_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				_tmp1_ = vala_genie_parser_parse_argument (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (list);
						return NULL;
					} else {
						_vala_collection_object_unref0 (list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) list, _tmp2_ = _tmp1_);
				_vala_code_node_unref0 (_tmp2_);
			}
		}
	}
	result = (ValaList*) list;
	return result;
}


static ValaExpression* vala_genie_parser_parse_argument (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_REF)) {
		ValaExpression* inner;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		inner = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = (_tmp2_ = (ValaExpression*) vala_unary_expression_new (VALA_UNARY_OPERATOR_REF, inner, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
		_vala_code_node_unref0 (inner);
		return result;
		_vala_code_node_unref0 (inner);
	} else {
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OUT)) {
			ValaExpression* inner;
			ValaSourceReference* _tmp3_;
			ValaExpression* _tmp4_;
			inner = vala_genie_parser_parse_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (_tmp4_ = (ValaExpression*) vala_unary_expression_new (VALA_UNARY_OPERATOR_OUT, inner, _tmp3_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
			_vala_code_node_unref0 (inner);
			return result;
			_vala_code_node_unref0 (inner);
		} else {
			ValaExpression* expr;
			ValaExpression* _tmp5_;
			ValaMemberAccess* ma;
			gboolean _tmp6_ = FALSE;
			gboolean _tmp7_ = FALSE;
			expr = vala_genie_parser_parse_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			ma = _vala_code_node_ref0 ((_tmp5_ = expr, VALA_IS_MEMBER_ACCESS (_tmp5_) ? ((ValaMemberAccess*) _tmp5_) : NULL));
			if (ma != NULL) {
				_tmp7_ = vala_member_access_get_inner (ma) == NULL;
			} else {
				_tmp7_ = FALSE;
			}
			if (_tmp7_) {
				_tmp6_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON);
			} else {
				_tmp6_ = FALSE;
			}
			if (_tmp6_) {
				ValaExpression* _tmp8_;
				ValaExpression* _tmp9_;
				ValaSourceReference* _tmp10_;
				ValaExpression* _tmp11_;
				_tmp8_ = vala_genie_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (ma);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (ma);
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp9_ = _tmp8_, _vala_code_node_unref0 (expr), _tmp9_);
				result = (_tmp11_ = (ValaExpression*) vala_named_argument_new (vala_member_access_get_member_name (ma), expr, _tmp10_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp10_), _tmp11_);
				_vala_code_node_unref0 (ma);
				_vala_code_node_unref0 (expr);
				return result;
			} else {
				result = expr;
				_vala_code_node_unref0 (ma);
				return result;
			}
			_vala_code_node_unref0 (ma);
			_vala_code_node_unref0 (expr);
		}
	}
}


static ValaExpression* vala_genie_parser_parse_primary_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	gboolean found;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	expr = NULL;
	switch (vala_genie_parser_current (self)) {
		case VALA_GENIE_TOKEN_TYPE_TRUE:
		case VALA_GENIE_TOKEN_TYPE_FALSE:
		case VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_REAL_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_CHARACTER_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_REGEX_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_STRING_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_TEMPLATE_STRING_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_VERBATIM_STRING_LITERAL:
		case VALA_GENIE_TOKEN_TYPE_NULL:
		{
			ValaExpression* _tmp1_;
			ValaExpression* _tmp2_;
			_tmp1_ = vala_genie_parser_parse_literal (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (expr), _tmp2_);
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSERT:
		{
			ValaExpression* _tmp3_;
			_tmp3_ = vala_genie_parser_parse_assert_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp3_;
			_vala_code_node_unref0 (expr);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OPEN_BRACE:
		{
			ValaInitializerList* _tmp4_;
			ValaExpression* _tmp5_;
			_tmp4_ = vala_genie_parser_parse_initializer (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp5_ = (ValaExpression*) _tmp4_, _vala_code_node_unref0 (expr), _tmp5_);
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
		{
			ValaExpression* _tmp6_;
			ValaExpression* _tmp7_;
			_tmp6_ = vala_genie_parser_parse_tuple (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp7_ = _tmp6_, _vala_code_node_unref0 (expr), _tmp7_);
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_OPEN_REGEX_LITERAL:
		{
			ValaExpression* _tmp8_;
			ValaExpression* _tmp9_;
			_tmp8_ = vala_genie_parser_parse_regex_literal (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp9_ = _tmp8_, _vala_code_node_unref0 (expr), _tmp9_);
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_OPEN_TEMPLATE:
		{
			ValaExpression* _tmp10_;
			ValaExpression* _tmp11_;
			_tmp10_ = vala_genie_parser_parse_template (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp11_ = _tmp10_, _vala_code_node_unref0 (expr), _tmp11_);
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_THIS:
		{
			ValaExpression* _tmp12_;
			ValaExpression* _tmp13_;
			_tmp12_ = vala_genie_parser_parse_this_access (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp13_ = _tmp12_, _vala_code_node_unref0 (expr), _tmp13_);
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_SUPER:
		{
			ValaExpression* _tmp14_;
			ValaExpression* _tmp15_;
			_tmp14_ = vala_genie_parser_parse_base_access (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp15_ = _tmp14_, _vala_code_node_unref0 (expr), _tmp15_);
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_NEW:
		{
			ValaExpression* _tmp16_;
			ValaExpression* _tmp17_;
			_tmp16_ = vala_genie_parser_parse_object_or_array_creation_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp17_ = _tmp16_, _vala_code_node_unref0 (expr), _tmp17_);
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_PRINT:
		{
			ValaExpression* _tmp18_;
			_tmp18_ = vala_genie_parser_parse_print_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp18_;
			_vala_code_node_unref0 (expr);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_SIZEOF:
		{
			ValaExpression* _tmp19_;
			ValaExpression* _tmp20_;
			_tmp19_ = vala_genie_parser_parse_sizeof_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp20_ = _tmp19_, _vala_code_node_unref0 (expr), _tmp20_);
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_TYPEOF:
		{
			ValaExpression* _tmp21_;
			ValaExpression* _tmp22_;
			_tmp21_ = vala_genie_parser_parse_typeof_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp22_ = _tmp21_, _vala_code_node_unref0 (expr), _tmp22_);
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_YIELD:
		{
			ValaExpression* _tmp23_;
			ValaExpression* _tmp24_;
			_tmp23_ = vala_genie_parser_parse_yield_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp24_ = _tmp23_, _vala_code_node_unref0 (expr), _tmp24_);
			break;
		}
		default:
		{
			ValaExpression* _tmp25_;
			ValaExpression* _tmp26_;
			_tmp25_ = vala_genie_parser_parse_simple_name (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp26_ = _tmp25_, _vala_code_node_unref0 (expr), _tmp26_);
			break;
		}
	}
	found = TRUE;
	while (TRUE) {
		if (!found) {
			break;
		}
		switch (vala_genie_parser_current (self)) {
			case VALA_GENIE_TOKEN_TYPE_DOT:
			{
				ValaExpression* _tmp27_;
				ValaExpression* _tmp28_;
				_tmp27_ = vala_genie_parser_parse_member_access (self, &begin, expr, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp28_ = _tmp27_, _vala_code_node_unref0 (expr), _tmp28_);
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OP_PTR:
			{
				ValaExpression* _tmp29_;
				ValaExpression* _tmp30_;
				_tmp29_ = vala_genie_parser_parse_pointer_member_access (self, &begin, expr, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp30_ = _tmp29_, _vala_code_node_unref0 (expr), _tmp30_);
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
			{
				ValaExpression* _tmp31_;
				ValaExpression* _tmp32_;
				_tmp31_ = vala_genie_parser_parse_method_call (self, &begin, expr, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp32_ = _tmp31_, _vala_code_node_unref0 (expr), _tmp32_);
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET:
			{
				ValaExpression* _tmp33_;
				ValaExpression* _tmp34_;
				_tmp33_ = vala_genie_parser_parse_element_access (self, &begin, expr, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp34_ = _tmp33_, _vala_code_node_unref0 (expr), _tmp34_);
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OP_INC:
			{
				ValaExpression* _tmp35_;
				ValaExpression* _tmp36_;
				_tmp35_ = vala_genie_parser_parse_post_increment_expression (self, &begin, expr, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp36_ = _tmp35_, _vala_code_node_unref0 (expr), _tmp36_);
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OP_DEC:
			{
				ValaExpression* _tmp37_;
				ValaExpression* _tmp38_;
				_tmp37_ = vala_genie_parser_parse_post_decrement_expression (self, &begin, expr, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp38_ = _tmp37_, _vala_code_node_unref0 (expr), _tmp38_);
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = expr;
	return result;
}


static ValaExpression* vala_genie_parser_parse_simple_name (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	char* id;
	ValaList* type_arg_list;
	ValaSourceReference* _tmp1_;
	ValaMemberAccess* _tmp2_;
	ValaMemberAccess* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	id = vala_genie_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_arg_list = vala_genie_parser_parse_type_argument_list (self, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = (_tmp2_ = vala_member_access_new (NULL, id, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	if (type_arg_list != NULL) {
		{
			ValaIterator* _type_arg_it;
			_type_arg_it = vala_iterable_iterator ((ValaIterable*) type_arg_list);
			while (TRUE) {
				ValaDataType* type_arg;
				if (!vala_iterator_next (_type_arg_it)) {
					break;
				}
				type_arg = (ValaDataType*) vala_iterator_get (_type_arg_it);
				vala_member_access_add_type_argument (expr, type_arg);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_collection_object_unref0 (_type_arg_it);
		}
	}
	result = (ValaExpression*) expr;
	_vala_collection_object_unref0 (type_arg_list);
	_g_free0 (id);
	return result;
}


static ValaExpression* vala_genie_parser_parse_template (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaTemplate* template;
	ValaSourceReference* _tmp3_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	template = vala_template_new (NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_TEMPLATE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (template);
			return NULL;
		} else {
			_vala_code_node_unref0 (template);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* _tmp1_;
		ValaExpression* _tmp2_;
		if (!(vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_TEMPLATE)) {
			break;
		}
		_tmp1_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (template);
				return NULL;
			} else {
				_vala_code_node_unref0 (template);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_template_add_expression (template, _tmp2_ = _tmp1_);
		_vala_code_node_unref0 (_tmp2_);
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COMMA, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (template);
				return NULL;
			} else {
				_vala_code_node_unref0 (template);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_TEMPLATE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (template);
			return NULL;
		} else {
			_vala_code_node_unref0 (template);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_code_node_set_source_reference ((ValaCodeNode*) template, _tmp3_ = vala_genie_parser_get_src (self, &begin));
	_vala_source_reference_unref0 (_tmp3_);
	result = (ValaExpression*) template;
	return result;
}


static ValaExpression* vala_genie_parser_parse_tuple (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaArrayList* expr_list;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr_list = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				ValaExpression* _tmp1_;
				ValaExpression* _tmp2_;
				if (!_tmp0_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				_tmp1_ = vala_genie_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (expr_list);
						return NULL;
					} else {
						_vala_collection_object_unref0 (expr_list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) expr_list, _tmp2_ = _tmp1_);
				_vala_code_node_unref0 (_tmp2_);
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (expr_list);
			return NULL;
		} else {
			_vala_collection_object_unref0 (expr_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_collection_get_size ((ValaCollection*) expr_list) != 1) {
		ValaTuple* tuple;
		tuple = vala_tuple_new (NULL);
		{
			ValaIterator* _expr_it;
			_expr_it = vala_iterable_iterator ((ValaIterable*) expr_list);
			while (TRUE) {
				ValaExpression* expr;
				if (!vala_iterator_next (_expr_it)) {
					break;
				}
				expr = (ValaExpression*) vala_iterator_get (_expr_it);
				vala_tuple_add_expression (tuple, expr);
				_vala_code_node_unref0 (expr);
			}
			_vala_collection_object_unref0 (_expr_it);
		}
		result = (ValaExpression*) tuple;
		_vala_collection_object_unref0 (expr_list);
		return result;
	}
	result = (ValaExpression*) vala_list_get ((ValaList*) expr_list, 0);
	_vala_collection_object_unref0 (expr_list);
	return result;
}


static ValaExpression* vala_genie_parser_parse_member_access (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	char* id;
	ValaList* type_arg_list;
	ValaSourceReference* _tmp0_;
	ValaMemberAccess* _tmp1_;
	ValaMemberAccess* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DOT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	id = vala_genie_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_arg_list = vala_genie_parser_parse_type_argument_list (self, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = (_tmp1_ = vala_member_access_new (inner, id, _tmp0_ = vala_genie_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp0_), _tmp1_);
	if (type_arg_list != NULL) {
		{
			ValaIterator* _type_arg_it;
			_type_arg_it = vala_iterable_iterator ((ValaIterable*) type_arg_list);
			while (TRUE) {
				ValaDataType* type_arg;
				if (!vala_iterator_next (_type_arg_it)) {
					break;
				}
				type_arg = (ValaDataType*) vala_iterator_get (_type_arg_it);
				vala_member_access_add_type_argument (expr, type_arg);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_collection_object_unref0 (_type_arg_it);
		}
	}
	result = (ValaExpression*) expr;
	_vala_collection_object_unref0 (type_arg_list);
	_g_free0 (id);
	return result;
}


static ValaExpression* vala_genie_parser_parse_pointer_member_access (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	char* id;
	ValaList* type_arg_list;
	ValaSourceReference* _tmp0_;
	ValaMemberAccess* _tmp1_;
	ValaMemberAccess* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OP_PTR, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	id = vala_genie_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_arg_list = vala_genie_parser_parse_type_argument_list (self, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = (_tmp1_ = vala_member_access_new_pointer (inner, id, _tmp0_ = vala_genie_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp0_), _tmp1_);
	if (type_arg_list != NULL) {
		{
			ValaIterator* _type_arg_it;
			_type_arg_it = vala_iterable_iterator ((ValaIterable*) type_arg_list);
			while (TRUE) {
				ValaDataType* type_arg;
				if (!vala_iterator_next (_type_arg_it)) {
					break;
				}
				type_arg = (ValaDataType*) vala_iterator_get (_type_arg_it);
				vala_member_access_add_type_argument (expr, type_arg);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_collection_object_unref0 (_type_arg_it);
		}
	}
	result = (ValaExpression*) expr;
	_vala_collection_object_unref0 (type_arg_list);
	_g_free0 (id);
	return result;
}


static ValaList* vala_genie_parser_parse_print_argument_list (ValaGenieParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list;
	gint i;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	list = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	i = 0;
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				ValaExpression* p_expr;
				if (!_tmp1_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp1_ = FALSE;
				p_expr = vala_genie_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (list);
						return NULL;
					} else {
						_vala_collection_object_unref0 (list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				if (i == 0) {
					i++;
					if (p_expr != NULL) {
						if (VALA_IS_STRING_LITERAL (p_expr)) {
							ValaStringLiteral* s_exp;
							gsize len;
							s_exp = _vala_code_node_ref0 (VALA_STRING_LITERAL (p_expr));
							len = strlen (vala_string_literal_get_value (s_exp));
							if (len > 2) {
								char* s;
								char* st;
								char* _tmp2_;
								s = g_strdup ("\\n\"");
								st = g_strndup (vala_string_literal_get_value (s_exp), len - 1);
								st = (_tmp2_ = g_strconcat (st, s, NULL), _g_free0 (st), _tmp2_);
								vala_string_literal_set_value (s_exp, st);
								_g_free0 (st);
								_g_free0 (s);
							}
							_vala_code_node_unref0 (s_exp);
						} else {
							char* s;
							ValaSourceReference* _tmp3_;
							ValaStringLiteral* _tmp4_;
							ValaStringLiteral* rhs;
							ValaSourceReference* _tmp5_;
							ValaExpression* _tmp6_;
							s = g_strdup ("\"\\n\"");
							rhs = (_tmp4_ = vala_string_literal_new (s, _tmp3_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
							p_expr = (_tmp6_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_PLUS, p_expr, (ValaExpression*) rhs, _tmp5_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (p_expr), _tmp6_);
							_vala_source_reference_unref0 (_tmp5_);
							_vala_code_node_unref0 (rhs);
							_g_free0 (s);
						}
					}
				}
				vala_collection_add ((ValaCollection*) list, p_expr);
				_vala_code_node_unref0 (p_expr);
			}
		}
	}
	result = (ValaList*) list;
	return result;
}


static ValaExpression* vala_genie_parser_parse_print_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	gboolean parens;
	ValaSourceReference* _tmp1_;
	ValaMemberAccess* _tmp2_;
	ValaMemberAccess* expr;
	ValaList* arg_list;
	ValaSourceReference* _tmp3_;
	ValaMethodCall* _tmp4_;
	ValaMethodCall* print_expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_PRINT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	parens = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS);
	expr = (_tmp2_ = vala_member_access_new (NULL, "print", _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	arg_list = vala_genie_parser_parse_print_argument_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (parens) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (arg_list);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_collection_object_unref0 (arg_list);
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	print_expr = (_tmp4_ = vala_method_call_new ((ValaExpression*) expr, _tmp3_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	{
		ValaIterator* _arg_it;
		_arg_it = vala_iterable_iterator ((ValaIterable*) arg_list);
		while (TRUE) {
			ValaExpression* arg;
			if (!vala_iterator_next (_arg_it)) {
				break;
			}
			arg = (ValaExpression*) vala_iterator_get (_arg_it);
			vala_method_call_add_argument (print_expr, arg);
			_vala_code_node_unref0 (arg);
		}
		_vala_collection_object_unref0 (_arg_it);
	}
	result = (ValaExpression*) print_expr;
	_vala_collection_object_unref0 (arg_list);
	_vala_code_node_unref0 (expr);
	return result;
}


static ValaExpression* vala_genie_parser_parse_assert_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	gboolean parens;
	ValaSourceReference* _tmp1_;
	ValaMemberAccess* _tmp2_;
	ValaMemberAccess* expr;
	ValaList* arg_list;
	ValaSourceReference* _tmp3_;
	ValaMethodCall* _tmp4_;
	ValaMethodCall* assert_expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_ASSERT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	parens = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS);
	expr = (_tmp2_ = vala_member_access_new (NULL, "assert", _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	arg_list = vala_genie_parser_parse_argument_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (parens) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (arg_list);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_collection_object_unref0 (arg_list);
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	assert_expr = (_tmp4_ = vala_method_call_new ((ValaExpression*) expr, _tmp3_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	{
		ValaIterator* _arg_it;
		_arg_it = vala_iterable_iterator ((ValaIterable*) arg_list);
		while (TRUE) {
			ValaExpression* arg;
			if (!vala_iterator_next (_arg_it)) {
				break;
			}
			arg = (ValaExpression*) vala_iterator_get (_arg_it);
			vala_method_call_add_argument (assert_expr, arg);
			_vala_code_node_unref0 (arg);
		}
		_vala_collection_object_unref0 (_arg_it);
	}
	result = (ValaExpression*) assert_expr;
	_vala_collection_object_unref0 (arg_list);
	_vala_code_node_unref0 (expr);
	return result;
}


static ValaExpression* vala_genie_parser_parse_method_call (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	ValaList* arg_list;
	ValaList* init_list;
	gboolean _tmp0_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	arg_list = vala_genie_parser_parse_argument_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (arg_list);
			return NULL;
		} else {
			_vala_collection_object_unref0 (arg_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	init_list = vala_genie_parser_parse_object_initializer (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (arg_list);
			return NULL;
		} else {
			_vala_collection_object_unref0 (arg_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_collection_get_size ((ValaCollection*) init_list) > 0) {
		_tmp0_ = VALA_IS_MEMBER_ACCESS (inner);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		ValaMemberAccess* member;
		ValaSourceReference* _tmp1_;
		ValaObjectCreationExpression* _tmp2_;
		ValaObjectCreationExpression* expr;
		member = _vala_code_node_ref0 (VALA_MEMBER_ACCESS (inner));
		vala_member_access_set_creation_member (member, TRUE);
		expr = (_tmp2_ = vala_object_creation_expression_new (member, _tmp1_ = vala_genie_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
		vala_object_creation_expression_set_struct_creation (expr, TRUE);
		{
			ValaIterator* _arg_it;
			_arg_it = vala_iterable_iterator ((ValaIterable*) arg_list);
			while (TRUE) {
				ValaExpression* arg;
				if (!vala_iterator_next (_arg_it)) {
					break;
				}
				arg = (ValaExpression*) vala_iterator_get (_arg_it);
				vala_object_creation_expression_add_argument (expr, arg);
				_vala_code_node_unref0 (arg);
			}
			_vala_collection_object_unref0 (_arg_it);
		}
		{
			ValaIterator* _initializer_it;
			_initializer_it = vala_iterable_iterator ((ValaIterable*) init_list);
			while (TRUE) {
				ValaMemberInitializer* initializer;
				if (!vala_iterator_next (_initializer_it)) {
					break;
				}
				initializer = (ValaMemberInitializer*) vala_iterator_get (_initializer_it);
				vala_object_creation_expression_add_member_initializer (expr, initializer);
				_vala_code_node_unref0 (initializer);
			}
			_vala_collection_object_unref0 (_initializer_it);
		}
		result = (ValaExpression*) expr;
		_vala_code_node_unref0 (member);
		_vala_collection_object_unref0 (init_list);
		_vala_collection_object_unref0 (arg_list);
		return result;
	} else {
		ValaSourceReference* _tmp3_;
		ValaMethodCall* _tmp4_;
		ValaMethodCall* expr;
		expr = (_tmp4_ = vala_method_call_new (inner, _tmp3_ = vala_genie_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
		{
			ValaIterator* _arg_it;
			_arg_it = vala_iterable_iterator ((ValaIterable*) arg_list);
			while (TRUE) {
				ValaExpression* arg;
				if (!vala_iterator_next (_arg_it)) {
					break;
				}
				arg = (ValaExpression*) vala_iterator_get (_arg_it);
				vala_method_call_add_argument (expr, arg);
				_vala_code_node_unref0 (arg);
			}
			_vala_collection_object_unref0 (_arg_it);
		}
		result = (ValaExpression*) expr;
		_vala_collection_object_unref0 (init_list);
		_vala_collection_object_unref0 (arg_list);
		return result;
	}
	_vala_collection_object_unref0 (init_list);
	_vala_collection_object_unref0 (arg_list);
}


static ValaExpression* vala_genie_parser_parse_element_access (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	ValaList* index_list;
	ValaExpression* stop;
	gboolean _tmp0_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	index_list = vala_genie_parser_parse_expression_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	stop = NULL;
	if (vala_collection_get_size ((ValaCollection*) index_list) == 1) {
		_tmp0_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		ValaExpression* _tmp1_;
		ValaExpression* _tmp2_;
		_tmp1_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (stop);
				_vala_collection_object_unref0 (index_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (stop);
				_vala_collection_object_unref0 (index_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		stop = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (stop), _tmp2_);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (stop);
			_vala_collection_object_unref0 (index_list);
			return NULL;
		} else {
			_vala_code_node_unref0 (stop);
			_vala_collection_object_unref0 (index_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (stop == NULL) {
		ValaSourceReference* _tmp3_;
		ValaElementAccess* _tmp4_;
		ValaElementAccess* expr;
		expr = (_tmp4_ = vala_element_access_new (inner, _tmp3_ = vala_genie_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
		{
			ValaIterator* _index_it;
			_index_it = vala_iterable_iterator ((ValaIterable*) index_list);
			while (TRUE) {
				ValaExpression* index;
				if (!vala_iterator_next (_index_it)) {
					break;
				}
				index = (ValaExpression*) vala_iterator_get (_index_it);
				vala_element_access_append_index (expr, index);
				_vala_code_node_unref0 (index);
			}
			_vala_collection_object_unref0 (_index_it);
		}
		result = (ValaExpression*) expr;
		_vala_code_node_unref0 (stop);
		_vala_collection_object_unref0 (index_list);
		return result;
	} else {
		ValaExpression* _tmp5_;
		ValaSourceReference* _tmp6_;
		ValaExpression* _tmp7_;
		result = (_tmp7_ = (ValaExpression*) vala_slice_expression_new (inner, _tmp5_ = (ValaExpression*) vala_list_get (index_list, 0), stop, _tmp6_ = vala_genie_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp6_), _vala_code_node_unref0 (_tmp5_), _tmp7_);
		_vala_code_node_unref0 (stop);
		_vala_collection_object_unref0 (index_list);
		return result;
	}
	_vala_code_node_unref0 (stop);
	_vala_collection_object_unref0 (index_list);
}


static ValaList* vala_genie_parser_parse_expression_list (ValaGenieParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	list = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	{
		gboolean _tmp0_;
		_tmp0_ = TRUE;
		while (TRUE) {
			ValaExpression* _tmp1_;
			ValaExpression* _tmp2_;
			if (!_tmp0_) {
				if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
					break;
				}
			}
			_tmp0_ = FALSE;
			_tmp1_ = vala_genie_parser_parse_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (list);
					return NULL;
				} else {
					_vala_collection_object_unref0 (list);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			vala_collection_add ((ValaCollection*) list, _tmp2_ = _tmp1_);
			_vala_code_node_unref0 (_tmp2_);
		}
	}
	result = (ValaList*) list;
	return result;
}


static ValaExpression* vala_genie_parser_parse_this_access (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaExpression* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_THIS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaExpression*) vala_member_access_new (NULL, "this", _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	return result;
}


static ValaExpression* vala_genie_parser_parse_base_access (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaExpression* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_SUPER, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaExpression*) vala_base_access_new (_tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	return result;
}


static ValaExpression* vala_genie_parser_parse_post_increment_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceReference* _tmp0_;
	ValaExpression* _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OP_INC, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp1_ = (ValaExpression*) vala_postfix_expression_new (inner, TRUE, _tmp0_ = vala_genie_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp0_), _tmp1_);
	return result;
}


static ValaExpression* vala_genie_parser_parse_post_decrement_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceReference* _tmp0_;
	ValaExpression* _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OP_DEC, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp1_ = (ValaExpression*) vala_postfix_expression_new (inner, FALSE, _tmp0_ = vala_genie_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp0_), _tmp1_);
	return result;
}


static ValaExpression* vala_genie_parser_parse_object_or_array_creation_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaMemberAccess* member;
	ValaExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_NEW, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ARRAY)) {
		ValaDataType* mtype;
		ValaExpression* expr;
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OF, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		mtype = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		expr = vala_genie_parser_parse_array_creation_expression (self, &begin, mtype, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (mtype);
				return NULL;
			} else {
				_vala_code_node_unref0 (mtype);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = expr;
		_vala_code_node_unref0 (mtype);
		return result;
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_LIST)) {
		ValaDataType* mtype;
		ValaExpression* expr;
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OF, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		mtype = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		expr = vala_genie_parser_parse_list_creation_expression (self, &begin, mtype, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (mtype);
				return NULL;
			} else {
				_vala_code_node_unref0 (mtype);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = expr;
		_vala_code_node_unref0 (mtype);
		return result;
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DICT)) {
		ValaDataType* mtype1;
		ValaDataType* mtype2;
		ValaExpression* expr;
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OF, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		mtype1 = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COMMA, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (mtype1);
				return NULL;
			} else {
				_vala_code_node_unref0 (mtype1);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		mtype2 = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (mtype1);
				return NULL;
			} else {
				_vala_code_node_unref0 (mtype1);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		expr = vala_genie_parser_parse_dict_creation_expression (self, &begin, mtype1, mtype2, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (mtype2);
				_vala_code_node_unref0 (mtype1);
				return NULL;
			} else {
				_vala_code_node_unref0 (mtype2);
				_vala_code_node_unref0 (mtype1);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = expr;
		_vala_code_node_unref0 (mtype2);
		_vala_code_node_unref0 (mtype1);
		return result;
	}
	member = vala_genie_parser_parse_member_name (self, NULL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = vala_genie_parser_parse_object_creation_expression (self, &begin, member, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (member);
			return NULL;
		} else {
			_vala_code_node_unref0 (member);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = expr;
	_vala_code_node_unref0 (member);
	return result;
}


static ValaExpression* vala_genie_parser_parse_object_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaMemberAccess* member, GError** error) {
	ValaExpression* result = NULL;
	ValaList* arg_list;
	ValaList* init_list;
	ValaSourceReference* _tmp3_;
	ValaObjectCreationExpression* _tmp4_;
	ValaObjectCreationExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (member != NULL, NULL);
	vala_member_access_set_creation_member (member, TRUE);
	arg_list = NULL;
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS)) {
		ValaList* _tmp0_;
		ValaList* _tmp1_;
		_tmp0_ = vala_genie_parser_parse_argument_list (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (arg_list);
				return NULL;
			} else {
				_vala_collection_object_unref0 (arg_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		arg_list = (_tmp1_ = _tmp0_, _vala_collection_object_unref0 (arg_list), _tmp1_);
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (arg_list);
				return NULL;
			} else {
				_vala_collection_object_unref0 (arg_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		ValaList* _tmp2_;
		arg_list = (_tmp2_ = (ValaList*) vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal), _vala_collection_object_unref0 (arg_list), _tmp2_);
	}
	init_list = vala_genie_parser_parse_object_initializer (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (arg_list);
			return NULL;
		} else {
			_vala_collection_object_unref0 (arg_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = (_tmp4_ = vala_object_creation_expression_new (member, _tmp3_ = vala_genie_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	{
		ValaIterator* _arg_it;
		_arg_it = vala_iterable_iterator ((ValaIterable*) arg_list);
		while (TRUE) {
			ValaExpression* arg;
			if (!vala_iterator_next (_arg_it)) {
				break;
			}
			arg = (ValaExpression*) vala_iterator_get (_arg_it);
			vala_object_creation_expression_add_argument (expr, arg);
			_vala_code_node_unref0 (arg);
		}
		_vala_collection_object_unref0 (_arg_it);
	}
	{
		ValaIterator* _initializer_it;
		_initializer_it = vala_iterable_iterator ((ValaIterable*) init_list);
		while (TRUE) {
			ValaMemberInitializer* initializer;
			if (!vala_iterator_next (_initializer_it)) {
				break;
			}
			initializer = (ValaMemberInitializer*) vala_iterator_get (_initializer_it);
			vala_object_creation_expression_add_member_initializer (expr, initializer);
			_vala_code_node_unref0 (initializer);
		}
		_vala_collection_object_unref0 (_initializer_it);
	}
	result = (ValaExpression*) expr;
	_vala_collection_object_unref0 (init_list);
	_vala_collection_object_unref0 (arg_list);
	return result;
}


static ValaExpression* vala_genie_parser_parse_array_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaDataType* element_type, GError** error) {
	ValaExpression* result = NULL;
	gboolean size_specified;
	ValaList* size_specifier_list;
	gboolean first;
	ValaDataType* etype;
	gboolean has_bracket;
	ValaInitializerList* initializer;
	ValaSourceReference* _tmp12_;
	ValaArrayCreationExpression* _tmp13_;
	ValaArrayCreationExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (element_type != NULL, NULL);
	size_specified = FALSE;
	size_specifier_list = NULL;
	first = TRUE;
	etype = vala_data_type_copy (element_type);
	has_bracket = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET);
	{
		gboolean _tmp0_;
		_tmp0_ = TRUE;
		while (TRUE) {
			ValaList* _tmp4_;
			if (!_tmp0_) {
				if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET)) {
					break;
				}
			}
			_tmp0_ = FALSE;
			if (!first) {
				ValaDataType* _tmp3_;
				if (size_specified) {
					char* _tmp1_;
					GError* _tmp2_;
					_inner_error_ = (_tmp2_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp1_ = vala_genie_parser_get_error (self, "size of inner arrays must not be specified in array creation expressio" \
"n")), _g_free0 (_tmp1_), _tmp2_);
					{
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (etype);
							_vala_collection_object_unref0 (size_specifier_list);
							return NULL;
						} else {
							_vala_code_node_unref0 (etype);
							_vala_collection_object_unref0 (size_specifier_list);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				etype = (_tmp3_ = (ValaDataType*) vala_array_type_new (etype, vala_collection_get_size ((ValaCollection*) size_specifier_list), vala_code_node_get_source_reference ((ValaCodeNode*) etype)), _vala_code_node_unref0 (etype), _tmp3_);
			} else {
				first = FALSE;
			}
			size_specifier_list = (_tmp4_ = (ValaList*) vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal), _vala_collection_object_unref0 (size_specifier_list), _tmp4_);
			{
				gboolean _tmp5_;
				_tmp5_ = TRUE;
				while (TRUE) {
					ValaExpression* size;
					gboolean _tmp6_ = FALSE;
					gboolean _tmp7_ = FALSE;
					if (!_tmp5_) {
						if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp5_ = FALSE;
					size = NULL;
					if (has_bracket) {
						_tmp7_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET;
					} else {
						_tmp7_ = FALSE;
					}
					if (_tmp7_) {
						_tmp6_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_COMMA;
					} else {
						_tmp6_ = FALSE;
					}
					if (_tmp6_) {
						ValaExpression* _tmp8_;
						ValaExpression* _tmp9_;
						_tmp8_ = vala_genie_parser_parse_expression (self, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_code_node_unref0 (size);
								_vala_code_node_unref0 (etype);
								_vala_collection_object_unref0 (size_specifier_list);
								return NULL;
							} else {
								_vala_code_node_unref0 (size);
								_vala_code_node_unref0 (etype);
								_vala_collection_object_unref0 (size_specifier_list);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						size = (_tmp9_ = _tmp8_, _vala_code_node_unref0 (size), _tmp9_);
						size_specified = TRUE;
					}
					vala_collection_add ((ValaCollection*) size_specifier_list, size);
					_vala_code_node_unref0 (size);
				}
			}
			if (has_bracket) {
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (etype);
						_vala_collection_object_unref0 (size_specifier_list);
						return NULL;
					} else {
						_vala_code_node_unref0 (etype);
						_vala_collection_object_unref0 (size_specifier_list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
		}
	}
	initializer = NULL;
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN)) {
		ValaInitializerList* _tmp10_;
		ValaInitializerList* _tmp11_;
		_tmp10_ = vala_genie_parser_parse_initializer (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (etype);
				_vala_collection_object_unref0 (size_specifier_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (etype);
				_vala_collection_object_unref0 (size_specifier_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		initializer = (_tmp11_ = _tmp10_, _vala_code_node_unref0 (initializer), _tmp11_);
	}
	expr = (_tmp13_ = vala_array_creation_expression_new (etype, vala_collection_get_size ((ValaCollection*) size_specifier_list), initializer, _tmp12_ = vala_genie_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp12_), _tmp13_);
	if (size_specified) {
		{
			ValaIterator* _size_it;
			_size_it = vala_iterable_iterator ((ValaIterable*) size_specifier_list);
			while (TRUE) {
				ValaExpression* size;
				if (!vala_iterator_next (_size_it)) {
					break;
				}
				size = (ValaExpression*) vala_iterator_get (_size_it);
				vala_array_creation_expression_append_size (expr, size);
				_vala_code_node_unref0 (size);
			}
			_vala_collection_object_unref0 (_size_it);
		}
	}
	result = (ValaExpression*) expr;
	_vala_code_node_unref0 (initializer);
	_vala_code_node_unref0 (etype);
	_vala_collection_object_unref0 (size_specifier_list);
	return result;
}


static ValaExpression* vala_genie_parser_parse_list_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaDataType* element_type, GError** error) {
	ValaExpression* result = NULL;
	ValaMemberAccess* list_member;
	ValaMemberAccess* parent_member;
	ValaSourceReference* _tmp0_;
	ValaMemberAccess* _tmp1_;
	ValaSourceReference* _tmp2_;
	ValaMemberAccess* _tmp3_;
	ValaSourceReference* _tmp4_;
	ValaObjectCreationExpression* _tmp5_;
	ValaObjectCreationExpression* expr;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (element_type != NULL, NULL);
	list_member = NULL;
	parent_member = NULL;
	parent_member = (_tmp1_ = vala_member_access_new (NULL, "Gee", _tmp0_ = vala_genie_parser_get_src (self, begin)), _vala_code_node_unref0 (parent_member), _tmp1_);
	_vala_source_reference_unref0 (_tmp0_);
	list_member = (_tmp3_ = vala_member_access_new ((ValaExpression*) parent_member, "ArrayList", _tmp2_ = vala_genie_parser_get_src (self, begin)), _vala_code_node_unref0 (list_member), _tmp3_);
	_vala_source_reference_unref0 (_tmp2_);
	vala_member_access_add_type_argument (list_member, element_type);
	vala_member_access_set_creation_member (list_member, TRUE);
	expr = (_tmp5_ = vala_object_creation_expression_new (list_member, _tmp4_ = vala_genie_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp4_), _tmp5_);
	result = (ValaExpression*) expr;
	_vala_code_node_unref0 (parent_member);
	_vala_code_node_unref0 (list_member);
	return result;
}


static ValaExpression* vala_genie_parser_parse_dict_creation_expression (ValaGenieParser* self, ValaSourceLocation* begin, ValaDataType* key_type, ValaDataType* value_type, GError** error) {
	ValaExpression* result = NULL;
	ValaMemberAccess* dict_member;
	ValaMemberAccess* parent_member;
	ValaSourceReference* _tmp0_;
	ValaMemberAccess* _tmp1_;
	ValaSourceReference* _tmp2_;
	ValaMemberAccess* _tmp3_;
	ValaSourceReference* _tmp4_;
	ValaObjectCreationExpression* _tmp5_;
	ValaObjectCreationExpression* expr;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key_type != NULL, NULL);
	g_return_val_if_fail (value_type != NULL, NULL);
	dict_member = NULL;
	parent_member = NULL;
	parent_member = (_tmp1_ = vala_member_access_new (NULL, "Gee", _tmp0_ = vala_genie_parser_get_src (self, begin)), _vala_code_node_unref0 (parent_member), _tmp1_);
	_vala_source_reference_unref0 (_tmp0_);
	dict_member = (_tmp3_ = vala_member_access_new ((ValaExpression*) parent_member, "HashMap", _tmp2_ = vala_genie_parser_get_src (self, begin)), _vala_code_node_unref0 (dict_member), _tmp3_);
	_vala_source_reference_unref0 (_tmp2_);
	vala_member_access_add_type_argument (dict_member, key_type);
	vala_member_access_add_type_argument (dict_member, value_type);
	vala_member_access_set_creation_member (dict_member, TRUE);
	expr = (_tmp5_ = vala_object_creation_expression_new (dict_member, _tmp4_ = vala_genie_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp4_), _tmp5_);
	result = (ValaExpression*) expr;
	_vala_code_node_unref0 (parent_member);
	_vala_code_node_unref0 (dict_member);
	return result;
}


static ValaList* vala_genie_parser_parse_object_initializer (ValaGenieParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	list = vala_array_list_new (VALA_TYPE_MEMBER_INITIALIZER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACE)) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				ValaMemberInitializer* _tmp1_;
				ValaMemberInitializer* _tmp2_;
				if (!_tmp0_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				_tmp1_ = vala_genie_parser_parse_member_initializer (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (list);
						return NULL;
					} else {
						_vala_collection_object_unref0 (list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) list, _tmp2_ = _tmp1_);
				_vala_code_node_unref0 (_tmp2_);
			}
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (list);
				return NULL;
			} else {
				_vala_collection_object_unref0 (list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	result = (ValaList*) list;
	return result;
}


static ValaMemberInitializer* vala_genie_parser_parse_member_initializer (ValaGenieParser* self, GError** error) {
	ValaMemberInitializer* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	char* id;
	ValaExpression* expr;
	ValaSourceReference* _tmp1_;
	ValaMemberInitializer* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	id = vala_genie_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_ASSIGN, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = vala_genie_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = vala_member_initializer_new (id, expr, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (expr);
	_g_free0 (id);
	return result;
	_vala_code_node_unref0 (expr);
	_g_free0 (id);
}


static ValaExpression* vala_genie_parser_parse_yield_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* base_expr;
	ValaMemberAccess* member;
	ValaExpression* _tmp3_;
	ValaMethodCall* call;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_YIELD, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	base_expr = NULL;
	if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_SUPER) {
		ValaExpression* _tmp1_;
		ValaExpression* _tmp2_;
		_tmp1_ = vala_genie_parser_parse_base_access (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (base_expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (base_expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		base_expr = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (base_expr), _tmp2_);
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DOT, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (base_expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (base_expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	member = vala_genie_parser_parse_member_name (self, base_expr, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (base_expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (base_expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = vala_genie_parser_parse_method_call (self, &begin, (ValaExpression*) member, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (member);
			_vala_code_node_unref0 (base_expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (member);
			_vala_code_node_unref0 (base_expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	call = VALA_METHOD_CALL (_tmp3_);
	vala_method_call_set_is_yield_expression (call, TRUE);
	result = (ValaExpression*) call;
	_vala_code_node_unref0 (member);
	_vala_code_node_unref0 (base_expr);
	return result;
}


static ValaExpression* vala_genie_parser_parse_sizeof_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaDataType* type;
	ValaSourceReference* _tmp1_;
	ValaExpression* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_SIZEOF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaExpression*) vala_sizeof_expression_new (type, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (type);
	return result;
	_vala_code_node_unref0 (type);
}


static ValaExpression* vala_genie_parser_parse_typeof_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaDataType* type;
	ValaSourceReference* _tmp1_;
	ValaExpression* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_TYPEOF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaExpression*) vala_typeof_expression_new (type, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (type);
	return result;
	_vala_code_node_unref0 (type);
}


static ValaUnaryOperator vala_genie_parser_get_unary_operator (ValaGenieParser* self, ValaGenieTokenType token_type) {
	ValaUnaryOperator result = 0;
	g_return_val_if_fail (self != NULL, 0);
	switch (token_type) {
		case VALA_GENIE_TOKEN_TYPE_PLUS:
		{
			result = VALA_UNARY_OPERATOR_PLUS;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_MINUS:
		{
			result = VALA_UNARY_OPERATOR_MINUS;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_NEG:
		{
			result = VALA_UNARY_OPERATOR_LOGICAL_NEGATION;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_TILDE:
		{
			result = VALA_UNARY_OPERATOR_BITWISE_COMPLEMENT;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_INC:
		{
			result = VALA_UNARY_OPERATOR_INCREMENT;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_DEC:
		{
			result = VALA_UNARY_OPERATOR_DECREMENT;
			return result;
		}
		default:
		{
			result = VALA_UNARY_OPERATOR_NONE;
			return result;
		}
	}
}


static ValaExpression* vala_genie_parser_parse_unary_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaUnaryOperator operator;
	ValaExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	operator = vala_genie_parser_get_unary_operator (self, vala_genie_parser_current (self));
	if (operator != VALA_UNARY_OPERATOR_NONE) {
		ValaExpression* op;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		vala_genie_parser_next (self);
		op = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = (_tmp2_ = (ValaExpression*) vala_unary_expression_new (operator, op, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
		_vala_code_node_unref0 (op);
		return result;
		_vala_code_node_unref0 (op);
	}
	switch (vala_genie_parser_current (self)) {
		case VALA_GENIE_TOKEN_TYPE_HASH:
		{
			ValaExpression* op;
			ValaSourceReference* _tmp3_;
			ValaExpression* _tmp4_;
			vala_genie_parser_next (self);
			op = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (_tmp4_ = (ValaExpression*) vala_reference_transfer_expression_new (op, _tmp3_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
			_vala_code_node_unref0 (op);
			return result;
			_vala_code_node_unref0 (op);
		}
		case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
		{
			vala_genie_parser_next (self);
			switch (vala_genie_parser_current (self)) {
				case VALA_GENIE_TOKEN_TYPE_OWNED:
				{
					vala_genie_parser_next (self);
					if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS)) {
						ValaExpression* op;
						ValaSourceReference* _tmp5_;
						ValaExpression* _tmp6_;
						op = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								return NULL;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						result = (_tmp6_ = (ValaExpression*) vala_reference_transfer_expression_new (op, _tmp5_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp5_), _tmp6_);
						_vala_code_node_unref0 (op);
						return result;
						_vala_code_node_unref0 (op);
					}
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_VOID:
				case VALA_GENIE_TOKEN_TYPE_DYNAMIC:
				case VALA_GENIE_TOKEN_TYPE_IDENTIFIER:
				case VALA_GENIE_TOKEN_TYPE_ARRAY:
				case VALA_GENIE_TOKEN_TYPE_LIST:
				case VALA_GENIE_TOKEN_TYPE_DICT:
				{
					ValaDataType* type;
					type = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							return NULL;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS)) {
						switch (vala_genie_parser_current (self)) {
							case VALA_GENIE_TOKEN_TYPE_OP_NEG:
							case VALA_GENIE_TOKEN_TYPE_TILDE:
							case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
							case VALA_GENIE_TOKEN_TYPE_TRUE:
							case VALA_GENIE_TOKEN_TYPE_FALSE:
							case VALA_GENIE_TOKEN_TYPE_INTEGER_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_REAL_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_CHARACTER_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_REGEX_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_STRING_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_TEMPLATE_STRING_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_VERBATIM_STRING_LITERAL:
							case VALA_GENIE_TOKEN_TYPE_NULL:
							case VALA_GENIE_TOKEN_TYPE_THIS:
							case VALA_GENIE_TOKEN_TYPE_SUPER:
							case VALA_GENIE_TOKEN_TYPE_NEW:
							case VALA_GENIE_TOKEN_TYPE_SIZEOF:
							case VALA_GENIE_TOKEN_TYPE_TYPEOF:
							case VALA_GENIE_TOKEN_TYPE_IDENTIFIER:
							case VALA_GENIE_TOKEN_TYPE_PARAMS:
							{
								ValaExpression* inner;
								ValaSourceReference* _tmp7_;
								ValaExpression* _tmp8_;
								inner = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == VALA_PARSE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_vala_code_node_unref0 (type);
										return NULL;
									} else {
										_vala_code_node_unref0 (type);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return NULL;
									}
								}
								result = (_tmp8_ = (ValaExpression*) vala_cast_expression_new (inner, type, _tmp7_ = vala_genie_parser_get_src (self, &begin), FALSE), _vala_source_reference_unref0 (_tmp7_), _tmp8_);
								_vala_code_node_unref0 (inner);
								_vala_code_node_unref0 (type);
								return result;
								_vala_code_node_unref0 (inner);
							}
							default:
							{
								break;
							}
						}
					}
					_vala_code_node_unref0 (type);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_OP_NEG:
				{
					vala_genie_parser_next (self);
					if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS)) {
						ValaExpression* inner;
						ValaSourceReference* _tmp9_;
						ValaExpression* _tmp10_;
						inner = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								return NULL;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						result = (_tmp10_ = (ValaExpression*) vala_cast_expression_new_non_null (inner, _tmp9_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp9_), _tmp10_);
						_vala_code_node_unref0 (inner);
						return result;
						_vala_code_node_unref0 (inner);
					}
					break;
				}
				default:
				{
					break;
				}
			}
			vala_genie_parser_rollback (self, &begin);
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_STAR:
		{
			ValaExpression* op;
			ValaSourceReference* _tmp11_;
			ValaExpression* _tmp12_;
			vala_genie_parser_next (self);
			op = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (_tmp12_ = (ValaExpression*) vala_pointer_indirection_new (op, _tmp11_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp11_), _tmp12_);
			_vala_code_node_unref0 (op);
			return result;
			_vala_code_node_unref0 (op);
		}
		case VALA_GENIE_TOKEN_TYPE_BITWISE_AND:
		{
			ValaExpression* op;
			ValaSourceReference* _tmp13_;
			ValaExpression* _tmp14_;
			vala_genie_parser_next (self);
			op = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (_tmp14_ = (ValaExpression*) vala_addressof_expression_new (op, _tmp13_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp13_), _tmp14_);
			_vala_code_node_unref0 (op);
			return result;
			_vala_code_node_unref0 (op);
		}
		default:
		{
			break;
		}
	}
	expr = vala_genie_parser_parse_primary_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = expr;
	return result;
}


static ValaBinaryOperator vala_genie_parser_get_binary_operator (ValaGenieParser* self, ValaGenieTokenType token_type) {
	ValaBinaryOperator result = 0;
	g_return_val_if_fail (self != NULL, 0);
	switch (token_type) {
		case VALA_GENIE_TOKEN_TYPE_STAR:
		{
			result = VALA_BINARY_OPERATOR_MUL;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_DIV:
		{
			result = VALA_BINARY_OPERATOR_DIV;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_PERCENT:
		{
			result = VALA_BINARY_OPERATOR_MOD;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_PLUS:
		{
			result = VALA_BINARY_OPERATOR_PLUS;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_MINUS:
		{
			result = VALA_BINARY_OPERATOR_MINUS;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_LT:
		{
			result = VALA_BINARY_OPERATOR_LESS_THAN;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_GT:
		{
			result = VALA_BINARY_OPERATOR_GREATER_THAN;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_LE:
		{
			result = VALA_BINARY_OPERATOR_LESS_THAN_OR_EQUAL;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_GE:
		{
			result = VALA_BINARY_OPERATOR_GREATER_THAN_OR_EQUAL;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_EQ:
		{
			result = VALA_BINARY_OPERATOR_EQUALITY;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_IS:
		{
			vala_genie_parser_next (self);
			if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_OP_NEG) {
				vala_genie_parser_prev (self);
				result = VALA_BINARY_OPERATOR_INEQUALITY;
				return result;
			}
			vala_genie_parser_prev (self);
			result = VALA_BINARY_OPERATOR_EQUALITY;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_OP_NE:
		{
			result = VALA_BINARY_OPERATOR_INEQUALITY;
			return result;
		}
		default:
		{
			result = VALA_BINARY_OPERATOR_NONE;
			return result;
		}
	}
}


static ValaExpression* vala_genie_parser_parse_multiplicative_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	gboolean found;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		ValaBinaryOperator operator;
		if (!found) {
			break;
		}
		operator = vala_genie_parser_get_binary_operator (self, vala_genie_parser_current (self));
		switch (operator) {
			case VALA_BINARY_OPERATOR_MUL:
			case VALA_BINARY_OPERATOR_DIV:
			case VALA_BINARY_OPERATOR_MOD:
			{
				ValaExpression* right;
				ValaSourceReference* _tmp1_;
				ValaExpression* _tmp2_;
				vala_genie_parser_next (self);
				right = vala_genie_parser_parse_unary_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (operator, left, right, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
				_vala_source_reference_unref0 (_tmp1_);
				_vala_code_node_unref0 (right);
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_additive_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	gboolean found;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_genie_parser_parse_multiplicative_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		ValaBinaryOperator operator;
		if (!found) {
			break;
		}
		operator = vala_genie_parser_get_binary_operator (self, vala_genie_parser_current (self));
		switch (operator) {
			case VALA_BINARY_OPERATOR_PLUS:
			case VALA_BINARY_OPERATOR_MINUS:
			{
				ValaExpression* right;
				ValaSourceReference* _tmp1_;
				ValaExpression* _tmp2_;
				vala_genie_parser_next (self);
				right = vala_genie_parser_parse_multiplicative_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (operator, left, right, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
				_vala_source_reference_unref0 (_tmp1_);
				_vala_code_node_unref0 (right);
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_shift_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	gboolean found;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_genie_parser_parse_additive_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		if (!found) {
			break;
		}
		switch (vala_genie_parser_current (self)) {
			case VALA_GENIE_TOKEN_TYPE_OP_SHIFT_LEFT:
			{
				ValaExpression* right;
				ValaSourceReference* _tmp1_;
				ValaExpression* _tmp2_;
				vala_genie_parser_next (self);
				right = vala_genie_parser_parse_additive_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_SHIFT_LEFT, left, right, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
				_vala_source_reference_unref0 (_tmp1_);
				_vala_code_node_unref0 (right);
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OP_GT:
			{
				gchar* first_gt_pos;
				gboolean _tmp3_ = FALSE;
				first_gt_pos = self->priv->tokens[self->priv->index].begin.pos;
				vala_genie_parser_next (self);
				if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_OP_GT) {
					_tmp3_ = self->priv->tokens[self->priv->index].begin.pos == (first_gt_pos + 1);
				} else {
					_tmp3_ = FALSE;
				}
				if (_tmp3_) {
					ValaExpression* right;
					ValaSourceReference* _tmp4_;
					ValaExpression* _tmp5_;
					vala_genie_parser_next (self);
					right = vala_genie_parser_parse_additive_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (left);
							return NULL;
						} else {
							_vala_code_node_unref0 (left);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					left = (_tmp5_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_SHIFT_RIGHT, left, right, _tmp4_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp5_);
					_vala_source_reference_unref0 (_tmp4_);
					_vala_code_node_unref0 (right);
				} else {
					vala_genie_parser_prev (self);
					found = FALSE;
				}
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_relational_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	gboolean found;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_genie_parser_parse_shift_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		ValaBinaryOperator operator;
		if (!found) {
			break;
		}
		operator = vala_genie_parser_get_binary_operator (self, vala_genie_parser_current (self));
		switch (operator) {
			case VALA_BINARY_OPERATOR_LESS_THAN:
			case VALA_BINARY_OPERATOR_LESS_THAN_OR_EQUAL:
			case VALA_BINARY_OPERATOR_GREATER_THAN_OR_EQUAL:
			{
				ValaExpression* right;
				ValaSourceReference* _tmp1_;
				ValaExpression* _tmp2_;
				vala_genie_parser_next (self);
				right = vala_genie_parser_parse_shift_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (operator, left, right, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
				_vala_source_reference_unref0 (_tmp1_);
				_vala_code_node_unref0 (right);
				break;
			}
			case VALA_BINARY_OPERATOR_GREATER_THAN:
			{
				gboolean _tmp3_ = FALSE;
				vala_genie_parser_next (self);
				if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_OP_GT) {
					_tmp3_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_OP_GE;
				} else {
					_tmp3_ = FALSE;
				}
				if (_tmp3_) {
					ValaExpression* right;
					ValaSourceReference* _tmp4_;
					ValaExpression* _tmp5_;
					right = vala_genie_parser_parse_shift_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (left);
							return NULL;
						} else {
							_vala_code_node_unref0 (left);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					left = (_tmp5_ = (ValaExpression*) vala_binary_expression_new (operator, left, right, _tmp4_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp5_);
					_vala_source_reference_unref0 (_tmp4_);
					_vala_code_node_unref0 (right);
				} else {
					vala_genie_parser_prev (self);
					found = FALSE;
				}
				break;
			}
			default:
			{
				switch (vala_genie_parser_current (self)) {
					case VALA_GENIE_TOKEN_TYPE_ISA:
					{
						ValaDataType* type;
						ValaSourceReference* _tmp6_;
						ValaExpression* _tmp7_;
						vala_genie_parser_next (self);
						type = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_code_node_unref0 (left);
								return NULL;
							} else {
								_vala_code_node_unref0 (left);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						left = (_tmp7_ = (ValaExpression*) vala_typecheck_new (left, type, _tmp6_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp7_);
						_vala_source_reference_unref0 (_tmp6_);
						_vala_code_node_unref0 (type);
						break;
					}
					case VALA_GENIE_TOKEN_TYPE_AS:
					{
						ValaDataType* type;
						ValaSourceReference* _tmp8_;
						ValaExpression* _tmp9_;
						vala_genie_parser_next (self);
						type = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_code_node_unref0 (left);
								return NULL;
							} else {
								_vala_code_node_unref0 (left);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						left = (_tmp9_ = (ValaExpression*) vala_cast_expression_new (left, type, _tmp8_ = vala_genie_parser_get_src (self, &begin), TRUE), _vala_code_node_unref0 (left), _tmp9_);
						_vala_source_reference_unref0 (_tmp8_);
						_vala_code_node_unref0 (type);
						break;
					}
					default:
					{
						found = FALSE;
						break;
					}
				}
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_equality_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	gboolean found;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_genie_parser_parse_relational_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		ValaBinaryOperator operator;
		if (!found) {
			break;
		}
		operator = vala_genie_parser_get_binary_operator (self, vala_genie_parser_current (self));
		switch (operator) {
			case VALA_BINARY_OPERATOR_INEQUALITY:
			case VALA_BINARY_OPERATOR_EQUALITY:
			{
				gboolean _tmp1_ = FALSE;
				ValaExpression* right;
				ValaSourceReference* _tmp2_;
				ValaExpression* _tmp3_;
				if (operator == VALA_BINARY_OPERATOR_INEQUALITY) {
					_tmp1_ = vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_IS;
				} else {
					_tmp1_ = FALSE;
				}
				if (_tmp1_) {
					vala_genie_parser_next (self);
				}
				vala_genie_parser_next (self);
				right = vala_genie_parser_parse_relational_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				left = (_tmp3_ = (ValaExpression*) vala_binary_expression_new (operator, left, right, _tmp2_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp3_);
				_vala_source_reference_unref0 (_tmp2_);
				_vala_code_node_unref0 (right);
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_and_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_genie_parser_parse_equality_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_BITWISE_AND)) {
			break;
		}
		right = vala_genie_parser_parse_equality_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_BITWISE_AND, left, right, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_exclusive_or_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_genie_parser_parse_and_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CARRET)) {
			break;
		}
		right = vala_genie_parser_parse_and_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_BITWISE_XOR, left, right, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_inclusive_or_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_genie_parser_parse_exclusive_or_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_BITWISE_OR)) {
			break;
		}
		right = vala_genie_parser_parse_exclusive_or_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_BITWISE_OR, left, right, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_in_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_genie_parser_parse_inclusive_or_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_IN)) {
			break;
		}
		right = vala_genie_parser_parse_inclusive_or_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_IN, left, right, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_conditional_and_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_genie_parser_parse_in_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OP_AND)) {
			break;
		}
		right = vala_genie_parser_parse_in_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_AND, left, right, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_conditional_or_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_genie_parser_parse_conditional_and_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OP_OR)) {
			break;
		}
		right = vala_genie_parser_parse_conditional_and_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_OR, left, right, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_genie_parser_parse_conditional_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* condition;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	condition = vala_genie_parser_parse_conditional_or_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INTERR)) {
		ValaExpression* true_expr;
		ValaExpression* false_expr;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		true_expr = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (true_expr);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (true_expr);
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		false_expr = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (true_expr);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (true_expr);
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = (_tmp2_ = (ValaExpression*) vala_conditional_expression_new (condition, true_expr, false_expr, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
		_vala_code_node_unref0 (false_expr);
		_vala_code_node_unref0 (true_expr);
		_vala_code_node_unref0 (condition);
		return result;
		_vala_code_node_unref0 (false_expr);
		_vala_code_node_unref0 (true_expr);
	} else {
		result = condition;
		return result;
	}
	_vala_code_node_unref0 (condition);
}


static ValaExpression* vala_genie_parser_parse_lambda_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaList* params;
	ValaLambdaExpression* lambda;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	params = (ValaList*) vala_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (params);
			return NULL;
		} else {
			_vala_collection_object_unref0 (params);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS)) {
		if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
			{
				gboolean _tmp1_;
				_tmp1_ = TRUE;
				while (TRUE) {
					char* _tmp2_;
					char* _tmp3_;
					if (!_tmp1_) {
						if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp1_ = FALSE;
					_tmp2_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_collection_object_unref0 (params);
							return NULL;
						} else {
							_vala_collection_object_unref0 (params);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_collection_add ((ValaCollection*) params, _tmp3_ = _tmp2_);
					_g_free0 (_tmp3_);
				}
			}
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (params);
				return NULL;
			} else {
				_vala_collection_object_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		char* _tmp4_;
		char* _tmp5_;
		_tmp4_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (params);
				return NULL;
			} else {
				_vala_collection_object_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_collection_add ((ValaCollection*) params, _tmp5_ = _tmp4_);
		_g_free0 (_tmp5_);
	}
	lambda = NULL;
	if (vala_genie_parser_accept_block (self)) {
		ValaBlock* block;
		ValaSourceReference* _tmp6_;
		ValaLambdaExpression* _tmp7_;
		block = vala_genie_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (lambda);
				_vala_collection_object_unref0 (params);
				return NULL;
			} else {
				_vala_code_node_unref0 (lambda);
				_vala_collection_object_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		lambda = (_tmp7_ = vala_lambda_expression_new_with_statement_body (block, _tmp6_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (lambda), _tmp7_);
		_vala_source_reference_unref0 (_tmp6_);
		_vala_code_node_unref0 (block);
	} else {
		ValaExpression* expr;
		ValaSourceReference* _tmp8_;
		ValaLambdaExpression* _tmp9_;
		expr = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (lambda);
				_vala_collection_object_unref0 (params);
				return NULL;
			} else {
				_vala_code_node_unref0 (lambda);
				_vala_collection_object_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		lambda = (_tmp9_ = vala_lambda_expression_new (expr, _tmp8_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (lambda), _tmp9_);
		_vala_source_reference_unref0 (_tmp8_);
		vala_genie_parser_expect_terminator (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (expr);
				_vala_code_node_unref0 (lambda);
				_vala_collection_object_unref0 (params);
				return NULL;
			} else {
				_vala_code_node_unref0 (expr);
				_vala_code_node_unref0 (lambda);
				_vala_collection_object_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (expr);
	}
	{
		ValaIterator* _param_it;
		_param_it = vala_iterable_iterator ((ValaIterable*) params);
		while (TRUE) {
			char* param;
			if (!vala_iterator_next (_param_it)) {
				break;
			}
			param = (char*) vala_iterator_get (_param_it);
			vala_lambda_expression_add_parameter (lambda, param);
			_g_free0 (param);
		}
		_vala_collection_object_unref0 (_param_it);
	}
	result = (ValaExpression*) lambda;
	_vala_collection_object_unref0 (params);
	return result;
}


static ValaAssignmentOperator vala_genie_parser_get_assignment_operator (ValaGenieParser* self, ValaGenieTokenType token_type) {
	ValaAssignmentOperator result = 0;
	g_return_val_if_fail (self != NULL, 0);
	switch (token_type) {
		case VALA_GENIE_TOKEN_TYPE_ASSIGN:
		{
			result = VALA_ASSIGNMENT_OPERATOR_SIMPLE;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_ADD:
		{
			result = VALA_ASSIGNMENT_OPERATOR_ADD;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_SUB:
		{
			result = VALA_ASSIGNMENT_OPERATOR_SUB;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_OR:
		{
			result = VALA_ASSIGNMENT_OPERATOR_BITWISE_OR;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_AND:
		{
			result = VALA_ASSIGNMENT_OPERATOR_BITWISE_AND;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_XOR:
		{
			result = VALA_ASSIGNMENT_OPERATOR_BITWISE_XOR;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_DIV:
		{
			result = VALA_ASSIGNMENT_OPERATOR_DIV;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_MUL:
		{
			result = VALA_ASSIGNMENT_OPERATOR_MUL;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_PERCENT:
		{
			result = VALA_ASSIGNMENT_OPERATOR_PERCENT;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_SHIFT_LEFT:
		{
			result = VALA_ASSIGNMENT_OPERATOR_SHIFT_LEFT;
			return result;
		}
		default:
		{
			result = VALA_ASSIGNMENT_OPERATOR_NONE;
			return result;
		}
	}
}


static ValaExpression* vala_genie_parser_parse_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_DEF) {
		ValaExpression* lambda;
		lambda = vala_genie_parser_parse_lambda_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		self->priv->current_expr_is_lambda = TRUE;
		result = lambda;
		return result;
	}
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	expr = vala_genie_parser_parse_conditional_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaAssignmentOperator operator;
		operator = vala_genie_parser_get_assignment_operator (self, vala_genie_parser_current (self));
		if (operator != VALA_ASSIGNMENT_OPERATOR_NONE) {
			ValaExpression* rhs;
			ValaSourceReference* _tmp1_;
			ValaExpression* _tmp2_;
			vala_genie_parser_next (self);
			rhs = vala_genie_parser_parse_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp2_ = (ValaExpression*) vala_assignment_new (expr, rhs, operator, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (expr), _tmp2_);
			_vala_source_reference_unref0 (_tmp1_);
			_vala_code_node_unref0 (rhs);
		} else {
			if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_OP_GT) {
				gchar* first_gt_pos;
				gboolean _tmp3_ = FALSE;
				first_gt_pos = self->priv->tokens[self->priv->index].begin.pos;
				vala_genie_parser_next (self);
				if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_OP_GE) {
					_tmp3_ = self->priv->tokens[self->priv->index].begin.pos == (first_gt_pos + 1);
				} else {
					_tmp3_ = FALSE;
				}
				if (_tmp3_) {
					ValaExpression* rhs;
					ValaSourceReference* _tmp4_;
					ValaExpression* _tmp5_;
					vala_genie_parser_next (self);
					rhs = vala_genie_parser_parse_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (expr);
							return NULL;
						} else {
							_vala_code_node_unref0 (expr);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					expr = (_tmp5_ = (ValaExpression*) vala_assignment_new (expr, rhs, VALA_ASSIGNMENT_OPERATOR_SHIFT_RIGHT, _tmp4_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (expr), _tmp5_);
					_vala_source_reference_unref0 (_tmp4_);
					_vala_code_node_unref0 (rhs);
				} else {
					vala_genie_parser_prev (self);
					break;
				}
			} else {
				break;
			}
		}
	}
	result = expr;
	return result;
}


static ValaStatement* vala_genie_parser_get_for_statement_type (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	gboolean is_foreach;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	is_foreach = FALSE;
	while (TRUE) {
		gboolean _tmp1_ = FALSE;
		if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_EOL) {
			_tmp1_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_DO;
		} else {
			_tmp1_ = FALSE;
		}
		if (!_tmp1_) {
			break;
		}
		vala_genie_parser_next (self);
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_IN)) {
			is_foreach = TRUE;
			break;
		}
	}
	vala_genie_parser_rollback (self, &begin);
	if (is_foreach) {
		ValaStatement* _tmp2_;
		_tmp2_ = vala_genie_parser_parse_foreach_statement (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = _tmp2_;
		return result;
	} else {
		ValaStatement* _tmp3_;
		_tmp3_ = vala_genie_parser_parse_for_statement (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = _tmp3_;
		return result;
	}
}


static void vala_genie_parser_parse_statements (ValaGenieParser* self, ValaBlock* block, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (block != NULL);
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		gboolean _tmp1_ = FALSE;
		if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_DEDENT) {
			_tmp1_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_WHEN;
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			_tmp0_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_DEFAULT;
		} else {
			_tmp0_ = FALSE;
		}
		if (!_tmp0_) {
			break;
		}
		{
			ValaStatement* stmt;
			gboolean is_decl;
			ValaComment* _tmp2_;
			stmt = NULL;
			is_decl = FALSE;
			self->priv->comment = (_tmp2_ = vala_genie_scanner_pop_comment (self->priv->scanner), _vala_comment_unref0 (self->priv->comment), _tmp2_);
			switch (vala_genie_parser_current (self)) {
				case VALA_GENIE_TOKEN_TYPE_REQUIRES:
				case VALA_GENIE_TOKEN_TYPE_ENSURES:
				{
					ValaSourceLocation _tmp3_ = {0};
					ValaSourceLocation begin;
					gboolean _tmp4_ = FALSE;
					ValaSourceReference* _tmp5_;
					ValaStatement* _tmp6_;
					begin = (vala_genie_parser_get_location (self, &_tmp3_), _tmp3_);
					vala_genie_parser_next (self);
					if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL)) {
						_tmp4_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INDENT);
					} else {
						_tmp4_ = FALSE;
					}
					if (_tmp4_) {
						while (TRUE) {
							if (!(vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_DEDENT)) {
								break;
							}
							vala_genie_parser_next (self);
						}
						vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
						if (_inner_error_ != NULL) {
							_vala_code_node_unref0 (stmt);
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch2_vala_parse_error;
							}
							_vala_code_node_unref0 (stmt);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					} else {
						while (TRUE) {
							if (!(vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_EOL)) {
								break;
							}
							vala_genie_parser_next (self);
						}
						vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
						if (_inner_error_ != NULL) {
							_vala_code_node_unref0 (stmt);
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch2_vala_parse_error;
							}
							_vala_code_node_unref0 (stmt);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
					stmt = (_tmp6_ = (ValaStatement*) vala_empty_statement_new (_tmp5_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (stmt), _tmp6_);
					_vala_source_reference_unref0 (_tmp5_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_INDENT:
				{
					ValaBlock* _tmp7_;
					ValaStatement* _tmp8_;
					_tmp7_ = vala_genie_parser_parse_block (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp8_ = (ValaStatement*) _tmp7_, _vala_code_node_unref0 (stmt), _tmp8_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_SEMICOLON:
				case VALA_GENIE_TOKEN_TYPE_PASS:
				{
					ValaStatement* _tmp9_;
					ValaStatement* _tmp10_;
					_tmp9_ = vala_genie_parser_parse_empty_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp10_ = _tmp9_, _vala_code_node_unref0 (stmt), _tmp10_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_PRINT:
				case VALA_GENIE_TOKEN_TYPE_ASSERT:
				{
					ValaStatement* _tmp11_;
					ValaStatement* _tmp12_;
					_tmp11_ = vala_genie_parser_parse_expression_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp12_ = _tmp11_, _vala_code_node_unref0 (stmt), _tmp12_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_IF:
				{
					ValaStatement* _tmp13_;
					ValaStatement* _tmp14_;
					_tmp13_ = vala_genie_parser_parse_if_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp14_ = _tmp13_, _vala_code_node_unref0 (stmt), _tmp14_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_CASE:
				{
					ValaStatement* _tmp15_;
					ValaStatement* _tmp16_;
					_tmp15_ = vala_genie_parser_parse_switch_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp16_ = _tmp15_, _vala_code_node_unref0 (stmt), _tmp16_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_WHILE:
				{
					ValaStatement* _tmp17_;
					ValaStatement* _tmp18_;
					_tmp17_ = vala_genie_parser_parse_while_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp18_ = _tmp17_, _vala_code_node_unref0 (stmt), _tmp18_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_DO:
				{
					ValaStatement* _tmp19_;
					ValaStatement* _tmp20_;
					_tmp19_ = vala_genie_parser_parse_do_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp20_ = _tmp19_, _vala_code_node_unref0 (stmt), _tmp20_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_FOR:
				{
					ValaStatement* _tmp21_;
					ValaStatement* _tmp22_;
					_tmp21_ = vala_genie_parser_get_for_statement_type (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp22_ = _tmp21_, _vala_code_node_unref0 (stmt), _tmp22_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_BREAK:
				{
					ValaStatement* _tmp23_;
					ValaStatement* _tmp24_;
					_tmp23_ = vala_genie_parser_parse_break_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp24_ = _tmp23_, _vala_code_node_unref0 (stmt), _tmp24_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_CONTINUE:
				{
					ValaStatement* _tmp25_;
					ValaStatement* _tmp26_;
					_tmp25_ = vala_genie_parser_parse_continue_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp26_ = _tmp25_, _vala_code_node_unref0 (stmt), _tmp26_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_RETURN:
				{
					ValaStatement* _tmp27_;
					ValaStatement* _tmp28_;
					_tmp27_ = vala_genie_parser_parse_return_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp28_ = _tmp27_, _vala_code_node_unref0 (stmt), _tmp28_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_RAISE:
				{
					ValaStatement* _tmp29_;
					ValaStatement* _tmp30_;
					_tmp29_ = vala_genie_parser_parse_throw_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp30_ = _tmp29_, _vala_code_node_unref0 (stmt), _tmp30_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_TRY:
				{
					ValaStatement* _tmp31_;
					ValaStatement* _tmp32_;
					_tmp31_ = vala_genie_parser_parse_try_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp32_ = _tmp31_, _vala_code_node_unref0 (stmt), _tmp32_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_LOCK:
				{
					ValaStatement* _tmp33_;
					ValaStatement* _tmp34_;
					_tmp33_ = vala_genie_parser_parse_lock_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp34_ = _tmp33_, _vala_code_node_unref0 (stmt), _tmp34_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_DELETE:
				{
					ValaStatement* _tmp35_;
					ValaStatement* _tmp36_;
					_tmp35_ = vala_genie_parser_parse_delete_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp36_ = _tmp35_, _vala_code_node_unref0 (stmt), _tmp36_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_VAR:
				{
					is_decl = TRUE;
					vala_genie_parser_parse_local_variable_declarations (self, block, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_YIELD:
				{
					ValaStatement* _tmp37_;
					ValaStatement* _tmp38_;
					_tmp37_ = vala_genie_parser_parse_yield_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp38_ = _tmp37_, _vala_code_node_unref0 (stmt), _tmp38_);
					break;
				}
				case VALA_GENIE_TOKEN_TYPE_OP_INC:
				case VALA_GENIE_TOKEN_TYPE_OP_DEC:
				case VALA_GENIE_TOKEN_TYPE_SUPER:
				case VALA_GENIE_TOKEN_TYPE_THIS:
				case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
				case VALA_GENIE_TOKEN_TYPE_STAR:
				case VALA_GENIE_TOKEN_TYPE_NEW:
				{
					ValaStatement* _tmp39_;
					ValaStatement* _tmp40_;
					_tmp39_ = vala_genie_parser_parse_expression_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp40_ = _tmp39_, _vala_code_node_unref0 (stmt), _tmp40_);
					break;
				}
				default:
				{
					gboolean is_expr;
					is_expr = vala_genie_parser_is_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch2_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					if (is_expr) {
						ValaStatement* _tmp41_;
						ValaStatement* _tmp42_;
						_tmp41_ = vala_genie_parser_parse_expression_statement (self, &_inner_error_);
						if (_inner_error_ != NULL) {
							_vala_code_node_unref0 (stmt);
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch2_vala_parse_error;
							}
							_vala_code_node_unref0 (stmt);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
						stmt = (_tmp42_ = _tmp41_, _vala_code_node_unref0 (stmt), _tmp42_);
					} else {
						is_decl = TRUE;
						vala_genie_parser_parse_local_variable_declarations (self, block, &_inner_error_);
						if (_inner_error_ != NULL) {
							_vala_code_node_unref0 (stmt);
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch2_vala_parse_error;
							}
							_vala_code_node_unref0 (stmt);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
					break;
				}
			}
			if (!is_decl) {
				vala_block_add_statement (block, stmt);
			}
			_vala_code_node_unref0 (stmt);
		}
		goto __finally2;
		__catch2_vala_parse_error:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				if (vala_genie_parser_recover (self) != VALA_GENIE_PARSER_RECOVERY_STATE_STATEMENT_BEGIN) {
					_g_error_free0 (e);
					break;
				}
				_g_error_free0 (e);
			}
		}
		__finally2:
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
}


static gboolean vala_genie_parser_is_expression (ValaGenieParser* self, GError** error) {
	gboolean result = FALSE;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_skip_type (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	switch (vala_genie_parser_current (self)) {
		case VALA_GENIE_TOKEN_TYPE_OPEN_PARENS:
		case VALA_GENIE_TOKEN_TYPE_OP_INC:
		case VALA_GENIE_TOKEN_TYPE_OP_DEC:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_ADD:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_AND:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_OR:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_BITWISE_XOR:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_DIV:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_MUL:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_PERCENT:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_SHIFT_LEFT:
		case VALA_GENIE_TOKEN_TYPE_ASSIGN_SUB:
		case VALA_GENIE_TOKEN_TYPE_OP_GT:
		case VALA_GENIE_TOKEN_TYPE_DOT:
		case VALA_GENIE_TOKEN_TYPE_OP_PTR:
		{
			vala_genie_parser_rollback (self, &begin);
			result = TRUE;
			return result;
		}
		default:
		{
			vala_genie_parser_rollback (self, &begin);
			result = FALSE;
			return result;
		}
	}
}


static ValaBlock* vala_genie_parser_parse_embedded_statement (ValaGenieParser* self, GError** error) {
	ValaBlock* result = NULL;
	ValaComment* _tmp0_;
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceLocation _tmp2_;
	ValaSourceReference* _tmp3_;
	ValaBlock* _tmp4_;
	ValaBlock* block;
	ValaStatement* _tmp5_;
	ValaStatement* _tmp6_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_INDENT) {
		ValaBlock* block;
		block = vala_genie_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = block;
		return result;
	}
	self->priv->comment = (_tmp0_ = vala_genie_scanner_pop_comment (self->priv->scanner), _vala_comment_unref0 (self->priv->comment), _tmp0_);
	block = (_tmp4_ = vala_block_new (_tmp3_ = vala_genie_parser_get_src (self, (_tmp2_ = (vala_genie_parser_get_location (self, &_tmp1_), _tmp1_), &_tmp2_))), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	_tmp5_ = vala_genie_parser_parse_embedded_statement_without_block (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_block_add_statement (block, _tmp6_ = _tmp5_);
	_vala_code_node_unref0 (_tmp6_);
	result = block;
	return result;
}


static ValaStatement* vala_genie_parser_parse_embedded_statement_without_block (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	switch (vala_genie_parser_current (self)) {
		case VALA_GENIE_TOKEN_TYPE_PASS:
		case VALA_GENIE_TOKEN_TYPE_SEMICOLON:
		{
			ValaStatement* _tmp0_;
			_tmp0_ = vala_genie_parser_parse_empty_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp0_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_IF:
		{
			ValaStatement* _tmp1_;
			_tmp1_ = vala_genie_parser_parse_if_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp1_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_CASE:
		{
			ValaStatement* _tmp2_;
			_tmp2_ = vala_genie_parser_parse_switch_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp2_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_WHILE:
		{
			ValaStatement* _tmp3_;
			_tmp3_ = vala_genie_parser_parse_while_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp3_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_DO:
		{
			ValaStatement* _tmp4_;
			_tmp4_ = vala_genie_parser_parse_do_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp4_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_FOR:
		{
			ValaStatement* _tmp5_;
			_tmp5_ = vala_genie_parser_get_for_statement_type (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp5_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_BREAK:
		{
			ValaStatement* _tmp6_;
			_tmp6_ = vala_genie_parser_parse_break_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp6_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_CONTINUE:
		{
			ValaStatement* _tmp7_;
			_tmp7_ = vala_genie_parser_parse_continue_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp7_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_RETURN:
		{
			ValaStatement* _tmp8_;
			_tmp8_ = vala_genie_parser_parse_return_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp8_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_YIELD:
		{
			ValaStatement* _tmp9_;
			_tmp9_ = vala_genie_parser_parse_yield_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp9_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_RAISE:
		{
			ValaStatement* _tmp10_;
			_tmp10_ = vala_genie_parser_parse_throw_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp10_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_TRY:
		{
			ValaStatement* _tmp11_;
			_tmp11_ = vala_genie_parser_parse_try_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp11_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_LOCK:
		{
			ValaStatement* _tmp12_;
			_tmp12_ = vala_genie_parser_parse_lock_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp12_;
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_DELETE:
		{
			ValaStatement* _tmp13_;
			_tmp13_ = vala_genie_parser_parse_delete_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp13_;
			return result;
		}
		default:
		{
			ValaStatement* _tmp14_;
			_tmp14_ = vala_genie_parser_parse_expression_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp14_;
			return result;
		}
	}
}


static ValaBlock* vala_genie_parser_parse_block (ValaGenieParser* self, GError** error) {
	ValaBlock* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaBlock* _tmp2_;
	ValaBlock* block;
	ValaSourceReference* _tmp4_;
	ValaSourceReference* _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	block = (_tmp2_ = vala_block_new (_tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	vala_genie_parser_parse_statements (self, block, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DEDENT)) {
		if (vala_report_get_errors (vala_code_context_get_report (self->priv->context)) == 0) {
			ValaSourceReference* _tmp3_;
			vala_report_error (_tmp3_ = vala_genie_parser_get_current_src (self), "tab indentation is incorrect");
			_vala_source_reference_unref0 (_tmp3_);
		}
	}
	vala_source_reference_set_last_line (vala_code_node_get_source_reference ((ValaCodeNode*) block), vala_source_reference_get_last_line (_tmp4_ = vala_genie_parser_get_current_src (self)));
	_vala_source_reference_unref0 (_tmp4_);
	vala_source_reference_set_last_column (vala_code_node_get_source_reference ((ValaCodeNode*) block), vala_source_reference_get_last_column (_tmp5_ = vala_genie_parser_get_current_src (self)));
	_vala_source_reference_unref0 (_tmp5_);
	result = block;
	return result;
}


static ValaStatement* vala_genie_parser_parse_empty_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_PASS);
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_SEMICOLON);
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_empty_statement_new (_tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	return result;
}


static void vala_genie_parser_add_local_var_variable (ValaGenieParser* self, ValaBlock* block, const char* id, GError** error) {
	ValaDataType* type_copy;
	ValaLocalVariable* local;
	ValaDeclarationStatement* _tmp0_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (block != NULL);
	g_return_if_fail (id != NULL);
	type_copy = NULL;
	local = vala_genie_parser_parse_local_variable (self, type_copy, id, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type_copy);
			return;
		} else {
			_vala_code_node_unref0 (type_copy);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	vala_block_add_statement (block, (ValaStatement*) (_tmp0_ = vala_declaration_statement_new ((ValaSymbol*) local, vala_code_node_get_source_reference ((ValaCodeNode*) local))));
	_vala_code_node_unref0 (_tmp0_);
	_vala_code_node_unref0 (local);
	_vala_code_node_unref0 (type_copy);
}


static void vala_genie_parser_parse_local_variable_declarations (ValaGenieParser* self, ValaBlock* block, GError** error) {
	ValaArrayList* id_list;
	ValaDataType* variable_type;
	ValaDataType* _tmp4_;
	ValaDataType* _tmp5_;
	ValaDataType* type;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (block != NULL);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_VAR)) {
		gboolean _tmp0_ = FALSE;
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL)) {
			_tmp0_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INDENT);
		} else {
			_tmp0_ = FALSE;
		}
		if (_tmp0_) {
			while (TRUE) {
				char* s;
				if (!(vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_DEDENT)) {
					break;
				}
				s = vala_genie_parser_parse_identifier (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				vala_genie_parser_add_local_var_variable (self, block, s, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_free0 (s);
						return;
					} else {
						_g_free0 (s);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
				vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_SEMICOLON);
				_g_free0 (s);
			}
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		} else {
			char* s;
			s = vala_genie_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			vala_genie_parser_add_local_var_variable (self, block, s, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (s);
					return;
				} else {
					_g_free0 (s);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			vala_genie_parser_expect_terminator (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (s);
					return;
				} else {
					_g_free0 (s);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			_g_free0 (s);
		}
		return;
	}
	id_list = vala_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal);
	variable_type = NULL;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			char* _tmp2_;
			char* _tmp3_;
			if (!_tmp1_) {
				if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
					break;
				}
			}
			_tmp1_ = FALSE;
			_tmp2_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (variable_type);
					_vala_collection_object_unref0 (id_list);
					return;
				} else {
					_vala_code_node_unref0 (variable_type);
					_vala_collection_object_unref0 (id_list);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			vala_collection_add ((ValaCollection*) id_list, _tmp3_ = _tmp2_);
			_g_free0 (_tmp3_);
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (variable_type);
			_vala_collection_object_unref0 (id_list);
			return;
		} else {
			_vala_code_node_unref0 (variable_type);
			_vala_collection_object_unref0 (id_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_tmp4_ = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (variable_type);
			_vala_collection_object_unref0 (id_list);
			return;
		} else {
			_vala_code_node_unref0 (variable_type);
			_vala_collection_object_unref0 (id_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	variable_type = (_tmp5_ = _tmp4_, _vala_code_node_unref0 (variable_type), _tmp5_);
	type = vala_genie_parser_parse_inline_array_type (self, variable_type, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (variable_type);
			_vala_collection_object_unref0 (id_list);
			return;
		} else {
			_vala_code_node_unref0 (variable_type);
			_vala_collection_object_unref0 (id_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	{
		ValaIterator* _id_it;
		_id_it = vala_iterable_iterator ((ValaIterable*) id_list);
		while (TRUE) {
			char* id;
			ValaDataType* type_copy;
			ValaLocalVariable* local;
			ValaDeclarationStatement* _tmp7_;
			if (!vala_iterator_next (_id_it)) {
				break;
			}
			id = (char*) vala_iterator_get (_id_it);
			type_copy = NULL;
			if (type != NULL) {
				ValaDataType* _tmp6_;
				type_copy = (_tmp6_ = vala_data_type_copy (type), _vala_code_node_unref0 (type_copy), _tmp6_);
			}
			local = vala_genie_parser_parse_local_variable (self, type_copy, id, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (type_copy);
					_g_free0 (id);
					_vala_collection_object_unref0 (_id_it);
					_vala_code_node_unref0 (type);
					_vala_code_node_unref0 (variable_type);
					_vala_collection_object_unref0 (id_list);
					return;
				} else {
					_vala_code_node_unref0 (type_copy);
					_g_free0 (id);
					_vala_collection_object_unref0 (_id_it);
					_vala_code_node_unref0 (type);
					_vala_code_node_unref0 (variable_type);
					_vala_collection_object_unref0 (id_list);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			vala_block_add_statement (block, (ValaStatement*) (_tmp7_ = vala_declaration_statement_new ((ValaSymbol*) local, vala_code_node_get_source_reference ((ValaCodeNode*) local))));
			_vala_code_node_unref0 (_tmp7_);
			_vala_code_node_unref0 (local);
			_vala_code_node_unref0 (type_copy);
			_g_free0 (id);
		}
		_vala_collection_object_unref0 (_id_it);
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			_vala_code_node_unref0 (variable_type);
			_vala_collection_object_unref0 (id_list);
			return;
		} else {
			_vala_code_node_unref0 (type);
			_vala_code_node_unref0 (variable_type);
			_vala_collection_object_unref0 (id_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_vala_code_node_unref0 (type);
	_vala_code_node_unref0 (variable_type);
	_vala_collection_object_unref0 (id_list);
}


static ValaLocalVariable* vala_genie_parser_parse_local_variable (ValaGenieParser* self, ValaDataType* variable_type, const char* id, GError** error) {
	ValaLocalVariable* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* initializer;
	ValaSourceReference* _tmp3_;
	ValaLocalVariable* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (id != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	initializer = NULL;
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN)) {
		ValaExpression* _tmp1_;
		ValaExpression* _tmp2_;
		_tmp1_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (initializer);
				return NULL;
			} else {
				_vala_code_node_unref0 (initializer);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		initializer = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (initializer), _tmp2_);
	}
	result = (_tmp4_ = vala_local_variable_new (variable_type, id, initializer, _tmp3_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	_vala_code_node_unref0 (initializer);
	return result;
	_vala_code_node_unref0 (initializer);
}


static ValaStatement* vala_genie_parser_parse_expression_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	expr = vala_genie_parser_parse_statement_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (self->priv->current_expr_is_lambda) {
		self->priv->current_expr_is_lambda = FALSE;
	} else {
		vala_genie_parser_expect_terminator (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_expression_statement_new (expr, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (expr);
	return result;
	_vala_code_node_unref0 (expr);
}


static ValaExpression* vala_genie_parser_parse_statement_expression (ValaGenieParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	expr = vala_genie_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = expr;
	return result;
}


static ValaStatement* vala_genie_parser_parse_if_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* condition;
	ValaSourceReference* src;
	ValaBlock* true_stmt;
	ValaBlock* false_stmt;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_IF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	condition = vala_genie_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DO)) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
	}
	src = vala_genie_parser_get_src (self, &begin);
	true_stmt = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_source_reference_unref0 (src);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_source_reference_unref0 (src);
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	false_stmt = NULL;
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ELSE)) {
		gboolean _tmp1_ = FALSE;
		ValaBlock* _tmp2_;
		ValaBlock* _tmp3_;
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DO)) {
			_tmp1_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_IF;
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (false_stmt);
					_vala_code_node_unref0 (true_stmt);
					_vala_source_reference_unref0 (src);
					_vala_code_node_unref0 (condition);
					return NULL;
				} else {
					_vala_code_node_unref0 (false_stmt);
					_vala_code_node_unref0 (true_stmt);
					_vala_source_reference_unref0 (src);
					_vala_code_node_unref0 (condition);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		} else {
			vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
		}
		_tmp2_ = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (false_stmt);
				_vala_code_node_unref0 (true_stmt);
				_vala_source_reference_unref0 (src);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (false_stmt);
				_vala_code_node_unref0 (true_stmt);
				_vala_source_reference_unref0 (src);
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		false_stmt = (_tmp3_ = _tmp2_, _vala_code_node_unref0 (false_stmt), _tmp3_);
	}
	result = (ValaStatement*) vala_if_statement_new (condition, true_stmt, false_stmt, src);
	_vala_code_node_unref0 (false_stmt);
	_vala_code_node_unref0 (true_stmt);
	_vala_source_reference_unref0 (src);
	_vala_code_node_unref0 (condition);
	return result;
}


static ValaStatement* vala_genie_parser_parse_switch_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* condition;
	ValaSourceReference* _tmp1_;
	ValaSwitchStatement* _tmp2_;
	ValaSwitchStatement* stmt;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CASE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	condition = vala_genie_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	stmt = (_tmp2_ = vala_switch_statement_new (condition, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (stmt);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (stmt);
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaSourceReference* _tmp3_;
		ValaSwitchSection* _tmp4_;
		ValaSwitchSection* section;
		ValaSourceReference* _tmp12_;
		ValaBreakStatement* _tmp13_;
		ValaBreakStatement* break_stmt;
		if (!(vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_DEDENT)) {
			break;
		}
		section = (_tmp4_ = vala_switch_section_new (_tmp3_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_WHEN)) {
			{
				gboolean _tmp5_;
				_tmp5_ = TRUE;
				while (TRUE) {
					ValaExpression* _tmp6_;
					ValaExpression* _tmp7_;
					ValaSourceReference* _tmp8_;
					ValaSwitchLabel* _tmp9_;
					if (!_tmp5_) {
						if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp5_ = FALSE;
					_tmp6_ = vala_genie_parser_parse_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (section);
							_vala_code_node_unref0 (stmt);
							_vala_code_node_unref0 (condition);
							return NULL;
						} else {
							_vala_code_node_unref0 (section);
							_vala_code_node_unref0 (stmt);
							_vala_code_node_unref0 (condition);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_switch_section_add_label (section, _tmp9_ = vala_switch_label_new (_tmp7_ = _tmp6_, _tmp8_ = vala_genie_parser_get_src (self, &begin)));
					_vala_code_node_unref0 (_tmp9_);
					_vala_source_reference_unref0 (_tmp8_);
					_vala_code_node_unref0 (_tmp7_);
				}
			}
		} else {
			ValaSourceReference* _tmp10_;
			ValaSwitchLabel* _tmp11_;
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEFAULT, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (section);
					_vala_code_node_unref0 (stmt);
					_vala_code_node_unref0 (condition);
					return NULL;
				} else {
					_vala_code_node_unref0 (section);
					_vala_code_node_unref0 (stmt);
					_vala_code_node_unref0 (condition);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			vala_switch_section_add_label (section, _tmp11_ = vala_switch_label_new_with_default (_tmp10_ = vala_genie_parser_get_src (self, &begin)));
			_vala_code_node_unref0 (_tmp11_);
			_vala_source_reference_unref0 (_tmp10_);
		}
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL)) {
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DO, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (section);
					_vala_code_node_unref0 (stmt);
					_vala_code_node_unref0 (condition);
					return NULL;
				} else {
					_vala_code_node_unref0 (section);
					_vala_code_node_unref0 (stmt);
					_vala_code_node_unref0 (condition);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
		vala_genie_parser_parse_statements (self, (ValaBlock*) section, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (section);
				_vala_code_node_unref0 (stmt);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (section);
				_vala_code_node_unref0 (stmt);
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		break_stmt = (_tmp13_ = vala_break_statement_new (_tmp12_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp12_), _tmp13_);
		vala_block_add_statement ((ValaBlock*) section, (ValaStatement*) break_stmt);
		vala_switch_statement_add_section (stmt, section);
		_vala_code_node_unref0 (break_stmt);
		_vala_code_node_unref0 (section);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (stmt);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (stmt);
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (ValaStatement*) stmt;
	_vala_code_node_unref0 (condition);
	return result;
}


static ValaStatement* vala_genie_parser_parse_while_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* condition;
	ValaBlock* body;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_WHILE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	condition = vala_genie_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DO)) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
	}
	body = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_while_statement_new (condition, body, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (body);
	_vala_code_node_unref0 (condition);
	return result;
	_vala_code_node_unref0 (body);
	_vala_code_node_unref0 (condition);
}


static ValaStatement* vala_genie_parser_parse_do_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaBlock* body;
	ValaExpression* condition;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DO, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	body = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_WHILE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (body);
			return NULL;
		} else {
			_vala_code_node_unref0 (body);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	condition = vala_genie_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (body);
			return NULL;
		} else {
			_vala_code_node_unref0 (body);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (body);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (body);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_do_statement_new (body, condition, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (condition);
	_vala_code_node_unref0 (body);
	return result;
	_vala_code_node_unref0 (condition);
	_vala_code_node_unref0 (body);
}


static ValaStatement* vala_genie_parser_parse_for_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaBlock* block;
	ValaExpression* initializer;
	ValaExpression* condition;
	ValaExpression* iterator;
	gboolean is_expr = FALSE;
	char* id;
	ValaSourceReference* src;
	ValaBlock* body;
	ValaForStatement* stmt;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	block = NULL;
	initializer = NULL;
	condition = NULL;
	iterator = NULL;
	id = NULL;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_FOR, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (iterator);
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (initializer);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (iterator);
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (initializer);
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	switch (vala_genie_parser_current (self)) {
		case VALA_GENIE_TOKEN_TYPE_VAR:
		{
			is_expr = FALSE;
			break;
		}
		default:
		{
			gboolean local_is_expr;
			local_is_expr = vala_genie_parser_is_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					return NULL;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			is_expr = local_is_expr;
			break;
		}
	}
	if (is_expr) {
		ValaSourceLocation _tmp1_ = {0};
		ValaSourceLocation expr_begin;
		char* _tmp2_;
		char* _tmp3_;
		ValaExpression* _tmp4_;
		ValaExpression* _tmp5_;
		expr_begin = (vala_genie_parser_get_location (self, &_tmp1_), _tmp1_);
		_tmp2_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		id = (_tmp3_ = _tmp2_, _g_free0 (id), _tmp3_);
		vala_genie_parser_rollback (self, &expr_begin);
		_tmp4_ = vala_genie_parser_parse_statement_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		initializer = (_tmp5_ = _tmp4_, _vala_code_node_unref0 (initializer), _tmp5_);
	} else {
		ValaSourceReference* _tmp6_;
		ValaBlock* _tmp7_;
		ValaDataType* variable_type;
		ValaDataType* type_copy;
		ValaLocalVariable* local;
		ValaDeclarationStatement* _tmp16_;
		block = (_tmp7_ = vala_block_new (_tmp6_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (block), _tmp7_);
		_vala_source_reference_unref0 (_tmp6_);
		variable_type = NULL;
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_VAR)) {
			ValaDataType* _tmp8_;
			char* _tmp9_;
			char* _tmp10_;
			variable_type = (_tmp8_ = NULL, _vala_code_node_unref0 (variable_type), _tmp8_);
			_tmp9_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					return NULL;
				} else {
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			id = (_tmp10_ = _tmp9_, _g_free0 (id), _tmp10_);
		} else {
			char* _tmp11_;
			char* _tmp12_;
			ValaDataType* _tmp13_;
			ValaDataType* _tmp14_;
			_tmp11_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					return NULL;
				} else {
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			id = (_tmp12_ = _tmp11_, _g_free0 (id), _tmp12_);
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					return NULL;
				} else {
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp13_ = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					return NULL;
				} else {
					_vala_code_node_unref0 (variable_type);
					_g_free0 (id);
					_vala_code_node_unref0 (iterator);
					_vala_code_node_unref0 (condition);
					_vala_code_node_unref0 (initializer);
					_vala_code_node_unref0 (block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			variable_type = (_tmp14_ = _tmp13_, _vala_code_node_unref0 (variable_type), _tmp14_);
		}
		type_copy = NULL;
		if (variable_type != NULL) {
			ValaDataType* _tmp15_;
			type_copy = (_tmp15_ = vala_data_type_copy (variable_type), _vala_code_node_unref0 (type_copy), _tmp15_);
		}
		local = vala_genie_parser_parse_local_variable (self, type_copy, id, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (type_copy);
				_vala_code_node_unref0 (variable_type);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_vala_code_node_unref0 (type_copy);
				_vala_code_node_unref0 (variable_type);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_block_add_statement (block, (ValaStatement*) (_tmp16_ = vala_declaration_statement_new ((ValaSymbol*) local, vala_code_node_get_source_reference ((ValaCodeNode*) local))));
		_vala_code_node_unref0 (_tmp16_);
		_vala_code_node_unref0 (local);
		_vala_code_node_unref0 (type_copy);
		_vala_code_node_unref0 (variable_type);
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_TO)) {
		ValaSourceLocation _tmp17_ = {0};
		ValaSourceLocation to_begin;
		ValaSourceReference* to_src;
		ValaMemberAccess* left;
		ValaExpression* right;
		ValaExpression* _tmp18_;
		ValaExpression* _tmp19_;
		to_begin = (vala_genie_parser_get_location (self, &_tmp17_), _tmp17_);
		to_src = vala_genie_parser_get_src (self, &to_begin);
		left = vala_member_access_new (NULL, id, to_src);
		right = vala_genie_parser_parse_primary_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				_vala_source_reference_unref0 (to_src);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				_vala_source_reference_unref0 (to_src);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		condition = (_tmp18_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_LESS_THAN_OR_EQUAL, (ValaExpression*) left, right, to_src), _vala_code_node_unref0 (condition), _tmp18_);
		iterator = (_tmp19_ = (ValaExpression*) vala_postfix_expression_new ((ValaExpression*) left, TRUE, to_src), _vala_code_node_unref0 (iterator), _tmp19_);
		_vala_code_node_unref0 (right);
		_vala_code_node_unref0 (left);
		_vala_source_reference_unref0 (to_src);
	} else {
		ValaSourceLocation _tmp20_ = {0};
		ValaSourceLocation downto_begin;
		ValaSourceReference* downto_src;
		ValaMemberAccess* left;
		ValaExpression* right;
		ValaExpression* _tmp21_;
		ValaExpression* _tmp22_;
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DOWNTO, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		downto_begin = (vala_genie_parser_get_location (self, &_tmp20_), _tmp20_);
		downto_src = vala_genie_parser_get_src (self, &downto_begin);
		left = vala_member_access_new (NULL, id, downto_src);
		right = vala_genie_parser_parse_primary_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				_vala_source_reference_unref0 (downto_src);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				_vala_source_reference_unref0 (downto_src);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		condition = (_tmp21_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_GREATER_THAN_OR_EQUAL, (ValaExpression*) left, right, downto_src), _vala_code_node_unref0 (condition), _tmp21_);
		iterator = (_tmp22_ = (ValaExpression*) vala_postfix_expression_new ((ValaExpression*) left, FALSE, downto_src), _vala_code_node_unref0 (iterator), _tmp22_);
		_vala_code_node_unref0 (right);
		_vala_code_node_unref0 (left);
		_vala_source_reference_unref0 (downto_src);
	}
	if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL)) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DO, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (iterator);
				_vala_code_node_unref0 (condition);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	src = vala_genie_parser_get_src (self, &begin);
	body = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_source_reference_unref0 (src);
			_g_free0 (id);
			_vala_code_node_unref0 (iterator);
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (initializer);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_source_reference_unref0 (src);
			_g_free0 (id);
			_vala_code_node_unref0 (iterator);
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (initializer);
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	stmt = vala_for_statement_new (condition, body, src);
	if (initializer != NULL) {
		vala_for_statement_add_initializer (stmt, initializer);
	}
	vala_for_statement_add_iterator (stmt, iterator);
	if (block != NULL) {
		vala_block_add_statement (block, (ValaStatement*) stmt);
		result = (ValaStatement*) block;
		_vala_code_node_unref0 (stmt);
		_vala_code_node_unref0 (body);
		_vala_source_reference_unref0 (src);
		_g_free0 (id);
		_vala_code_node_unref0 (iterator);
		_vala_code_node_unref0 (condition);
		_vala_code_node_unref0 (initializer);
		return result;
	} else {
		result = (ValaStatement*) stmt;
		_vala_code_node_unref0 (body);
		_vala_source_reference_unref0 (src);
		_g_free0 (id);
		_vala_code_node_unref0 (iterator);
		_vala_code_node_unref0 (condition);
		_vala_code_node_unref0 (initializer);
		_vala_code_node_unref0 (block);
		return result;
	}
	_vala_code_node_unref0 (stmt);
	_vala_code_node_unref0 (body);
	_vala_source_reference_unref0 (src);
	_g_free0 (id);
	_vala_code_node_unref0 (iterator);
	_vala_code_node_unref0 (condition);
	_vala_code_node_unref0 (initializer);
	_vala_code_node_unref0 (block);
}


static ValaStatement* vala_genie_parser_parse_foreach_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaDataType* type;
	char* id;
	ValaExpression* collection;
	ValaSourceReference* src;
	ValaBlock* body;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	type = NULL;
	id = NULL;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_FOR, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_VAR)) {
		char* _tmp1_;
		char* _tmp2_;
		_tmp1_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		id = (_tmp2_ = _tmp1_, _g_free0 (id), _tmp2_);
	} else {
		char* _tmp3_;
		char* _tmp4_;
		_tmp3_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		id = (_tmp4_ = _tmp3_, _g_free0 (id), _tmp4_);
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON)) {
			ValaDataType* _tmp5_;
			ValaDataType* _tmp6_;
			_tmp5_ = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return NULL;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			type = (_tmp6_ = _tmp5_, _vala_code_node_unref0 (type), _tmp6_);
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_IN, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	collection = vala_genie_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL)) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DO, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (collection);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (collection);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	src = vala_genie_parser_get_src (self, &begin);
	body = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_source_reference_unref0 (src);
			_vala_code_node_unref0 (collection);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_source_reference_unref0 (src);
			_vala_code_node_unref0 (collection);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (ValaStatement*) vala_foreach_statement_new (type, id, collection, body, src);
	_vala_code_node_unref0 (body);
	_vala_source_reference_unref0 (src);
	_vala_code_node_unref0 (collection);
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaStatement* vala_genie_parser_parse_break_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_BREAK, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_break_statement_new (_tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	return result;
}


static ValaStatement* vala_genie_parser_parse_continue_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CONTINUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_continue_statement_new (_tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	return result;
}


static ValaStatement* vala_genie_parser_parse_return_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	gboolean _tmp1_ = FALSE;
	ValaSourceReference* _tmp4_;
	ValaStatement* _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_RETURN, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = NULL;
	if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_SEMICOLON) {
		_tmp1_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_EOL;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		ValaExpression* _tmp2_;
		ValaExpression* _tmp3_;
		_tmp2_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		expr = (_tmp3_ = _tmp2_, _vala_code_node_unref0 (expr), _tmp3_);
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp5_ = (ValaStatement*) vala_return_statement_new (expr, _tmp4_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp4_), _tmp5_);
	_vala_code_node_unref0 (expr);
	return result;
	_vala_code_node_unref0 (expr);
}


static ValaStatement* vala_genie_parser_parse_yield_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	ValaExpression* expr;
	ValaSourceReference* _tmp6_;
	ValaStatement* _tmp7_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_YIELD, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_SEMICOLON) {
		_tmp2_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_EOL;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		_tmp1_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_RETURN;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		ValaStatement* _tmp3_;
		vala_genie_parser_prev (self);
		_tmp3_ = vala_genie_parser_parse_expression_statement (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = _tmp3_;
		return result;
	}
	expr = NULL;
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_RETURN)) {
		ValaExpression* _tmp4_;
		ValaExpression* _tmp5_;
		_tmp4_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		expr = (_tmp5_ = _tmp4_, _vala_code_node_unref0 (expr), _tmp5_);
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp7_ = (ValaStatement*) vala_yield_statement_new (expr, _tmp6_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp6_), _tmp7_);
	_vala_code_node_unref0 (expr);
	return result;
	_vala_code_node_unref0 (expr);
}


static ValaStatement* vala_genie_parser_parse_throw_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_RAISE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = vala_genie_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_throw_statement_new (expr, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (expr);
	return result;
	_vala_code_node_unref0 (expr);
}


static ValaStatement* vala_genie_parser_parse_try_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaBlock* try_block;
	ValaBlock* finally_clause;
	ValaArrayList* catch_clauses;
	ValaSourceReference* _tmp5_;
	ValaTryStatement* _tmp6_;
	ValaTryStatement* stmt;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_TRY, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	try_block = vala_genie_parser_parse_block (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	finally_clause = NULL;
	catch_clauses = vala_array_list_new (VALA_TYPE_CATCH_CLAUSE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_EXCEPT) {
		vala_genie_parser_parse_catch_clauses (self, (ValaList*) catch_clauses, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (catch_clauses);
				_vala_code_node_unref0 (finally_clause);
				_vala_code_node_unref0 (try_block);
				return NULL;
			} else {
				_vala_collection_object_unref0 (catch_clauses);
				_vala_code_node_unref0 (finally_clause);
				_vala_code_node_unref0 (try_block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_FINALLY) {
			ValaBlock* _tmp1_;
			ValaBlock* _tmp2_;
			_tmp1_ = vala_genie_parser_parse_finally_clause (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (catch_clauses);
					_vala_code_node_unref0 (finally_clause);
					_vala_code_node_unref0 (try_block);
					return NULL;
				} else {
					_vala_collection_object_unref0 (catch_clauses);
					_vala_code_node_unref0 (finally_clause);
					_vala_code_node_unref0 (try_block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			finally_clause = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (finally_clause), _tmp2_);
		}
	} else {
		ValaBlock* _tmp3_;
		ValaBlock* _tmp4_;
		_tmp3_ = vala_genie_parser_parse_finally_clause (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (catch_clauses);
				_vala_code_node_unref0 (finally_clause);
				_vala_code_node_unref0 (try_block);
				return NULL;
			} else {
				_vala_collection_object_unref0 (catch_clauses);
				_vala_code_node_unref0 (finally_clause);
				_vala_code_node_unref0 (try_block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		finally_clause = (_tmp4_ = _tmp3_, _vala_code_node_unref0 (finally_clause), _tmp4_);
	}
	stmt = (_tmp6_ = vala_try_statement_new (try_block, finally_clause, _tmp5_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp5_), _tmp6_);
	{
		ValaIterator* _clause_it;
		_clause_it = vala_iterable_iterator ((ValaIterable*) catch_clauses);
		while (TRUE) {
			ValaCatchClause* clause;
			if (!vala_iterator_next (_clause_it)) {
				break;
			}
			clause = (ValaCatchClause*) vala_iterator_get (_clause_it);
			vala_try_statement_add_catch_clause (stmt, clause);
			_vala_code_node_unref0 (clause);
		}
		_vala_collection_object_unref0 (_clause_it);
	}
	result = (ValaStatement*) stmt;
	_vala_collection_object_unref0 (catch_clauses);
	_vala_code_node_unref0 (finally_clause);
	_vala_code_node_unref0 (try_block);
	return result;
}


static void vala_genie_parser_parse_catch_clauses (ValaGenieParser* self, ValaList* catch_clauses, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (catch_clauses != NULL);
	while (TRUE) {
		ValaSourceLocation _tmp0_ = {0};
		ValaSourceLocation begin;
		ValaDataType* type;
		char* id;
		ValaBlock* block;
		ValaSourceReference* _tmp5_;
		ValaCatchClause* _tmp6_;
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EXCEPT)) {
			break;
		}
		begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
		type = NULL;
		id = NULL;
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL)) {
			char* _tmp1_;
			char* _tmp2_;
			ValaDataType* _tmp3_;
			ValaDataType* _tmp4_;
			_tmp1_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			id = (_tmp2_ = _tmp1_, _g_free0 (id), _tmp2_);
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			_tmp3_ = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			type = (_tmp4_ = _tmp3_, _vala_code_node_unref0 (type), _tmp4_);
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
		block = vala_genie_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		vala_collection_add ((ValaCollection*) catch_clauses, _tmp6_ = vala_catch_clause_new (type, id, block, _tmp5_ = vala_genie_parser_get_src (self, &begin)));
		_vala_code_node_unref0 (_tmp6_);
		_vala_source_reference_unref0 (_tmp5_);
		_vala_code_node_unref0 (block);
		_g_free0 (id);
		_vala_code_node_unref0 (type);
	}
}


static ValaBlock* vala_genie_parser_parse_finally_clause (ValaGenieParser* self, GError** error) {
	ValaBlock* result = NULL;
	ValaBlock* block;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_FINALLY, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_accept_block (self);
	block = vala_genie_parser_parse_block (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = block;
	return result;
}


static ValaStatement* vala_genie_parser_parse_lock_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	ValaBlock* stmt;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_LOCK, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = vala_genie_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	stmt = vala_genie_parser_parse_embedded_statement (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_lock_statement_new (expr, stmt, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (stmt);
	_vala_code_node_unref0 (expr);
	return result;
	_vala_code_node_unref0 (stmt);
	_vala_code_node_unref0 (expr);
}


static ValaStatement* vala_genie_parser_parse_delete_statement (ValaGenieParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DELETE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = vala_genie_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_delete_statement_new (expr, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (expr);
	return result;
	_vala_code_node_unref0 (expr);
}


static ValaList* vala_genie_parser_parse_attributes (ValaGenieParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* attrs;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET) {
		result = NULL;
		return result;
	}
	attrs = vala_array_list_new (VALA_TYPE_ATTRIBUTE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	while (TRUE) {
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACKET)) {
			break;
		}
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				ValaSourceLocation _tmp1_ = {0};
				ValaSourceLocation begin;
				char* id;
				ValaSourceReference* _tmp2_;
				ValaAttribute* _tmp3_;
				ValaAttribute* attr;
				if (!_tmp0_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				begin = (vala_genie_parser_get_location (self, &_tmp1_), _tmp1_);
				id = vala_genie_parser_parse_identifier (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (attrs);
						return NULL;
					} else {
						_vala_collection_object_unref0 (attrs);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				attr = (_tmp3_ = vala_attribute_new (id, _tmp2_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp2_), _tmp3_);
				if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS)) {
					if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
						{
							gboolean _tmp4_;
							_tmp4_ = TRUE;
							while (TRUE) {
								char* _tmp5_;
								char* _tmp6_;
								ValaExpression* expr;
								if (!_tmp4_) {
									if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
										break;
									}
								}
								_tmp4_ = FALSE;
								_tmp5_ = vala_genie_parser_parse_identifier (self, &_inner_error_);
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == VALA_PARSE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_collection_object_unref0 (attrs);
										return NULL;
									} else {
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_collection_object_unref0 (attrs);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return NULL;
									}
								}
								id = (_tmp6_ = _tmp5_, _g_free0 (id), _tmp6_);
								vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_ASSIGN, &_inner_error_);
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == VALA_PARSE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_collection_object_unref0 (attrs);
										return NULL;
									} else {
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_collection_object_unref0 (attrs);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return NULL;
									}
								}
								expr = vala_genie_parser_parse_expression (self, &_inner_error_);
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == VALA_PARSE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_collection_object_unref0 (attrs);
										return NULL;
									} else {
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_collection_object_unref0 (attrs);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return NULL;
									}
								}
								vala_attribute_add_argument (attr, id, expr);
								_vala_code_node_unref0 (expr);
							}
						}
					}
					vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (attr);
							_g_free0 (id);
							_vala_collection_object_unref0 (attrs);
							return NULL;
						} else {
							_vala_code_node_unref0 (attr);
							_g_free0 (id);
							_vala_collection_object_unref0 (attrs);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				vala_collection_add ((ValaCollection*) attrs, attr);
				_vala_code_node_unref0 (attr);
				_g_free0 (id);
			}
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (attrs);
				return NULL;
			} else {
				_vala_collection_object_unref0 (attrs);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (attrs);
			return NULL;
		} else {
			_vala_collection_object_unref0 (attrs);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (ValaList*) attrs;
	return result;
}


static void vala_genie_parser_set_attributes (ValaGenieParser* self, ValaCodeNode* node, ValaList* attributes) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	if (attributes != NULL) {
		{
			ValaIterator* _attr_it;
			_attr_it = vala_iterable_iterator ((ValaIterable*) VALA_LIST (attributes));
			while (TRUE) {
				ValaAttribute* attr;
				if (!vala_iterator_next (_attr_it)) {
					break;
				}
				attr = (ValaAttribute*) vala_iterator_get (_attr_it);
				node->attributes = g_list_append (node->attributes, _vala_code_node_ref0 (attr));
				_vala_code_node_unref0 (attr);
			}
			_vala_collection_object_unref0 (_attr_it);
		}
	}
}


static ValaSymbol* vala_genie_parser_parse_declaration (ValaGenieParser* self, gboolean is_root, GError** error) {
	ValaSymbol* result = NULL;
	ValaComment* _tmp0_;
	ValaList* attrs;
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceLocation begin;
	ValaGenieTokenType cur;
	ValaGenieTokenType pre;
	char* _tmp20_;
	char* _tmp21_;
	GError* _tmp22_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	self->priv->comment = (_tmp0_ = vala_genie_scanner_pop_comment (self->priv->scanner), _vala_comment_unref0 (self->priv->comment), _tmp0_);
	attrs = vala_genie_parser_parse_attributes (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	begin = (vala_genie_parser_get_location (self, &_tmp1_), _tmp1_);
	switch (vala_genie_parser_current (self)) {
		case VALA_GENIE_TOKEN_TYPE_CONST:
		{
			ValaConstant* _tmp2_;
			_tmp2_ = vala_genie_parser_parse_constant_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp2_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_CONSTRUCT:
		{
			ValaCreationMethod* _tmp3_;
			_tmp3_ = vala_genie_parser_parse_creation_method_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp3_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_CLASS:
		{
			ValaSymbol* _tmp4_;
			_tmp4_ = vala_genie_parser_parse_class_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp4_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_INIT:
		{
			if (is_root) {
				ValaMethod* _tmp5_;
				_tmp5_ = vala_genie_parser_parse_main_method_declaration (self, attrs, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (attrs);
						return NULL;
					} else {
						_vala_collection_object_unref0 (attrs);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				result = (ValaSymbol*) _tmp5_;
				_vala_collection_object_unref0 (attrs);
				return result;
			}
			if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_GOBJECT) {
				ValaConstructor* _tmp6_;
				vala_genie_parser_rollback (self, &begin);
				_tmp6_ = vala_genie_parser_parse_constructor_declaration (self, attrs, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (attrs);
						return NULL;
					} else {
						_vala_collection_object_unref0 (attrs);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				result = (ValaSymbol*) _tmp6_;
				_vala_collection_object_unref0 (attrs);
				return result;
			}
			break;
		}
		case VALA_GENIE_TOKEN_TYPE_DELEGATE:
		{
			ValaSymbol* _tmp7_;
			_tmp7_ = vala_genie_parser_parse_delegate_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp7_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_DEF:
		{
			ValaMethod* _tmp8_;
			_tmp8_ = vala_genie_parser_parse_method_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp8_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ENUM:
		{
			ValaSymbol* _tmp9_;
			_tmp9_ = vala_genie_parser_parse_enum_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp9_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_ERRORDOMAIN:
		{
			ValaSymbol* _tmp10_;
			_tmp10_ = vala_genie_parser_parse_errordomain_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp10_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_FINAL:
		{
			ValaDestructor* _tmp11_;
			_tmp11_ = vala_genie_parser_parse_destructor_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp11_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_INTERFACE:
		{
			ValaSymbol* _tmp12_;
			_tmp12_ = vala_genie_parser_parse_interface_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp12_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_NAMESPACE:
		{
			ValaNamespace* _tmp13_;
			_tmp13_ = vala_genie_parser_parse_namespace_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp13_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_PROP:
		{
			ValaProperty* _tmp14_;
			_tmp14_ = vala_genie_parser_parse_property_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp14_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_EVENT:
		{
			ValaSignal* _tmp15_;
			_tmp15_ = vala_genie_parser_parse_signal_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp15_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_GENIE_TOKEN_TYPE_STRUCT:
		{
			ValaSymbol* _tmp16_;
			_tmp16_ = vala_genie_parser_parse_struct_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp16_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		default:
		{
			while (TRUE) {
				gboolean _tmp17_ = FALSE;
				gboolean _tmp18_ = FALSE;
				if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_EOL) {
					_tmp18_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_SEMICOLON;
				} else {
					_tmp18_ = FALSE;
				}
				if (_tmp18_) {
					_tmp17_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_EOF;
				} else {
					_tmp17_ = FALSE;
				}
				if (!_tmp17_) {
					break;
				}
				if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_COLON) {
					ValaField* _tmp19_;
					vala_genie_parser_rollback (self, &begin);
					_tmp19_ = vala_genie_parser_parse_field_declaration (self, attrs, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_collection_object_unref0 (attrs);
							return NULL;
						} else {
							_vala_collection_object_unref0 (attrs);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					result = (ValaSymbol*) _tmp19_;
					_vala_collection_object_unref0 (attrs);
					return result;
				} else {
					vala_genie_parser_next (self);
				}
			}
			vala_genie_parser_rollback (self, &begin);
			break;
		}
	}
	cur = vala_genie_parser_current (self);
	pre = self->priv->tokens[self->priv->index - 1].type;
	_inner_error_ = (_tmp22_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp21_ = vala_genie_parser_get_error (self, _tmp20_ = g_strdup_printf ("expected declaration  but got %s with previous %s", vala_genie_token_type_to_string (cur), vala_genie_token_type_to_string (pre)))), _g_free0 (_tmp21_), _g_free0 (_tmp20_), _tmp22_);
	{
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (attrs);
			return NULL;
		} else {
			_vala_collection_object_unref0 (attrs);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_vala_collection_object_unref0 (attrs);
}


static void vala_genie_parser_parse_declarations (ValaGenieParser* self, ValaSymbol* parent, gboolean root, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (parent != NULL);
	if (!root) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_DEDENT) {
			_tmp0_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_EOF;
		} else {
			_tmp0_ = FALSE;
		}
		if (!_tmp0_) {
			break;
		}
		{
			if (VALA_IS_NAMESPACE (parent)) {
				vala_genie_parser_parse_namespace_member (self, VALA_NAMESPACE (parent), &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						goto __catch3_vala_parse_error;
					}
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			} else {
				if (VALA_IS_CLASS (parent)) {
					vala_genie_parser_parse_class_member (self, VALA_CLASS (parent), &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch3_vala_parse_error;
						}
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				} else {
					if (VALA_IS_STRUCT (parent)) {
						vala_genie_parser_parse_struct_member (self, VALA_STRUCT (parent), &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch3_vala_parse_error;
							}
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					} else {
						if (VALA_IS_INTERFACE (parent)) {
							vala_genie_parser_parse_interface_member (self, VALA_INTERFACE (parent), &_inner_error_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									goto __catch3_vala_parse_error;
								}
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
					}
				}
			}
		}
		goto __finally3;
		__catch3_vala_parse_error:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				gint r = 0;
				while (TRUE) {
					r = (gint) vala_genie_parser_recover (self);
					if (r == VALA_GENIE_PARSER_RECOVERY_STATE_STATEMENT_BEGIN) {
						vala_genie_parser_next (self);
					} else {
						break;
					}
				}
				if (r == VALA_GENIE_PARSER_RECOVERY_STATE_EOF) {
					_g_error_free0 (e);
					return;
				}
				_g_error_free0 (e);
			}
		}
		__finally3:
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	if (!root) {
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DEDENT)) {
			if (vala_report_get_errors (vala_code_context_get_report (self->priv->context)) == 0) {
				ValaSourceReference* _tmp1_;
				vala_report_error (_tmp1_ = vala_genie_parser_get_current_src (self), "expected dedent");
				_vala_source_reference_unref0 (_tmp1_);
			}
		}
	}
}


static ValaGenieParserRecoveryState vala_genie_parser_recover (ValaGenieParser* self) {
	ValaGenieParserRecoveryState result = 0;
	g_return_val_if_fail (self != NULL, 0);
	while (TRUE) {
		if (!(vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_EOF)) {
			break;
		}
		switch (vala_genie_parser_current (self)) {
			case VALA_GENIE_TOKEN_TYPE_CLASS:
			case VALA_GENIE_TOKEN_TYPE_CONST:
			case VALA_GENIE_TOKEN_TYPE_CONSTRUCT:
			case VALA_GENIE_TOKEN_TYPE_INIT:
			case VALA_GENIE_TOKEN_TYPE_DEF:
			case VALA_GENIE_TOKEN_TYPE_DELEGATE:
			case VALA_GENIE_TOKEN_TYPE_ENUM:
			case VALA_GENIE_TOKEN_TYPE_ERRORDOMAIN:
			case VALA_GENIE_TOKEN_TYPE_FINAL:
			case VALA_GENIE_TOKEN_TYPE_INTERFACE:
			case VALA_GENIE_TOKEN_TYPE_NAMESPACE:
			case VALA_GENIE_TOKEN_TYPE_PROP:
			case VALA_GENIE_TOKEN_TYPE_EVENT:
			case VALA_GENIE_TOKEN_TYPE_STRUCT:
			{
				result = VALA_GENIE_PARSER_RECOVERY_STATE_DECLARATION_BEGIN;
				return result;
			}
			case VALA_GENIE_TOKEN_TYPE_BREAK:
			case VALA_GENIE_TOKEN_TYPE_CASE:
			case VALA_GENIE_TOKEN_TYPE_CONTINUE:
			case VALA_GENIE_TOKEN_TYPE_DELETE:
			case VALA_GENIE_TOKEN_TYPE_DO:
			case VALA_GENIE_TOKEN_TYPE_FOR:
			case VALA_GENIE_TOKEN_TYPE_IF:
			case VALA_GENIE_TOKEN_TYPE_LOCK:
			case VALA_GENIE_TOKEN_TYPE_RETURN:
			case VALA_GENIE_TOKEN_TYPE_RAISE:
			case VALA_GENIE_TOKEN_TYPE_TRY:
			case VALA_GENIE_TOKEN_TYPE_VAR:
			case VALA_GENIE_TOKEN_TYPE_WHILE:
			case VALA_GENIE_TOKEN_TYPE_YIELD:
			{
				result = VALA_GENIE_PARSER_RECOVERY_STATE_STATEMENT_BEGIN;
				return result;
			}
			default:
			{
				vala_genie_parser_next (self);
				break;
			}
		}
	}
	result = VALA_GENIE_PARSER_RECOVERY_STATE_EOF;
	return result;
}


static ValaNamespace* vala_genie_parser_parse_namespace_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaNamespace* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaUnresolvedSymbol* sym;
	ValaSourceReference* _tmp1_;
	ValaNamespace* _tmp2_;
	ValaNamespace* ns;
	ValaNamespace* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_NAMESPACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	sym = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	ns = (_tmp2_ = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	if (self->priv->comment != NULL) {
		ValaComment* _tmp3_;
		vala_namespace_add_comment (ns, self->priv->comment);
		self->priv->comment = (_tmp3_ = NULL, _vala_comment_unref0 (self->priv->comment), _tmp3_);
	}
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) ns, attrs);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_parse_declarations (self, (ValaSymbol*) ns, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_result_ = _vala_code_node_ref0 (ns);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp4_;
		ValaNamespace* _tmp5_;
		ValaNamespace* _tmp6_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp4_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp4_);
		ns = (_tmp5_ = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) _result_)), _vala_code_node_unref0 (ns), _tmp5_);
		vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		_result_ = (_tmp6_ = _vala_code_node_ref0 (ns), _vala_code_node_unref0 (_result_), _tmp6_);
	}
	result = _result_;
	_vala_code_node_unref0 (ns);
	_vala_code_node_unref0 (sym);
	return result;
}


static void vala_genie_parser_parse_namespace_member (ValaGenieParser* self, ValaNamespace* ns, GError** error) {
	ValaSymbol* sym;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (ns != NULL);
	sym = vala_genie_parser_parse_declaration (self, ns == vala_code_context_get_root (self->priv->context), &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (VALA_IS_NAMESPACE (sym)) {
		vala_namespace_add_namespace (ns, VALA_NAMESPACE (sym));
	} else {
		if (VALA_IS_CLASS (sym)) {
			vala_namespace_add_class (ns, VALA_CLASS (sym));
		} else {
			if (VALA_IS_INTERFACE (sym)) {
				vala_namespace_add_interface (ns, VALA_INTERFACE (sym));
			} else {
				if (VALA_IS_STRUCT (sym)) {
					vala_namespace_add_struct (ns, VALA_STRUCT (sym));
				} else {
					if (VALA_IS_ENUM (sym)) {
						vala_namespace_add_enum (ns, VALA_ENUM (sym));
					} else {
						if (VALA_IS_ERROR_DOMAIN (sym)) {
							vala_namespace_add_error_domain (ns, VALA_ERROR_DOMAIN (sym));
						} else {
							if (VALA_IS_DELEGATE (sym)) {
								vala_namespace_add_delegate (ns, VALA_DELEGATE (sym));
							} else {
								if (VALA_IS_METHOD (sym)) {
									ValaMethod* method;
									method = _vala_code_node_ref0 (VALA_METHOD (sym));
									if (vala_method_get_binding (method) == MEMBER_BINDING_INSTANCE) {
										vala_method_set_binding (method, MEMBER_BINDING_STATIC);
									}
									vala_namespace_add_method (ns, method);
									_vala_code_node_unref0 (method);
								} else {
									if (VALA_IS_FIELD (sym)) {
										ValaField* field;
										field = _vala_code_node_ref0 (VALA_FIELD (sym));
										if (vala_field_get_binding (field) == MEMBER_BINDING_INSTANCE) {
											vala_field_set_binding (field, MEMBER_BINDING_STATIC);
										}
										vala_namespace_add_field (ns, field);
										_vala_code_node_unref0 (field);
									} else {
										if (VALA_IS_CONSTANT (sym)) {
											vala_namespace_add_constant (ns, VALA_CONSTANT (sym));
										} else {
											vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) sym), "unexpected declaration in namespace");
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	vala_source_file_add_node (vala_genie_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) sym);
	_vala_code_node_unref0 (sym);
}


static void vala_genie_parser_add_uses_clause (ValaGenieParser* self, ValaNamespace* ns, GError** error) {
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaUnresolvedSymbol* sym;
	ValaSourceReference* _tmp1_;
	ValaUsingDirective* _tmp2_;
	ValaUsingDirective* ns_ref;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (ns != NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	sym = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	ns_ref = (_tmp2_ = vala_using_directive_new ((ValaSymbol*) sym, _tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	vala_source_file_add_using_directive (vala_genie_scanner_get_source_file (self->priv->scanner), ns_ref);
	vala_namespace_add_using_directive (ns, ns_ref);
	_vala_code_node_unref0 (ns_ref);
	_vala_code_node_unref0 (sym);
}


static void vala_genie_parser_parse_using_directives (ValaGenieParser* self, ValaNamespace* ns, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (ns != NULL);
	while (TRUE) {
		if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_USES)) {
			break;
		}
		if (vala_genie_parser_accept_block (self)) {
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			while (TRUE) {
				gboolean _tmp0_ = FALSE;
				if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_DEDENT) {
					_tmp0_ = vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_EOF;
				} else {
					_tmp0_ = FALSE;
				}
				if (!_tmp0_) {
					break;
				}
				vala_genie_parser_add_uses_clause (self, ns, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
			}
			vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		} else {
			{
				gboolean _tmp1_;
				_tmp1_ = TRUE;
				while (TRUE) {
					if (!_tmp1_) {
						if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp1_ = FALSE;
					vala_genie_parser_add_uses_clause (self, ns, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							return;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
				}
			}
			vala_genie_parser_expect_terminator (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


static ValaSymbol* vala_genie_parser_parse_class_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaGenieParserModifierFlags flags;
	ValaUnresolvedSymbol* sym;
	ValaList* type_param_list;
	ValaArrayList* base_types;
	ValaSourceReference* _tmp2_;
	ValaClass* _tmp3_;
	ValaClass* cl;
	char* _tmp4_;
	gboolean _tmp5_ = FALSE;
	ValaSymbol* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLASS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	flags = vala_genie_parser_parse_type_declaration_modifiers (self);
	sym = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_param_list = vala_genie_parser_parse_type_parameter_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	base_types = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON)) {
		ValaDataType* type1;
		type1 = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (base_types);
				_vala_collection_object_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_collection_object_unref0 (base_types);
				_vala_collection_object_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_collection_add ((ValaCollection*) base_types, type1);
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_IMPLEMENTS)) {
			{
				gboolean _tmp1_;
				_tmp1_ = TRUE;
				while (TRUE) {
					ValaDataType* type2;
					if (!_tmp1_) {
						if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp1_ = FALSE;
					type2 = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (type1);
							_vala_collection_object_unref0 (base_types);
							_vala_collection_object_unref0 (type_param_list);
							_vala_code_node_unref0 (sym);
							return NULL;
						} else {
							_vala_code_node_unref0 (type1);
							_vala_collection_object_unref0 (base_types);
							_vala_collection_object_unref0 (type_param_list);
							_vala_code_node_unref0 (sym);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_collection_add ((ValaCollection*) base_types, type2);
					_vala_code_node_unref0 (type2);
				}
			}
		}
		_vala_code_node_unref0 (type1);
	}
	vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
	cl = (_tmp3_ = vala_class_new (vala_symbol_get_name ((ValaSymbol*) sym), _tmp2_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp2_), _tmp3_);
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		vala_symbol_set_access ((ValaSymbol*) cl, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		if (g_utf8_get_char (g_utf8_offset_to_pointer (vala_symbol_get_name ((ValaSymbol*) sym), 0)) == '_') {
			vala_symbol_set_access ((ValaSymbol*) cl, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
		} else {
			vala_symbol_set_access ((ValaSymbol*) cl, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
		}
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) {
		vala_class_set_is_abstract (cl, TRUE);
	}
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) cl, attrs);
	{
		ValaIterator* _type_param_it;
		_type_param_it = vala_iterable_iterator ((ValaIterable*) type_param_list);
		while (TRUE) {
			ValaTypeParameter* type_param;
			if (!vala_iterator_next (_type_param_it)) {
				break;
			}
			type_param = (ValaTypeParameter*) vala_iterator_get (_type_param_it);
			vala_object_type_symbol_add_type_parameter ((ValaObjectTypeSymbol*) cl, type_param);
			_vala_code_node_unref0 (type_param);
		}
		_vala_collection_object_unref0 (_type_param_it);
	}
	{
		ValaIterator* _base_type_it;
		_base_type_it = vala_iterable_iterator ((ValaIterable*) base_types);
		while (TRUE) {
			ValaDataType* base_type;
			if (!vala_iterator_next (_base_type_it)) {
				break;
			}
			base_type = (ValaDataType*) vala_iterator_get (_base_type_it);
			vala_class_add_base_type (cl, base_type);
			_vala_code_node_unref0 (base_type);
		}
		_vala_collection_object_unref0 (_base_type_it);
	}
	self->priv->class_name = (_tmp4_ = g_strdup (vala_symbol_get_name ((ValaSymbol*) cl)), _g_free0 (self->priv->class_name), _tmp4_);
	vala_genie_parser_parse_declarations (self, (ValaSymbol*) cl, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (cl);
			_vala_collection_object_unref0 (base_types);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (cl);
			_vala_collection_object_unref0 (base_types);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (!vala_source_file_get_external_package (vala_genie_scanner_get_source_file (self->priv->scanner))) {
		_tmp5_ = vala_class_get_default_construction_method (cl) == NULL;
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		ValaCreationMethod* m;
		ValaBlock* _tmp6_;
		m = vala_creation_method_new (vala_symbol_get_name ((ValaSymbol*) cl), NULL, vala_code_node_get_source_reference ((ValaCodeNode*) cl), NULL);
		vala_symbol_set_access ((ValaSymbol*) m, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
		vala_method_set_body ((ValaMethod*) m, _tmp6_ = vala_block_new (vala_code_node_get_source_reference ((ValaCodeNode*) cl)));
		_vala_code_node_unref0 (_tmp6_);
		vala_class_add_method (cl, (ValaMethod*) m);
		_vala_code_node_unref0 (m);
	}
	_result_ = _vala_code_node_ref0 ((ValaSymbol*) cl);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp7_;
		ValaNamespace* ns;
		ValaSymbol* _tmp8_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp7_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp7_);
		ns = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) cl));
		if (VALA_IS_NAMESPACE (_result_)) {
			vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		} else {
			vala_namespace_add_class (ns, VALA_CLASS (_result_));
			vala_source_file_add_node (vala_genie_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) _result_);
		}
		_result_ = (_tmp8_ = _vala_code_node_ref0 ((ValaSymbol*) ns), _vala_code_node_unref0 (_result_), _tmp8_);
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (cl);
	_vala_collection_object_unref0 (base_types);
	_vala_collection_object_unref0 (type_param_list);
	_vala_code_node_unref0 (sym);
	return result;
}


static void vala_genie_parser_parse_class_member (ValaGenieParser* self, ValaClass* cl, GError** error) {
	ValaSymbol* sym;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cl != NULL);
	sym = vala_genie_parser_parse_declaration (self, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (VALA_IS_CLASS (sym)) {
		vala_class_add_class (cl, VALA_CLASS (sym));
	} else {
		if (VALA_IS_STRUCT (sym)) {
			vala_class_add_struct (cl, VALA_STRUCT (sym));
		} else {
			if (VALA_IS_ENUM (sym)) {
				vala_class_add_enum (cl, VALA_ENUM (sym));
			} else {
				if (VALA_IS_DELEGATE (sym)) {
					vala_class_add_delegate (cl, VALA_DELEGATE (sym));
				} else {
					if (VALA_IS_METHOD (sym)) {
						vala_class_add_method (cl, VALA_METHOD (sym));
					} else {
						if (VALA_IS_SIGNAL (sym)) {
							vala_class_add_signal (cl, VALA_SIGNAL (sym));
						} else {
							if (VALA_IS_FIELD (sym)) {
								vala_class_add_field (cl, VALA_FIELD (sym));
							} else {
								if (VALA_IS_CONSTANT (sym)) {
									vala_class_add_constant (cl, VALA_CONSTANT (sym));
								} else {
									if (VALA_IS_PROPERTY (sym)) {
										vala_class_add_property (cl, VALA_PROPERTY (sym));
									} else {
										if (VALA_IS_CONSTRUCTOR (sym)) {
											ValaConstructor* c;
											c = _vala_code_node_ref0 (VALA_CONSTRUCTOR (sym));
											if (vala_constructor_get_binding (c) == MEMBER_BINDING_INSTANCE) {
												if (vala_class_get_constructor (cl) != NULL) {
													vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) c), "class already contains a constructor");
												}
												vala_class_set_constructor (cl, c);
											} else {
												if (vala_constructor_get_binding (c) == MEMBER_BINDING_CLASS) {
													if (vala_class_get_class_constructor (cl) != NULL) {
														vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) c), "class already contains a class constructor");
													}
													vala_class_set_class_constructor (cl, c);
												} else {
													if (vala_class_get_static_constructor (cl) != NULL) {
														vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) c), "class already contains a static constructor");
													}
													vala_class_set_static_constructor (cl, c);
												}
											}
											_vala_code_node_unref0 (c);
										} else {
											if (VALA_IS_DESTRUCTOR (sym)) {
												ValaDestructor* d;
												d = _vala_code_node_ref0 (VALA_DESTRUCTOR (sym));
												if (vala_destructor_get_binding (d) == MEMBER_BINDING_STATIC) {
													if (vala_class_get_static_destructor (cl) != NULL) {
														vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) d), "class already contains a static destructor");
													}
													vala_class_set_static_destructor (cl, VALA_DESTRUCTOR (d));
												} else {
													if (vala_destructor_get_binding (d) == MEMBER_BINDING_CLASS) {
														if (vala_class_get_class_destructor (cl) != NULL) {
															vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) d), "class already contains a class destructor");
														}
														vala_class_set_class_destructor (cl, VALA_DESTRUCTOR (d));
													} else {
														if (vala_class_get_destructor (cl) != NULL) {
															vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) d), "class already contains a destructor");
														}
														vala_class_set_destructor (cl, VALA_DESTRUCTOR (d));
													}
												}
												_vala_code_node_unref0 (d);
											} else {
												vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) sym), "unexpected declaration in class");
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_vala_code_node_unref0 (sym);
}


static ValaConstant* vala_genie_parser_parse_constant_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaConstant* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaGenieParserModifierFlags flags;
	char* id;
	ValaDataType* type;
	ValaDataType* _tmp1_;
	ValaDataType* _tmp2_;
	ValaExpression* initializer;
	ValaDataType* _tmp5_;
	ValaArrayType* array_type;
	ValaSourceReference* _tmp6_;
	ValaConstant* _tmp7_;
	ValaConstant* c;
	gboolean _tmp8_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CONST, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	flags = vala_genie_parser_parse_member_declaration_modifiers (self);
	id = vala_genie_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = vala_genie_parser_parse_type (self, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_inline_array_type (self, type, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (type), _tmp2_);
	initializer = NULL;
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN)) {
		ValaExpression* _tmp3_;
		ValaExpression* _tmp4_;
		_tmp3_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		initializer = (_tmp4_ = _tmp3_, _vala_code_node_unref0 (initializer), _tmp4_);
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (initializer);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			return NULL;
		} else {
			_vala_code_node_unref0 (initializer);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	array_type = _vala_code_node_ref0 ((_tmp5_ = type, VALA_IS_ARRAY_TYPE (_tmp5_) ? ((ValaArrayType*) _tmp5_) : NULL));
	if (array_type != NULL) {
		vala_data_type_set_value_owned (vala_array_type_get_element_type (array_type), FALSE);
	}
	c = (_tmp7_ = vala_constant_new (id, type, initializer, _tmp6_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp6_), _tmp7_);
	vala_symbol_set_access ((ValaSymbol*) c, vala_genie_parser_get_access (self, id));
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp8_ = TRUE;
	} else {
		_tmp8_ = vala_source_file_get_external_package (vala_genie_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp8_) {
		vala_symbol_set_external ((ValaSymbol*) c, TRUE);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) == VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) {
		vala_symbol_set_hides ((ValaSymbol*) c, TRUE);
	}
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) c, attrs);
	result = c;
	_vala_code_node_unref0 (array_type);
	_vala_code_node_unref0 (initializer);
	_vala_code_node_unref0 (type);
	_g_free0 (id);
	return result;
}


static ValaField* vala_genie_parser_parse_field_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaField* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	char* id;
	ValaGenieParserModifierFlags flags;
	ValaDataType* type;
	ValaDataType* _tmp1_;
	ValaDataType* _tmp2_;
	ValaSourceReference* _tmp3_;
	ValaField* _tmp4_;
	ValaField* f;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	id = vala_genie_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	flags = vala_genie_parser_parse_member_declaration_modifiers (self);
	type = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_genie_parser_parse_inline_array_type (self, type, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (type), _tmp2_);
	f = (_tmp4_ = vala_field_new (id, type, NULL, _tmp3_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) {
		_tmp6_ = TRUE;
	} else {
		_tmp6_ = (flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL;
	}
	if (_tmp6_) {
		_tmp5_ = TRUE;
	} else {
		_tmp5_ = (flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE;
	}
	if (_tmp5_) {
		vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) f), "abstract, virtual, and override modifiers are not applicable to fields");
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		vala_symbol_set_access ((ValaSymbol*) f, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		vala_symbol_set_access ((ValaSymbol*) f, vala_genie_parser_get_access (self, id));
	}
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) f, attrs);
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp7_ = TRUE;
	} else {
		_tmp7_ = vala_source_file_get_external_package (vala_genie_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp7_) {
		vala_symbol_set_external ((ValaSymbol*) f, TRUE);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) == VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) {
		vala_symbol_set_hides ((ValaSymbol*) f, TRUE);
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN)) {
		ValaExpression* _tmp8_;
		ValaExpression* _tmp9_;
		_tmp8_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (f);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (f);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_variable_set_initializer ((ValaVariable*) f, _tmp9_ = _tmp8_);
		_vala_code_node_unref0 (_tmp9_);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) {
		vala_field_set_binding (f, MEMBER_BINDING_STATIC);
	} else {
		if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) == VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) {
			vala_field_set_binding (f, MEMBER_BINDING_CLASS);
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (f);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			return NULL;
		} else {
			_vala_code_node_unref0 (f);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = f;
	_vala_code_node_unref0 (type);
	_g_free0 (id);
	return result;
}


static ValaInitializerList* vala_genie_parser_parse_initializer (ValaGenieParser* self, GError** error) {
	ValaInitializerList* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaInitializerList* _tmp2_;
	ValaInitializerList* initializer;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS)) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	initializer = (_tmp2_ = vala_initializer_list_new (_tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_DEDENT) {
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				ValaExpression* init;
				if (!_tmp3_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp3_ = FALSE;
				init = vala_genie_parser_parse_argument (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (initializer);
						return NULL;
					} else {
						_vala_code_node_unref0 (initializer);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_initializer_list_append (initializer, init);
				_vala_code_node_unref0 (init);
			}
		}
	}
	if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS)) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (initializer);
				return NULL;
			} else {
				_vala_code_node_unref0 (initializer);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	result = initializer;
	return result;
}


static ValaMethod* vala_genie_parser_parse_main_method_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaMethod* result = NULL;
	char* id;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaDataType* type;
	ValaSourceReference* _tmp1_;
	ValaMethod* _tmp2_;
	ValaMethod* method;
	ValaSourceReference* _tmp3_;
	ValaUnresolvedSymbol* _tmp4_;
	ValaUnresolvedSymbol* sym;
	ValaSourceReference* _tmp5_;
	ValaDataType* _tmp6_;
	ValaSourceReference* _tmp7_;
	ValaDataType* _tmp8_;
	ValaSourceReference* _tmp9_;
	ValaFormalParameter* _tmp10_;
	ValaFormalParameter* param;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	id = g_strdup ("main");
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	type = (ValaDataType*) vala_void_type_new (NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INIT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	method = (_tmp2_ = vala_method_new (id, type, _tmp1_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	vala_symbol_set_access ((ValaSymbol*) method, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) method, attrs);
	vala_method_set_binding (method, MEMBER_BINDING_STATIC);
	sym = (_tmp4_ = vala_unresolved_symbol_new (NULL, "string", _tmp3_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	type = (_tmp6_ = (ValaDataType*) vala_unresolved_type_new_from_symbol (sym, _tmp5_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (type), _tmp6_);
	_vala_source_reference_unref0 (_tmp5_);
	vala_data_type_set_value_owned (type, TRUE);
	type = (_tmp8_ = (ValaDataType*) vala_array_type_new (type, 1, _tmp7_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (type), _tmp8_);
	_vala_source_reference_unref0 (_tmp7_);
	vala_data_type_set_nullable (type, FALSE);
	param = (_tmp10_ = vala_formal_parameter_new ("args", type, _tmp9_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp9_), _tmp10_);
	vala_method_add_parameter (method, param);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (param);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (method);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			return NULL;
		} else {
			_vala_code_node_unref0 (param);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (method);
			_vala_code_node_unref0 (type);
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_accept_block (self)) {
		ValaBlock* _tmp11_;
		ValaBlock* _tmp12_;
		_tmp11_ = vala_genie_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (param);
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (param);
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_method_set_body (method, _tmp12_ = _tmp11_);
		_vala_code_node_unref0 (_tmp12_);
	}
	result = method;
	_vala_code_node_unref0 (param);
	_vala_code_node_unref0 (sym);
	_vala_code_node_unref0 (type);
	_g_free0 (id);
	return result;
}


static ValaMethod* vala_genie_parser_parse_method_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaMethod* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaDataType* type;
	ValaGenieParserModifierFlags flags;
	char* id;
	ValaArrayList* params;
	ValaList* type_param_list;
	ValaSourceReference* _tmp4_;
	ValaMethod* _tmp5_;
	ValaMethod* method;
	gboolean _tmp9_ = FALSE;
	ValaSourceLocation _tmp21_ = {0};
	ValaSourceLocation body_location;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	type = (ValaDataType*) vala_void_type_new (NULL);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	flags = vala_genie_parser_parse_member_declaration_modifiers (self);
	id = vala_genie_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	params = vala_array_list_new (VALA_TYPE_FORMAL_PARAMETER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_collection_object_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				ValaFormalParameter* param;
				if (!_tmp1_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp1_ = FALSE;
				param = vala_genie_parser_parse_parameter (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) params, param);
				_vala_code_node_unref0 (param);
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_collection_object_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON)) {
		ValaDataType* _tmp2_;
		ValaDataType* _tmp3_;
		_tmp2_ = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_collection_object_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		type = (_tmp3_ = _tmp2_, _vala_code_node_unref0 (type), _tmp3_);
	}
	type_param_list = vala_genie_parser_parse_type_parameter_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_collection_object_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	method = (_tmp5_ = vala_method_new (id, type, _tmp4_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp4_), _tmp5_);
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		vala_symbol_set_access ((ValaSymbol*) method, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		vala_symbol_set_access ((ValaSymbol*) method, vala_genie_parser_get_access (self, id));
	}
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) method, attrs);
	{
		ValaIterator* _type_param_it;
		_type_param_it = vala_iterable_iterator ((ValaIterable*) type_param_list);
		while (TRUE) {
			ValaTypeParameter* type_param;
			if (!vala_iterator_next (_type_param_it)) {
				break;
			}
			type_param = (ValaTypeParameter*) vala_iterator_get (_type_param_it);
			vala_method_add_type_parameter (method, type_param);
			_vala_code_node_unref0 (type_param);
		}
		_vala_collection_object_unref0 (_type_param_it);
	}
	{
		ValaIterator* _param_it;
		_param_it = vala_iterable_iterator ((ValaIterable*) params);
		while (TRUE) {
			ValaFormalParameter* param;
			if (!vala_iterator_next (_param_it)) {
				break;
			}
			param = (ValaFormalParameter*) vala_iterator_get (_param_it);
			vala_method_add_parameter (method, param);
			_vala_code_node_unref0 (param);
		}
		_vala_collection_object_unref0 (_param_it);
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_RAISES)) {
		{
			gboolean _tmp6_;
			_tmp6_ = TRUE;
			while (TRUE) {
				ValaDataType* _tmp7_;
				ValaDataType* _tmp8_;
				if (!_tmp6_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp6_ = FALSE;
				_tmp7_ = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_code_node_add_error_type ((ValaCodeNode*) method, _tmp8_ = _tmp7_);
				_vala_code_node_unref0 (_tmp8_);
			}
		}
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) {
		_tmp9_ = TRUE;
	} else {
		_tmp9_ = _vala_strcmp0 (id, "main") == 0;
	}
	if (_tmp9_) {
		vala_method_set_binding (method, MEMBER_BINDING_STATIC);
	} else {
		if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) == VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) {
			vala_method_set_binding (method, MEMBER_BINDING_CLASS);
		}
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC) {
		vala_method_set_coroutine (method, TRUE);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) == VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) {
		vala_symbol_set_hides ((ValaSymbol*) method, TRUE);
	}
	if (vala_method_get_binding (method) == MEMBER_BINDING_INSTANCE) {
		gboolean _tmp10_ = FALSE;
		gboolean _tmp11_ = FALSE;
		gboolean _tmp12_ = FALSE;
		if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) {
			vala_method_set_is_abstract (method, TRUE);
		}
		if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) {
			vala_method_set_is_virtual (method, TRUE);
		}
		if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE) {
			vala_method_set_overrides (method, TRUE);
		}
		if (vala_method_get_is_abstract (method)) {
			_tmp12_ = vala_method_get_is_virtual (method);
		} else {
			_tmp12_ = FALSE;
		}
		if (_tmp12_) {
			_tmp11_ = TRUE;
		} else {
			gboolean _tmp13_ = FALSE;
			if (vala_method_get_is_abstract (method)) {
				_tmp13_ = vala_method_get_overrides (method);
			} else {
				_tmp13_ = FALSE;
			}
			_tmp11_ = _tmp13_;
		}
		if (_tmp11_) {
			_tmp10_ = TRUE;
		} else {
			gboolean _tmp14_ = FALSE;
			if (vala_method_get_is_virtual (method)) {
				_tmp14_ = vala_method_get_overrides (method);
			} else {
				_tmp14_ = FALSE;
			}
			_tmp10_ = _tmp14_;
		}
		if (_tmp10_) {
			char* _tmp15_;
			GError* _tmp16_;
			_inner_error_ = (_tmp16_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp15_ = vala_genie_parser_get_error (self, "only one of `abstract', `virtual', or `override' may be specified")), _g_free0 (_tmp15_), _tmp16_);
			{
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (method);
					_vala_collection_object_unref0 (type_param_list);
					_vala_collection_object_unref0 (params);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return NULL;
				} else {
					_vala_code_node_unref0 (method);
					_vala_collection_object_unref0 (type_param_list);
					_vala_collection_object_unref0 (params);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	} else {
		gboolean _tmp17_ = FALSE;
		gboolean _tmp18_ = FALSE;
		if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) {
			_tmp18_ = TRUE;
		} else {
			_tmp18_ = (flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL;
		}
		if (_tmp18_) {
			_tmp17_ = TRUE;
		} else {
			_tmp17_ = (flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE;
		}
		if (_tmp17_) {
			char* _tmp19_;
			GError* _tmp20_;
			_inner_error_ = (_tmp20_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp19_ = vala_genie_parser_get_error (self, "the modifiers `abstract', `virtual', and `override' are not valid for " \
"static methods")), _g_free0 (_tmp19_), _tmp20_);
			{
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (method);
					_vala_collection_object_unref0 (type_param_list);
					_vala_collection_object_unref0 (params);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return NULL;
				} else {
					_vala_code_node_unref0 (method);
					_vala_collection_object_unref0 (type_param_list);
					_vala_collection_object_unref0 (params);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_INLINE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_INLINE) {
		vala_method_set_is_inline (method, TRUE);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		vala_symbol_set_external ((ValaSymbol*) method, TRUE);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (method);
			_vala_collection_object_unref0 (type_param_list);
			_vala_collection_object_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (method);
			_vala_collection_object_unref0 (type_param_list);
			_vala_collection_object_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	body_location = (vala_genie_parser_get_location (self, &_tmp21_), _tmp21_);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INDENT)) {
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_REQUIRES)) {
			gboolean _tmp22_ = FALSE;
			if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL)) {
				_tmp22_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INDENT);
			} else {
				_tmp22_ = FALSE;
			}
			if (_tmp22_) {
				while (TRUE) {
					ValaExpression* _tmp23_;
					ValaExpression* _tmp24_;
					if (!(vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_DEDENT)) {
						break;
					}
					_tmp23_ = vala_genie_parser_parse_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (method);
							_vala_collection_object_unref0 (type_param_list);
							_vala_collection_object_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (method);
							_vala_collection_object_unref0 (type_param_list);
							_vala_collection_object_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_method_add_precondition (method, _tmp24_ = _tmp23_);
					_vala_code_node_unref0 (_tmp24_);
					vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (method);
							_vala_collection_object_unref0 (type_param_list);
							_vala_collection_object_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (method);
							_vala_collection_object_unref0 (type_param_list);
							_vala_collection_object_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_genie_parser_accept_terminator (self);
			} else {
				ValaExpression* _tmp25_;
				ValaExpression* _tmp26_;
				_tmp25_ = vala_genie_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_method_add_precondition (method, _tmp26_ = _tmp25_);
				_vala_code_node_unref0 (_tmp26_);
				vala_genie_parser_expect_terminator (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
		}
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ENSURES)) {
			gboolean _tmp27_ = FALSE;
			if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL)) {
				_tmp27_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_INDENT);
			} else {
				_tmp27_ = FALSE;
			}
			if (_tmp27_) {
				while (TRUE) {
					ValaExpression* _tmp28_;
					ValaExpression* _tmp29_;
					if (!(vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_DEDENT)) {
						break;
					}
					_tmp28_ = vala_genie_parser_parse_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (method);
							_vala_collection_object_unref0 (type_param_list);
							_vala_collection_object_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (method);
							_vala_collection_object_unref0 (type_param_list);
							_vala_collection_object_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_method_add_postcondition (method, _tmp29_ = _tmp28_);
					_vala_code_node_unref0 (_tmp29_);
					vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (method);
							_vala_collection_object_unref0 (type_param_list);
							_vala_collection_object_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (method);
							_vala_collection_object_unref0 (type_param_list);
							_vala_collection_object_unref0 (params);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_genie_parser_accept_terminator (self);
			} else {
				ValaExpression* _tmp30_;
				ValaExpression* _tmp31_;
				_tmp30_ = vala_genie_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_method_add_postcondition (method, _tmp31_ = _tmp30_);
				_vala_code_node_unref0 (_tmp31_);
				vala_genie_parser_expect_terminator (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
		}
	}
	vala_genie_parser_rollback (self, &body_location);
	if (vala_genie_parser_accept_block (self)) {
		ValaBlock* _tmp32_;
		ValaBlock* _tmp33_;
		_tmp32_ = vala_genie_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_vala_collection_object_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_vala_collection_object_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_method_set_body (method, _tmp33_ = _tmp32_);
		_vala_code_node_unref0 (_tmp33_);
	} else {
		if (vala_source_file_get_external_package (vala_genie_scanner_get_source_file (self->priv->scanner))) {
			vala_symbol_set_external ((ValaSymbol*) method, TRUE);
		}
	}
	result = method;
	_vala_collection_object_unref0 (type_param_list);
	_vala_collection_object_unref0 (params);
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaProperty* vala_genie_parser_parse_property_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaProperty* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	gboolean readonly;
	ValaGenieParserModifierFlags flags;
	char* id;
	ValaDataType* type;
	ValaSourceReference* _tmp1_;
	ValaProperty* _tmp2_;
	ValaProperty* prop;
	gboolean _tmp3_ = FALSE;
	gboolean _tmp30_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	readonly = FALSE;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_PROP, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	flags = vala_genie_parser_parse_member_declaration_modifiers (self);
	readonly = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_READONLY);
	id = vala_genie_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = vala_genie_parser_parse_type (self, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	prop = (_tmp2_ = vala_property_new (id, type, NULL, NULL, _tmp1_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		vala_symbol_set_access ((ValaSymbol*) prop, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		vala_symbol_set_access ((ValaSymbol*) prop, vala_genie_parser_get_access (self, id));
	}
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) prop, attrs);
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) {
		vala_property_set_binding (prop, MEMBER_BINDING_STATIC);
	} else {
		if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) == VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) {
			vala_property_set_binding (prop, MEMBER_BINDING_CLASS);
		}
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT) {
		vala_property_set_is_abstract (prop, TRUE);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) {
		vala_property_set_is_virtual (prop, TRUE);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE) {
		vala_property_set_overrides (prop, TRUE);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) == VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) {
		vala_symbol_set_hides ((ValaSymbol*) prop, TRUE);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = vala_source_file_get_external_package (vala_genie_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp3_) {
		vala_symbol_set_external ((ValaSymbol*) prop, TRUE);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC) {
		vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) prop), "async properties are not supported yet");
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN)) {
		ValaExpression* _tmp4_;
		ValaExpression* _tmp5_;
		_tmp4_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_property_set_initializer (prop, _tmp5_ = _tmp4_);
		_vala_code_node_unref0 (_tmp5_);
	}
	if (vala_genie_parser_accept_block (self)) {
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		while (TRUE) {
			ValaSourceLocation _tmp6_ = {0};
			ValaSourceLocation accessor_begin;
			ValaList* attribs;
			ValaDataType* value_type;
			if (!(vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_DEDENT)) {
				break;
			}
			accessor_begin = (vala_genie_parser_get_location (self, &_tmp6_), _tmp6_);
			attribs = vala_genie_parser_parse_attributes (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (prop);
					_vala_code_node_unref0 (type);
					_g_free0 (id);
					return NULL;
				} else {
					_vala_code_node_unref0 (prop);
					_vala_code_node_unref0 (type);
					_g_free0 (id);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			value_type = vala_data_type_copy (type);
			vala_data_type_set_value_owned (value_type, vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OWNED));
			if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_GET)) {
				ValaBlock* block;
				ValaSourceReference* _tmp11_;
				ValaPropertyAccessor* _tmp12_;
				if (vala_property_get_get_accessor (prop) != NULL) {
					char* _tmp7_;
					GError* _tmp8_;
					_inner_error_ = (_tmp8_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp7_ = vala_genie_parser_get_error (self, "property get accessor already defined")), _g_free0 (_tmp7_), _tmp8_);
					{
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							return NULL;
						} else {
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				block = NULL;
				if (vala_genie_parser_accept_block (self)) {
					ValaBlock* _tmp9_;
					ValaBlock* _tmp10_;
					_tmp9_ = vala_genie_parser_parse_block (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (block);
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							return NULL;
						} else {
							_vala_code_node_unref0 (block);
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					block = (_tmp10_ = _tmp9_, _vala_code_node_unref0 (block), _tmp10_);
					vala_symbol_set_external ((ValaSymbol*) prop, FALSE);
				}
				vala_property_set_get_accessor (prop, _tmp12_ = vala_property_accessor_new (TRUE, FALSE, FALSE, value_type, block, _tmp11_ = vala_genie_parser_get_src (self, &accessor_begin), NULL));
				_vala_code_node_unref0 (_tmp12_);
				_vala_source_reference_unref0 (_tmp11_);
				vala_genie_parser_set_attributes (self, (ValaCodeNode*) vala_property_get_get_accessor (prop), attribs);
				vala_symbol_set_access ((ValaSymbol*) vala_property_get_get_accessor (prop), VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
				_vala_code_node_unref0 (block);
			} else {
				gboolean _construct;
				ValaBlock* block;
				ValaSourceReference* _tmp23_;
				ValaPropertyAccessor* _tmp24_;
				_construct = FALSE;
				if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_SET)) {
					gboolean _tmp15_ = FALSE;
					if (readonly) {
						char* _tmp13_;
						GError* _tmp14_;
						_inner_error_ = (_tmp14_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp13_ = vala_genie_parser_get_error (self, "set block not allowed for a read only property")), _g_free0 (_tmp13_), _tmp14_);
						{
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_code_node_unref0 (value_type);
								_vala_collection_object_unref0 (attribs);
								_vala_code_node_unref0 (prop);
								_vala_code_node_unref0 (type);
								_g_free0 (id);
								return NULL;
							} else {
								_vala_code_node_unref0 (value_type);
								_vala_collection_object_unref0 (attribs);
								_vala_code_node_unref0 (prop);
								_vala_code_node_unref0 (type);
								_g_free0 (id);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
					}
					if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_GOBJECT) {
						_tmp15_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CONSTRUCT);
					} else {
						_tmp15_ = FALSE;
					}
					_construct = _tmp15_;
				} else {
					gboolean _tmp16_ = FALSE;
					if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_GOBJECT) {
						_tmp16_ = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_CONSTRUCT);
					} else {
						_tmp16_ = FALSE;
					}
					if (_tmp16_) {
						_construct = TRUE;
					} else {
						if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL)) {
							char* _tmp17_;
							GError* _tmp18_;
							_inner_error_ = (_tmp18_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp17_ = vala_genie_parser_get_error (self, "expected get, set, or construct")), _g_free0 (_tmp17_), _tmp18_);
							{
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									g_propagate_error (error, _inner_error_);
									_vala_code_node_unref0 (value_type);
									_vala_collection_object_unref0 (attribs);
									_vala_code_node_unref0 (prop);
									_vala_code_node_unref0 (type);
									_g_free0 (id);
									return NULL;
								} else {
									_vala_code_node_unref0 (value_type);
									_vala_collection_object_unref0 (attribs);
									_vala_code_node_unref0 (prop);
									_vala_code_node_unref0 (type);
									_g_free0 (id);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return NULL;
								}
							}
						}
					}
				}
				if (vala_property_get_set_accessor (prop) != NULL) {
					char* _tmp19_;
					GError* _tmp20_;
					_inner_error_ = (_tmp20_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp19_ = vala_genie_parser_get_error (self, "property set accessor already defined")), _g_free0 (_tmp19_), _tmp20_);
					{
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							return NULL;
						} else {
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				block = NULL;
				if (vala_genie_parser_accept_block (self)) {
					ValaBlock* _tmp21_;
					ValaBlock* _tmp22_;
					_tmp21_ = vala_genie_parser_parse_block (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (block);
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							return NULL;
						} else {
							_vala_code_node_unref0 (block);
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (attribs);
							_vala_code_node_unref0 (prop);
							_vala_code_node_unref0 (type);
							_g_free0 (id);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					block = (_tmp22_ = _tmp21_, _vala_code_node_unref0 (block), _tmp22_);
					vala_symbol_set_external ((ValaSymbol*) prop, FALSE);
				}
				vala_property_set_set_accessor (prop, _tmp24_ = vala_property_accessor_new (FALSE, !readonly, _construct, value_type, block, _tmp23_ = vala_genie_parser_get_src (self, &accessor_begin), NULL));
				_vala_code_node_unref0 (_tmp24_);
				_vala_source_reference_unref0 (_tmp23_);
				vala_genie_parser_set_attributes (self, (ValaCodeNode*) vala_property_get_set_accessor (prop), attribs);
				vala_symbol_set_access ((ValaSymbol*) vala_property_get_set_accessor (prop), VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
				_vala_code_node_unref0 (block);
			}
			_vala_code_node_unref0 (value_type);
			_vala_collection_object_unref0 (attribs);
		}
		vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		ValaDataType* value_type;
		ValaSourceReference* _tmp25_;
		ValaPropertyAccessor* _tmp26_;
		value_type = vala_data_type_copy (type);
		vala_data_type_set_value_owned (value_type, FALSE);
		vala_property_set_get_accessor (prop, _tmp26_ = vala_property_accessor_new (TRUE, FALSE, FALSE, value_type, NULL, _tmp25_ = vala_genie_parser_get_src (self, &begin), NULL));
		_vala_code_node_unref0 (_tmp26_);
		_vala_source_reference_unref0 (_tmp25_);
		vala_symbol_set_access ((ValaSymbol*) vala_property_get_get_accessor (prop), VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
		if (!readonly) {
			ValaDataType* _tmp27_;
			ValaSourceReference* _tmp28_;
			ValaPropertyAccessor* _tmp29_;
			value_type = (_tmp27_ = vala_data_type_copy (type), _vala_code_node_unref0 (value_type), _tmp27_);
			vala_data_type_set_value_owned (value_type, FALSE);
			vala_property_set_set_accessor (prop, _tmp29_ = vala_property_accessor_new (FALSE, TRUE, FALSE, value_type, NULL, _tmp28_ = vala_genie_parser_get_src (self, &begin), NULL));
			_vala_code_node_unref0 (_tmp29_);
			_vala_source_reference_unref0 (_tmp28_);
			vala_symbol_set_access ((ValaSymbol*) vala_property_get_set_accessor (prop), VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
		}
		vala_genie_parser_expect_terminator (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (value_type);
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (value_type);
				_vala_code_node_unref0 (prop);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (value_type);
	}
	if (!vala_property_get_is_abstract (prop)) {
		_tmp30_ = !vala_source_file_get_external_package (vala_genie_scanner_get_source_file (self->priv->scanner));
	} else {
		_tmp30_ = FALSE;
	}
	if (_tmp30_) {
		gboolean _tmp31_ = FALSE;
		gboolean needs_var;
		if (readonly) {
			gboolean _tmp32_ = FALSE;
			if (vala_property_get_get_accessor (prop) != NULL) {
				_tmp32_ = vala_property_accessor_get_body (vala_property_get_get_accessor (prop)) == NULL;
			} else {
				_tmp32_ = FALSE;
			}
			_tmp31_ = _tmp32_;
		} else {
			_tmp31_ = FALSE;
		}
		needs_var = _tmp31_;
		if (!needs_var) {
			gboolean _tmp33_ = FALSE;
			gboolean _tmp34_ = FALSE;
			if (vala_property_get_get_accessor (prop) != NULL) {
				_tmp34_ = vala_property_accessor_get_body (vala_property_get_get_accessor (prop)) == NULL;
			} else {
				_tmp34_ = FALSE;
			}
			if (_tmp34_) {
				_tmp33_ = TRUE;
			} else {
				gboolean _tmp35_ = FALSE;
				if (vala_property_get_set_accessor (prop) != NULL) {
					_tmp35_ = vala_property_accessor_get_body (vala_property_get_set_accessor (prop)) == NULL;
				} else {
					_tmp35_ = FALSE;
				}
				_tmp33_ = _tmp35_;
			}
			needs_var = _tmp33_;
		}
		if (needs_var) {
			ValaDataType* variable_type;
			char* _tmp36_;
			ValaField* _tmp37_;
			variable_type = vala_data_type_copy (vala_property_get_property_type (prop));
			vala_property_set_field (prop, _tmp37_ = vala_field_new (_tmp36_ = g_strdup_printf ("_%s", vala_symbol_get_name ((ValaSymbol*) prop)), variable_type, vala_property_get_initializer (prop), vala_code_node_get_source_reference ((ValaCodeNode*) prop), NULL));
			_vala_code_node_unref0 (_tmp37_);
			_g_free0 (_tmp36_);
			vala_symbol_set_access ((ValaSymbol*) vala_property_get_field (prop), VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
			vala_field_set_binding (vala_property_get_field (prop), vala_property_get_binding (prop));
			_vala_code_node_unref0 (variable_type);
		}
	}
	result = prop;
	_vala_code_node_unref0 (type);
	_g_free0 (id);
	return result;
}


static ValaSignal* vala_genie_parser_parse_signal_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSignal* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaDataType* type;
	ValaGenieParserModifierFlags flags;
	char* id;
	ValaArrayList* params;
	ValaSourceReference* _tmp5_;
	ValaSignal* _tmp6_;
	ValaSignal* sig;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	type = NULL;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EVENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	flags = vala_genie_parser_parse_member_declaration_modifiers (self);
	id = vala_genie_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	params = vala_array_list_new (VALA_TYPE_FORMAL_PARAMETER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_collection_object_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				ValaFormalParameter* param;
				if (!_tmp1_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp1_ = FALSE;
				param = vala_genie_parser_parse_parameter (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_collection_object_unref0 (params);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) params, param);
				_vala_code_node_unref0 (param);
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_collection_object_unref0 (params);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON)) {
		ValaDataType* _tmp2_;
		ValaDataType* _tmp3_;
		_tmp2_ = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_collection_object_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		type = (_tmp3_ = _tmp2_, _vala_code_node_unref0 (type), _tmp3_);
	} else {
		ValaDataType* _tmp4_;
		type = (_tmp4_ = (ValaDataType*) vala_void_type_new (NULL), _vala_code_node_unref0 (type), _tmp4_);
	}
	sig = (_tmp6_ = vala_signal_new (id, type, _tmp5_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp5_), _tmp6_);
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		vala_symbol_set_access ((ValaSymbol*) sig, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		vala_symbol_set_access ((ValaSymbol*) sig, vala_genie_parser_get_access (self, id));
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL) {
		vala_signal_set_is_virtual (sig, TRUE);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) == VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) {
		vala_symbol_set_hides ((ValaSymbol*) sig, TRUE);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) {
		char* _tmp7_;
		GError* _tmp8_;
		_inner_error_ = (_tmp8_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp7_ = vala_genie_parser_get_error (self, "`static' modifier not allowed on signals")), _g_free0 (_tmp7_), _tmp8_);
		{
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sig);
				_vala_collection_object_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (sig);
				_vala_collection_object_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) == VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) {
			char* _tmp9_;
			GError* _tmp10_;
			_inner_error_ = (_tmp10_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp9_ = vala_genie_parser_get_error (self, "`class' modifier not allowed on signals")), _g_free0 (_tmp9_), _tmp10_);
			{
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (sig);
					_vala_collection_object_unref0 (params);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return NULL;
				} else {
					_vala_code_node_unref0 (sig);
					_vala_collection_object_unref0 (params);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	}
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) sig, attrs);
	{
		ValaIterator* _formal_param_it;
		_formal_param_it = vala_iterable_iterator ((ValaIterable*) params);
		while (TRUE) {
			ValaFormalParameter* formal_param;
			if (!vala_iterator_next (_formal_param_it)) {
				break;
			}
			formal_param = (ValaFormalParameter*) vala_iterator_get (_formal_param_it);
			vala_signal_add_parameter (sig, formal_param);
			_vala_code_node_unref0 (formal_param);
		}
		_vala_collection_object_unref0 (_formal_param_it);
	}
	if (!vala_genie_parser_accept_terminator (self)) {
		ValaBlock* _tmp11_;
		ValaBlock* _tmp12_;
		_tmp11_ = vala_genie_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sig);
				_vala_collection_object_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (sig);
				_vala_collection_object_unref0 (params);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_signal_set_body (sig, _tmp12_ = _tmp11_);
		_vala_code_node_unref0 (_tmp12_);
	}
	result = sig;
	_vala_collection_object_unref0 (params);
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaConstructor* vala_genie_parser_parse_constructor_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaConstructor* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaGenieParserModifierFlags flags;
	ValaSourceReference* _tmp1_;
	ValaConstructor* _tmp2_;
	ValaConstructor* c;
	ValaBlock* _tmp3_;
	ValaBlock* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INIT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	flags = vala_genie_parser_parse_member_declaration_modifiers (self);
	c = (_tmp2_ = vala_constructor_new (_tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) {
		vala_constructor_set_binding (c, MEMBER_BINDING_STATIC);
	} else {
		if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) == VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS) {
			vala_constructor_set_binding (c, MEMBER_BINDING_CLASS);
		}
	}
	vala_genie_parser_accept_block (self);
	_tmp3_ = vala_genie_parser_parse_block (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (c);
			return NULL;
		} else {
			_vala_code_node_unref0 (c);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_constructor_set_body (c, _tmp4_ = _tmp3_);
	_vala_code_node_unref0 (_tmp4_);
	result = c;
	return result;
}


static ValaDestructor* vala_genie_parser_parse_destructor_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaDestructor* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaDestructor* _tmp2_;
	ValaDestructor* d;
	ValaBlock* _tmp3_;
	ValaBlock* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_FINAL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	d = (_tmp2_ = vala_destructor_new (_tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	vala_genie_parser_accept_block (self);
	_tmp3_ = vala_genie_parser_parse_block (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (d);
			return NULL;
		} else {
			_vala_code_node_unref0 (d);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_destructor_set_body (d, _tmp4_ = _tmp3_);
	_vala_code_node_unref0 (_tmp4_);
	result = d;
	return result;
}


static ValaSymbol* vala_genie_parser_parse_struct_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaGenieParserModifierFlags flags;
	ValaUnresolvedSymbol* sym;
	ValaList* type_param_list;
	ValaDataType* base_type;
	ValaSourceReference* _tmp3_;
	ValaStruct* _tmp4_;
	ValaStruct* st;
	ValaSymbol* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_STRUCT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	flags = vala_genie_parser_parse_type_declaration_modifiers (self);
	sym = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_param_list = vala_genie_parser_parse_type_parameter_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	base_type = NULL;
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON)) {
		ValaDataType* _tmp1_;
		ValaDataType* _tmp2_;
		_tmp1_ = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (base_type);
				_vala_collection_object_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (base_type);
				_vala_collection_object_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		base_type = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (base_type), _tmp2_);
	}
	st = (_tmp4_ = vala_struct_new (vala_symbol_get_name ((ValaSymbol*) sym), _tmp3_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		vala_symbol_set_access ((ValaSymbol*) st, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		vala_symbol_set_access ((ValaSymbol*) st, vala_genie_parser_get_access (self, vala_symbol_get_name ((ValaSymbol*) sym)));
	}
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) st, attrs);
	{
		ValaIterator* _type_param_it;
		_type_param_it = vala_iterable_iterator ((ValaIterable*) type_param_list);
		while (TRUE) {
			ValaTypeParameter* type_param;
			if (!vala_iterator_next (_type_param_it)) {
				break;
			}
			type_param = (ValaTypeParameter*) vala_iterator_get (_type_param_it);
			vala_struct_add_type_parameter (st, type_param);
			_vala_code_node_unref0 (type_param);
		}
		_vala_collection_object_unref0 (_type_param_it);
	}
	if (base_type != NULL) {
		vala_struct_set_base_type (st, base_type);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (st);
			_vala_code_node_unref0 (base_type);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (st);
			_vala_code_node_unref0 (base_type);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_parse_declarations (self, (ValaSymbol*) st, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (st);
			_vala_code_node_unref0 (base_type);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (st);
			_vala_code_node_unref0 (base_type);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_result_ = _vala_code_node_ref0 ((ValaSymbol*) st);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp5_;
		ValaNamespace* ns;
		ValaSymbol* _tmp6_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp5_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp5_);
		ns = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) st));
		if (VALA_IS_NAMESPACE (_result_)) {
			vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		} else {
			vala_namespace_add_struct (ns, VALA_STRUCT (_result_));
			vala_source_file_add_node (vala_genie_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) _result_);
		}
		_result_ = (_tmp6_ = _vala_code_node_ref0 ((ValaSymbol*) ns), _vala_code_node_unref0 (_result_), _tmp6_);
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (st);
	_vala_code_node_unref0 (base_type);
	_vala_collection_object_unref0 (type_param_list);
	_vala_code_node_unref0 (sym);
	return result;
}


static void vala_genie_parser_parse_struct_member (ValaGenieParser* self, ValaStruct* st, GError** error) {
	ValaSymbol* sym;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (st != NULL);
	sym = vala_genie_parser_parse_declaration (self, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (VALA_IS_METHOD (sym)) {
		vala_struct_add_method (st, VALA_METHOD (sym));
	} else {
		if (VALA_IS_FIELD (sym)) {
			vala_struct_add_field (st, VALA_FIELD (sym));
		} else {
			if (VALA_IS_CONSTANT (sym)) {
				vala_struct_add_constant (st, VALA_CONSTANT (sym));
			} else {
				vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) sym), "unexpected declaration in struct");
			}
		}
	}
	_vala_code_node_unref0 (sym);
}


static ValaSymbol* vala_genie_parser_parse_interface_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaGenieParserModifierFlags flags;
	ValaUnresolvedSymbol* sym;
	ValaList* type_param_list;
	ValaArrayList* base_types;
	ValaSourceReference* _tmp2_;
	ValaInterface* _tmp3_;
	ValaInterface* iface;
	gboolean _tmp4_ = FALSE;
	ValaSymbol* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INTERFACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	flags = vala_genie_parser_parse_type_declaration_modifiers (self);
	sym = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_param_list = vala_genie_parser_parse_type_parameter_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	base_types = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON)) {
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				ValaDataType* type;
				if (!_tmp1_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp1_ = FALSE;
				type = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (base_types);
						_vala_collection_object_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						return NULL;
					} else {
						_vala_collection_object_unref0 (base_types);
						_vala_collection_object_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) base_types, type);
				_vala_code_node_unref0 (type);
			}
		}
	}
	iface = (_tmp3_ = vala_interface_new (vala_symbol_get_name ((ValaSymbol*) sym), _tmp2_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp2_), _tmp3_);
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		vala_symbol_set_access ((ValaSymbol*) iface, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		vala_symbol_set_access ((ValaSymbol*) iface, vala_genie_parser_get_access (self, vala_symbol_get_name ((ValaSymbol*) sym)));
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp4_ = TRUE;
	} else {
		_tmp4_ = vala_source_file_get_external_package (vala_genie_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp4_) {
		vala_symbol_set_external ((ValaSymbol*) iface, TRUE);
	}
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) iface, attrs);
	{
		ValaIterator* _type_param_it;
		_type_param_it = vala_iterable_iterator ((ValaIterable*) type_param_list);
		while (TRUE) {
			ValaTypeParameter* type_param;
			if (!vala_iterator_next (_type_param_it)) {
				break;
			}
			type_param = (ValaTypeParameter*) vala_iterator_get (_type_param_it);
			vala_object_type_symbol_add_type_parameter ((ValaObjectTypeSymbol*) iface, type_param);
			_vala_code_node_unref0 (type_param);
		}
		_vala_collection_object_unref0 (_type_param_it);
	}
	{
		ValaIterator* _base_type_it;
		_base_type_it = vala_iterable_iterator ((ValaIterable*) base_types);
		while (TRUE) {
			ValaDataType* base_type;
			if (!vala_iterator_next (_base_type_it)) {
				break;
			}
			base_type = (ValaDataType*) vala_iterator_get (_base_type_it);
			vala_interface_add_prerequisite (iface, base_type);
			_vala_code_node_unref0 (base_type);
		}
		_vala_collection_object_unref0 (_base_type_it);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (iface);
			_vala_collection_object_unref0 (base_types);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (iface);
			_vala_collection_object_unref0 (base_types);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_parse_declarations (self, (ValaSymbol*) iface, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (iface);
			_vala_collection_object_unref0 (base_types);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (iface);
			_vala_collection_object_unref0 (base_types);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_result_ = _vala_code_node_ref0 ((ValaSymbol*) iface);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp5_;
		ValaNamespace* ns;
		ValaSymbol* _tmp6_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp5_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp5_);
		ns = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) iface));
		if (VALA_IS_NAMESPACE (_result_)) {
			vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		} else {
			vala_namespace_add_interface (ns, VALA_INTERFACE (_result_));
			vala_source_file_add_node (vala_genie_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) _result_);
		}
		_result_ = (_tmp6_ = _vala_code_node_ref0 ((ValaSymbol*) ns), _vala_code_node_unref0 (_result_), _tmp6_);
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (iface);
	_vala_collection_object_unref0 (base_types);
	_vala_collection_object_unref0 (type_param_list);
	_vala_code_node_unref0 (sym);
	return result;
}


static void vala_genie_parser_parse_interface_member (ValaGenieParser* self, ValaInterface* iface, GError** error) {
	ValaSymbol* sym;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (iface != NULL);
	sym = vala_genie_parser_parse_declaration (self, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (VALA_IS_CLASS (sym)) {
		vala_interface_add_class (iface, VALA_CLASS (sym));
	} else {
		if (VALA_IS_STRUCT (sym)) {
			vala_interface_add_struct (iface, VALA_STRUCT (sym));
		} else {
			if (VALA_IS_ENUM (sym)) {
				vala_interface_add_enum (iface, VALA_ENUM (sym));
			} else {
				if (VALA_IS_DELEGATE (sym)) {
					vala_interface_add_delegate (iface, VALA_DELEGATE (sym));
				} else {
					if (VALA_IS_METHOD (sym)) {
						vala_interface_add_method (iface, VALA_METHOD (sym));
					} else {
						if (VALA_IS_SIGNAL (sym)) {
							vala_interface_add_signal (iface, VALA_SIGNAL (sym));
						} else {
							if (VALA_IS_FIELD (sym)) {
								vala_interface_add_field (iface, VALA_FIELD (sym));
							} else {
								if (VALA_IS_CONSTANT (sym)) {
									vala_interface_add_constant (iface, VALA_CONSTANT (sym));
								} else {
									if (VALA_IS_PROPERTY (sym)) {
										vala_interface_add_property (iface, VALA_PROPERTY (sym));
									} else {
										vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) sym), "unexpected declaration in interface");
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_vala_code_node_unref0 (sym);
}


static ValaSymbol* vala_genie_parser_parse_enum_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaGenieParserModifierFlags flags;
	ValaUnresolvedSymbol* sym;
	ValaSourceReference* _tmp1_;
	ValaEnum* _tmp2_;
	ValaEnum* en;
	gboolean _tmp3_ = FALSE;
	ValaSymbol* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_ENUM, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	flags = vala_genie_parser_parse_type_declaration_modifiers (self);
	sym = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	en = (_tmp2_ = vala_enum_new (vala_symbol_get_name ((ValaSymbol*) sym), _tmp1_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		vala_symbol_set_access ((ValaSymbol*) en, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		vala_symbol_set_access ((ValaSymbol*) en, vala_genie_parser_get_access (self, vala_symbol_get_name ((ValaSymbol*) sym)));
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = vala_source_file_get_external_package (vala_genie_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp3_) {
		vala_symbol_set_external ((ValaSymbol*) en, TRUE);
	}
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) en, attrs);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaList* value_attrs;
		ValaSourceLocation _tmp4_ = {0};
		ValaSourceLocation value_begin;
		char* id;
		ValaComment* _tmp5_;
		ValaExpression* value;
		ValaSourceReference* _tmp8_;
		ValaEnumValue* _tmp9_;
		ValaEnumValue* ev;
		if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_DEDENT) {
			break;
		}
		value_attrs = vala_genie_parser_parse_attributes (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (en);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (en);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		value_begin = (vala_genie_parser_get_location (self, &_tmp4_), _tmp4_);
		id = vala_genie_parser_parse_identifier (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (value_attrs);
				_vala_code_node_unref0 (en);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_collection_object_unref0 (value_attrs);
				_vala_code_node_unref0 (en);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		self->priv->comment = (_tmp5_ = vala_genie_scanner_pop_comment (self->priv->scanner), _vala_comment_unref0 (self->priv->comment), _tmp5_);
		value = NULL;
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN)) {
			ValaExpression* _tmp6_;
			ValaExpression* _tmp7_;
			_tmp6_ = vala_genie_parser_parse_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (value);
					_g_free0 (id);
					_vala_collection_object_unref0 (value_attrs);
					_vala_code_node_unref0 (en);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_code_node_unref0 (value);
					_g_free0 (id);
					_vala_collection_object_unref0 (value_attrs);
					_vala_code_node_unref0 (en);
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			value = (_tmp7_ = _tmp6_, _vala_code_node_unref0 (value), _tmp7_);
		}
		ev = (_tmp9_ = vala_enum_value_new (id, value, _tmp8_ = vala_genie_parser_get_src (self, &value_begin), self->priv->comment), _vala_source_reference_unref0 (_tmp8_), _tmp9_);
		vala_genie_parser_set_attributes (self, (ValaCodeNode*) ev, value_attrs);
		vala_enum_add_value (en, ev);
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (ev);
				_vala_code_node_unref0 (value);
				_g_free0 (id);
				_vala_collection_object_unref0 (value_attrs);
				_vala_code_node_unref0 (en);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (ev);
				_vala_code_node_unref0 (value);
				_g_free0 (id);
				_vala_collection_object_unref0 (value_attrs);
				_vala_code_node_unref0 (en);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (ev);
		_vala_code_node_unref0 (value);
		_g_free0 (id);
		_vala_collection_object_unref0 (value_attrs);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_result_ = _vala_code_node_ref0 ((ValaSymbol*) en);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp10_;
		ValaNamespace* ns;
		ValaSymbol* _tmp11_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp10_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp10_);
		ns = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) en));
		if (VALA_IS_NAMESPACE (_result_)) {
			vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		} else {
			vala_namespace_add_enum (ns, VALA_ENUM (_result_));
			vala_source_file_add_node (vala_genie_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) _result_);
		}
		_result_ = (_tmp11_ = _vala_code_node_ref0 ((ValaSymbol*) ns), _vala_code_node_unref0 (_result_), _tmp11_);
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (en);
	_vala_code_node_unref0 (sym);
	return result;
}


static ValaSymbol* vala_genie_parser_parse_errordomain_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaGenieParserModifierFlags flags;
	ValaUnresolvedSymbol* sym;
	ValaSourceReference* _tmp1_;
	ValaErrorDomain* _tmp2_;
	ValaErrorDomain* ed;
	ValaSymbol* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_ERRORDOMAIN, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	flags = vala_genie_parser_parse_type_declaration_modifiers (self);
	sym = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	ed = (_tmp2_ = vala_error_domain_new (vala_symbol_get_name ((ValaSymbol*) sym), _tmp1_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		vala_symbol_set_access ((ValaSymbol*) ed, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		vala_symbol_set_access ((ValaSymbol*) ed, vala_genie_parser_get_access (self, vala_symbol_get_name ((ValaSymbol*) sym)));
	}
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) ed, attrs);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_EOL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_INDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaList* code_attrs;
		ValaSourceLocation _tmp3_ = {0};
		ValaSourceLocation code_begin;
		char* id;
		ValaComment* _tmp4_;
		ValaSourceReference* _tmp5_;
		ValaErrorCode* _tmp6_;
		ValaErrorCode* ec;
		if (vala_genie_parser_current (self) == VALA_GENIE_TOKEN_TYPE_DEDENT) {
			break;
		}
		code_attrs = vala_genie_parser_parse_attributes (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (ed);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (ed);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		code_begin = (vala_genie_parser_get_location (self, &_tmp3_), _tmp3_);
		id = vala_genie_parser_parse_identifier (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (code_attrs);
				_vala_code_node_unref0 (ed);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_collection_object_unref0 (code_attrs);
				_vala_code_node_unref0 (ed);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		self->priv->comment = (_tmp4_ = vala_genie_scanner_pop_comment (self->priv->scanner), _vala_comment_unref0 (self->priv->comment), _tmp4_);
		ec = (_tmp6_ = vala_error_code_new (id, _tmp5_ = vala_genie_parser_get_src (self, &code_begin), self->priv->comment), _vala_source_reference_unref0 (_tmp5_), _tmp6_);
		vala_genie_parser_set_attributes (self, (ValaCodeNode*) ec, code_attrs);
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN)) {
			ValaExpression* _tmp7_;
			ValaExpression* _tmp8_;
			_tmp7_ = vala_genie_parser_parse_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (ec);
					_g_free0 (id);
					_vala_collection_object_unref0 (code_attrs);
					_vala_code_node_unref0 (ed);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_code_node_unref0 (ec);
					_g_free0 (id);
					_vala_collection_object_unref0 (code_attrs);
					_vala_code_node_unref0 (ed);
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			vala_error_code_set_value (ec, _tmp8_ = _tmp7_);
			_vala_code_node_unref0 (_tmp8_);
		}
		vala_error_domain_add_code (ed, ec);
		vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_EOL);
		_vala_code_node_unref0 (ec);
		_g_free0 (id);
		_vala_collection_object_unref0 (code_attrs);
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DEDENT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_result_ = _vala_code_node_ref0 ((ValaSymbol*) ed);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp9_;
		ValaNamespace* ns;
		ValaSymbol* _tmp10_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp9_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp9_);
		ns = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) ed));
		if (VALA_IS_NAMESPACE (_result_)) {
			vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		} else {
			vala_namespace_add_error_domain (ns, VALA_ERROR_DOMAIN (_result_));
			vala_source_file_add_node (vala_genie_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) _result_);
		}
		_result_ = (_tmp10_ = _vala_code_node_ref0 ((ValaSymbol*) ns), _vala_code_node_unref0 (_result_), _tmp10_);
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (ed);
	_vala_code_node_unref0 (sym);
	return result;
}


static ValaGenieParserModifierFlags vala_genie_parser_parse_type_declaration_modifiers (ValaGenieParser* self) {
	ValaGenieParserModifierFlags result = 0;
	ValaGenieParserModifierFlags flags;
	g_return_val_if_fail (self != NULL, 0);
	flags = 0;
	while (TRUE) {
		switch (vala_genie_parser_current (self)) {
			case VALA_GENIE_TOKEN_TYPE_ABSTRACT:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_EXTERN:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_STATIC:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_PRIVATE:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE;
				break;
			}
			default:
			{
				result = flags;
				return result;
			}
		}
	}
}


static ValaGenieParserModifierFlags vala_genie_parser_parse_member_declaration_modifiers (ValaGenieParser* self) {
	ValaGenieParserModifierFlags result = 0;
	ValaGenieParserModifierFlags flags;
	g_return_val_if_fail (self != NULL, 0);
	flags = 0;
	while (TRUE) {
		switch (vala_genie_parser_current (self)) {
			case VALA_GENIE_TOKEN_TYPE_ABSTRACT:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_ABSTRACT;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_ASYNC:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_ASYNC;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_CLASS:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_CLASS;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_EXTERN:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_INLINE:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_INLINE;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_NEW:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_OVERRIDE:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_OVERRIDE;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_STATIC:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_VIRTUAL:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_VIRTUAL;
				break;
			}
			case VALA_GENIE_TOKEN_TYPE_PRIVATE:
			{
				vala_genie_parser_next (self);
				flags = flags | VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE;
				break;
			}
			default:
			{
				result = flags;
				return result;
			}
		}
	}
}


static ValaFormalParameter* vala_genie_parser_parse_parameter (ValaGenieParser* self, GError** error) {
	ValaFormalParameter* result = NULL;
	ValaList* attrs;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	gboolean params_array;
	ValaParameterDirection direction;
	char* id;
	ValaDataType* type;
	ValaSourceReference* _tmp7_;
	ValaFormalParameter* _tmp8_;
	ValaFormalParameter* param;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	attrs = vala_genie_parser_parse_attributes (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ELLIPSIS)) {
		ValaSourceReference* _tmp1_;
		ValaFormalParameter* _tmp2_;
		result = (_tmp2_ = vala_formal_parameter_new_with_ellipsis (_tmp1_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
		_vala_collection_object_unref0 (attrs);
		return result;
	}
	params_array = vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_PARAMS);
	direction = VALA_PARAMETER_DIRECTION_IN;
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OUT)) {
		direction = VALA_PARAMETER_DIRECTION_OUT;
	} else {
		if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_REF)) {
			direction = VALA_PARAMETER_DIRECTION_REF;
		}
	}
	id = vala_genie_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (attrs);
			return NULL;
		} else {
			_vala_collection_object_unref0 (attrs);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_COLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_collection_object_unref0 (attrs);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_collection_object_unref0 (attrs);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = NULL;
	if (direction == VALA_PARAMETER_DIRECTION_IN) {
		ValaDataType* _tmp3_;
		ValaDataType* _tmp4_;
		_tmp3_ = vala_genie_parser_parse_type (self, FALSE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				_vala_collection_object_unref0 (attrs);
				return NULL;
			} else {
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				_vala_collection_object_unref0 (attrs);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		type = (_tmp4_ = _tmp3_, _vala_code_node_unref0 (type), _tmp4_);
	} else {
		ValaDataType* _tmp5_;
		ValaDataType* _tmp6_;
		_tmp5_ = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				_vala_collection_object_unref0 (attrs);
				return NULL;
			} else {
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				_vala_collection_object_unref0 (attrs);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		type = (_tmp6_ = _tmp5_, _vala_code_node_unref0 (type), _tmp6_);
	}
	param = (_tmp8_ = vala_formal_parameter_new (id, type, _tmp7_ = vala_genie_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp7_), _tmp8_);
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) param, attrs);
	vala_formal_parameter_set_direction (param, direction);
	vala_formal_parameter_set_params_array (param, params_array);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_ASSIGN)) {
		ValaExpression* _tmp9_;
		ValaExpression* _tmp10_;
		_tmp9_ = vala_genie_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (param);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				_vala_collection_object_unref0 (attrs);
				return NULL;
			} else {
				_vala_code_node_unref0 (param);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				_vala_collection_object_unref0 (attrs);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_variable_set_initializer ((ValaVariable*) param, _tmp10_ = _tmp9_);
		_vala_code_node_unref0 (_tmp10_);
	}
	result = param;
	_vala_code_node_unref0 (type);
	_g_free0 (id);
	_vala_collection_object_unref0 (attrs);
	return result;
}


static ValaCreationMethod* vala_genie_parser_parse_creation_method_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaCreationMethod* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaCreationMethod* method;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	method = NULL;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CONSTRUCT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (method);
			return NULL;
		} else {
			_vala_code_node_unref0 (method);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_genie_parser_parse_member_declaration_modifiers (self);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS)) {
		ValaSourceReference* _tmp1_;
		ValaCreationMethod* _tmp2_;
		method = (_tmp2_ = vala_creation_method_new (self->priv->class_name, NULL, _tmp1_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_code_node_unref0 (method), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
	} else {
		ValaUnresolvedSymbol* sym;
		sym = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		if (vala_unresolved_symbol_get_inner (sym) == NULL) {
			if (_vala_strcmp0 (vala_symbol_get_name ((ValaSymbol*) sym), self->priv->class_name) != 0) {
				ValaSourceReference* _tmp3_;
				ValaCreationMethod* _tmp4_;
				method = (_tmp4_ = vala_creation_method_new (self->priv->class_name, vala_symbol_get_name ((ValaSymbol*) sym), _tmp3_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_code_node_unref0 (method), _tmp4_);
				_vala_source_reference_unref0 (_tmp3_);
			} else {
				ValaSourceReference* _tmp5_;
				ValaCreationMethod* _tmp6_;
				method = (_tmp6_ = vala_creation_method_new (vala_symbol_get_name ((ValaSymbol*) sym), NULL, _tmp5_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_code_node_unref0 (method), _tmp6_);
				_vala_source_reference_unref0 (_tmp5_);
			}
		} else {
			ValaSourceReference* _tmp7_;
			ValaCreationMethod* _tmp8_;
			method = (_tmp8_ = vala_creation_method_new (vala_symbol_get_name ((ValaSymbol*) vala_unresolved_symbol_get_inner (sym)), vala_symbol_get_name ((ValaSymbol*) sym), _tmp7_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_code_node_unref0 (method), _tmp8_);
			_vala_source_reference_unref0 (_tmp7_);
		}
		vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (method);
				return NULL;
			} else {
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (method);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_vala_code_node_unref0 (sym);
	}
	if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp9_;
			_tmp9_ = TRUE;
			while (TRUE) {
				ValaFormalParameter* param;
				if (!_tmp9_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp9_ = FALSE;
				param = vala_genie_parser_parse_parameter (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_method_add_parameter ((ValaMethod*) method, param);
				_vala_code_node_unref0 (param);
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (method);
			return NULL;
		} else {
			_vala_code_node_unref0 (method);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_RAISES)) {
		{
			gboolean _tmp10_;
			_tmp10_ = TRUE;
			while (TRUE) {
				ValaDataType* _tmp11_;
				ValaDataType* _tmp12_;
				if (!_tmp10_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp10_ = FALSE;
				_tmp11_ = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_code_node_add_error_type ((ValaCodeNode*) method, _tmp12_ = _tmp11_);
				_vala_code_node_unref0 (_tmp12_);
			}
		}
	}
	vala_symbol_set_access ((ValaSymbol*) method, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) method, attrs);
	vala_method_set_binding ((ValaMethod*) method, MEMBER_BINDING_STATIC);
	if (vala_genie_parser_accept_block (self)) {
		ValaBlock* _tmp13_;
		ValaBlock* _tmp14_;
		_tmp13_ = vala_genie_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_method_set_body ((ValaMethod*) method, _tmp14_ = _tmp13_);
		_vala_code_node_unref0 (_tmp14_);
	} else {
		if (vala_source_file_get_external_package (vala_genie_scanner_get_source_file (self->priv->scanner))) {
			vala_symbol_set_external ((ValaSymbol*) method, TRUE);
		}
	}
	result = method;
	return result;
}


static ValaSymbol* vala_genie_parser_parse_delegate_declaration (ValaGenieParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaDataType* type;
	ValaGenieParserModifierFlags flags;
	ValaUnresolvedSymbol* sym;
	ValaList* type_param_list;
	ValaArrayList* params;
	ValaSourceReference* _tmp7_;
	ValaDelegate* _tmp8_;
	ValaDelegate* d;
	gboolean _tmp12_ = FALSE;
	ValaSymbol* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	type = NULL;
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_DELEGATE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	flags = vala_genie_parser_parse_member_declaration_modifiers (self);
	sym = vala_genie_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_param_list = vala_genie_parser_parse_type_parameter_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) == VALA_GENIE_PARSER_MODIFIER_FLAGS_NEW) {
		char* _tmp1_;
		GError* _tmp2_;
		_inner_error_ = (_tmp2_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp1_ = vala_genie_parser_get_error (self, "`new' modifier not allowed on delegates")), _g_free0 (_tmp1_), _tmp2_);
		{
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_collection_object_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	params = vala_array_list_new (VALA_TYPE_FORMAL_PARAMETER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (params);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_collection_object_unref0 (params);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_current (self) != VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				ValaFormalParameter* param;
				if (!_tmp3_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp3_ = FALSE;
				param = vala_genie_parser_parse_parameter (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (params);
						_vala_collection_object_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_collection_object_unref0 (params);
						_vala_collection_object_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) params, param);
				_vala_code_node_unref0 (param);
			}
		}
	}
	vala_genie_parser_expect (self, VALA_GENIE_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (params);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_collection_object_unref0 (params);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COLON)) {
		ValaDataType* _tmp4_;
		ValaDataType* _tmp5_;
		_tmp4_ = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (params);
				_vala_collection_object_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_collection_object_unref0 (params);
				_vala_collection_object_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		type = (_tmp5_ = _tmp4_, _vala_code_node_unref0 (type), _tmp5_);
	} else {
		ValaDataType* _tmp6_;
		type = (_tmp6_ = (ValaDataType*) vala_void_type_new (NULL), _vala_code_node_unref0 (type), _tmp6_);
	}
	d = (_tmp8_ = vala_delegate_new (vala_symbol_get_name ((ValaSymbol*) sym), type, _tmp7_ = vala_genie_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp7_), _tmp8_);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_RAISES)) {
		{
			gboolean _tmp9_;
			_tmp9_ = TRUE;
			while (TRUE) {
				ValaDataType* _tmp10_;
				ValaDataType* _tmp11_;
				if (!_tmp9_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp9_ = FALSE;
				_tmp10_ = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (d);
						_vala_collection_object_unref0 (params);
						_vala_collection_object_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (d);
						_vala_collection_object_unref0 (params);
						_vala_collection_object_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_code_node_add_error_type ((ValaCodeNode*) d, _tmp11_ = _tmp10_);
				_vala_code_node_unref0 (_tmp11_);
			}
		}
	}
	vala_genie_parser_expect_terminator (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (d);
			_vala_collection_object_unref0 (params);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (d);
			_vala_collection_object_unref0 (params);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) == VALA_GENIE_PARSER_MODIFIER_FLAGS_PRIVATE) {
		vala_symbol_set_access ((ValaSymbol*) d, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	} else {
		vala_symbol_set_access ((ValaSymbol*) d, vala_genie_parser_get_access (self, vala_symbol_get_name ((ValaSymbol*) sym)));
	}
	if (!((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC) == VALA_GENIE_PARSER_MODIFIER_FLAGS_STATIC)) {
		vala_delegate_set_has_target (d, TRUE);
	}
	if ((flags & VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_GENIE_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp12_ = TRUE;
	} else {
		_tmp12_ = vala_source_file_get_external_package (vala_genie_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp12_) {
		vala_symbol_set_external ((ValaSymbol*) d, TRUE);
	}
	vala_genie_parser_set_attributes (self, (ValaCodeNode*) d, attrs);
	{
		ValaIterator* _type_param_it;
		_type_param_it = vala_iterable_iterator ((ValaIterable*) type_param_list);
		while (TRUE) {
			ValaTypeParameter* type_param;
			if (!vala_iterator_next (_type_param_it)) {
				break;
			}
			type_param = (ValaTypeParameter*) vala_iterator_get (_type_param_it);
			vala_delegate_add_type_parameter (d, type_param);
			_vala_code_node_unref0 (type_param);
		}
		_vala_collection_object_unref0 (_type_param_it);
	}
	{
		ValaIterator* _formal_param_it;
		_formal_param_it = vala_iterable_iterator ((ValaIterable*) params);
		while (TRUE) {
			ValaFormalParameter* formal_param;
			if (!vala_iterator_next (_formal_param_it)) {
				break;
			}
			formal_param = (ValaFormalParameter*) vala_iterator_get (_formal_param_it);
			vala_delegate_add_parameter (d, formal_param);
			_vala_code_node_unref0 (formal_param);
		}
		_vala_collection_object_unref0 (_formal_param_it);
	}
	_result_ = _vala_code_node_ref0 ((ValaSymbol*) d);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp13_;
		ValaNamespace* ns;
		ValaSymbol* _tmp14_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp13_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp13_);
		ns = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) d));
		if (VALA_IS_NAMESPACE (_result_)) {
			vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		} else {
			vala_namespace_add_delegate (ns, VALA_DELEGATE (_result_));
			vala_source_file_add_node (vala_genie_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) _result_);
		}
		_result_ = (_tmp14_ = _vala_code_node_ref0 ((ValaSymbol*) ns), _vala_code_node_unref0 (_result_), _tmp14_);
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (d);
	_vala_collection_object_unref0 (params);
	_vala_collection_object_unref0 (type_param_list);
	_vala_code_node_unref0 (sym);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaList* vala_genie_parser_parse_type_parameter_list (ValaGenieParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	list = vala_array_list_new (VALA_TYPE_TYPEPARAMETER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OF)) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				ValaSourceLocation _tmp1_ = {0};
				ValaSourceLocation begin;
				char* id;
				ValaSourceReference* _tmp2_;
				ValaTypeParameter* _tmp3_;
				if (!_tmp0_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				begin = (vala_genie_parser_get_location (self, &_tmp1_), _tmp1_);
				id = vala_genie_parser_parse_identifier (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (list);
						return NULL;
					} else {
						_vala_collection_object_unref0 (list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) list, _tmp3_ = vala_typeparameter_new (id, _tmp2_ = vala_genie_parser_get_src (self, &begin)));
				_vala_code_node_unref0 (_tmp3_);
				_vala_source_reference_unref0 (_tmp2_);
				_g_free0 (id);
			}
		}
	}
	result = (ValaList*) list;
	return result;
}


static void vala_genie_parser_skip_type_argument_list (ValaGenieParser* self, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OF)) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				vala_genie_parser_skip_type (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
			}
		}
	}
}


static ValaList* vala_genie_parser_parse_type_argument_list (ValaGenieParser* self, gboolean maybe_expression, GError** error) {
	ValaList* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	if (vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_OF)) {
		ValaArrayList* list;
		list = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp1_ = FALSE;
				switch (vala_genie_parser_current (self)) {
					case VALA_GENIE_TOKEN_TYPE_VOID:
					case VALA_GENIE_TOKEN_TYPE_DYNAMIC:
					case VALA_GENIE_TOKEN_TYPE_UNOWNED:
					case VALA_GENIE_TOKEN_TYPE_WEAK:
					case VALA_GENIE_TOKEN_TYPE_IDENTIFIER:
					{
						ValaDataType* type;
						type = vala_genie_parser_parse_type (self, TRUE, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_collection_object_unref0 (list);
								return NULL;
							} else {
								_vala_collection_object_unref0 (list);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						vala_collection_add ((ValaCollection*) list, type);
						_vala_code_node_unref0 (type);
						break;
					}
					default:
					{
						vala_genie_parser_rollback (self, &begin);
						result = NULL;
						_vala_collection_object_unref0 (list);
						return result;
					}
				}
			}
		}
		result = (ValaList*) list;
		return result;
	}
	result = NULL;
	return result;
}


static ValaMemberAccess* vala_genie_parser_parse_member_name (ValaGenieParser* self, ValaExpression* base_expr, GError** error) {
	ValaMemberAccess* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaMemberAccess* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_genie_parser_get_location (self, &_tmp0_), _tmp0_);
	expr = NULL;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			char* id;
			ValaList* type_arg_list;
			ValaExpression* _tmp2_;
			ValaSourceReference* _tmp3_;
			ValaMemberAccess* _tmp4_;
			if (!_tmp1_) {
				if (!vala_genie_parser_accept (self, VALA_GENIE_TOKEN_TYPE_DOT)) {
					break;
				}
			}
			_tmp1_ = FALSE;
			id = vala_genie_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			type_arg_list = vala_genie_parser_parse_type_argument_list (self, FALSE, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp2_ = NULL;
			if (expr != NULL) {
				_tmp2_ = (ValaExpression*) expr;
			} else {
				_tmp2_ = base_expr;
			}
			expr = (_tmp4_ = vala_member_access_new (_tmp2_, id, _tmp3_ = vala_genie_parser_get_src (self, &begin)), _vala_code_node_unref0 (expr), _tmp4_);
			_vala_source_reference_unref0 (_tmp3_);
			if (type_arg_list != NULL) {
				{
					ValaIterator* _type_arg_it;
					_type_arg_it = vala_iterable_iterator ((ValaIterable*) type_arg_list);
					while (TRUE) {
						ValaDataType* type_arg;
						if (!vala_iterator_next (_type_arg_it)) {
							break;
						}
						type_arg = (ValaDataType*) vala_iterator_get (_type_arg_it);
						vala_member_access_add_type_argument (expr, type_arg);
						_vala_code_node_unref0 (type_arg);
					}
					_vala_collection_object_unref0 (_type_arg_it);
				}
			}
			_vala_collection_object_unref0 (type_arg_list);
			_g_free0 (id);
		}
	}
	result = expr;
	return result;
}


static ValaGenieParserTokenInfo* vala_genie_parser_token_info_dup (const ValaGenieParserTokenInfo* self) {
	ValaGenieParserTokenInfo* dup;
	dup = g_new0 (ValaGenieParserTokenInfo, 1);
	memcpy (dup, self, sizeof (ValaGenieParserTokenInfo));
	return dup;
}


static void vala_genie_parser_token_info_free (ValaGenieParserTokenInfo* self) {
	g_free (self);
}


static GType vala_genie_parser_token_info_get_type (void) {
	static volatile gsize vala_genie_parser_token_info_type_id__volatile = 0;
	if (g_once_init_enter (&vala_genie_parser_token_info_type_id__volatile)) {
		GType vala_genie_parser_token_info_type_id;
		vala_genie_parser_token_info_type_id = g_boxed_type_register_static ("ValaGenieParserTokenInfo", (GBoxedCopyFunc) vala_genie_parser_token_info_dup, (GBoxedFreeFunc) vala_genie_parser_token_info_free);
		g_once_init_leave (&vala_genie_parser_token_info_type_id__volatile, vala_genie_parser_token_info_type_id);
	}
	return vala_genie_parser_token_info_type_id__volatile;
}


static void vala_genie_parser_class_init (ValaGenieParserClass * klass) {
	vala_genie_parser_parent_class = g_type_class_peek_parent (klass);
	VALA_CODE_VISITOR_CLASS (klass)->finalize = vala_genie_parser_finalize;
	g_type_class_add_private (klass, sizeof (ValaGenieParserPrivate));
	VALA_CODE_VISITOR_CLASS (klass)->visit_source_file = vala_genie_parser_real_visit_source_file;
}


static void vala_genie_parser_instance_init (ValaGenieParser * self) {
	self->priv = VALA_GENIE_PARSER_GET_PRIVATE (self);
}


static void vala_genie_parser_finalize (ValaCodeVisitor* obj) {
	ValaGenieParser * self;
	self = VALA_GENIE_PARSER (obj);
	_vala_genie_scanner_unref0 (self->priv->scanner);
	_vala_code_context_unref0 (self->priv->context);
	self->priv->tokens = (g_free (self->priv->tokens), NULL);
	_vala_comment_unref0 (self->priv->comment);
	_g_free0 (self->priv->class_name);
	VALA_CODE_VISITOR_CLASS (vala_genie_parser_parent_class)->finalize (obj);
}


/**
 * Code visitor parsing all Genie source files.
 */
GType vala_genie_parser_get_type (void) {
	static volatile gsize vala_genie_parser_type_id__volatile = 0;
	if (g_once_init_enter (&vala_genie_parser_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValaGenieParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_genie_parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaGenieParser), 0, (GInstanceInitFunc) vala_genie_parser_instance_init, NULL };
		GType vala_genie_parser_type_id;
		vala_genie_parser_type_id = g_type_register_static (VALA_TYPE_CODE_VISITOR, "ValaGenieParser", &g_define_type_info, 0);
		g_once_init_leave (&vala_genie_parser_type_id__volatile, vala_genie_parser_type_id);
	}
	return vala_genie_parser_type_id__volatile;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




