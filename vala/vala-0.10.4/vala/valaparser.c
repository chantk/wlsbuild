/* valaparser.c generated by valac, the Vala compiler
 * generated from valaparser.vala, do not modify */

/* valaparser.vala
 *
 * Copyright (C) 2006-2010  Jürg Billeter
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.

 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.

 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA
 *
 * Author:
 * 	Jürg Billeter <j@bitron.ch>
 */

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <valagee.h>


#define VALA_TYPE_CODE_VISITOR (vala_code_visitor_get_type ())
#define VALA_CODE_VISITOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_VISITOR, ValaCodeVisitor))
#define VALA_CODE_VISITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_VISITOR, ValaCodeVisitorClass))
#define VALA_IS_CODE_VISITOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_VISITOR))
#define VALA_IS_CODE_VISITOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_VISITOR))
#define VALA_CODE_VISITOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_VISITOR, ValaCodeVisitorClass))

typedef struct _ValaCodeVisitor ValaCodeVisitor;
typedef struct _ValaCodeVisitorClass ValaCodeVisitorClass;
typedef struct _ValaCodeVisitorPrivate ValaCodeVisitorPrivate;

#define VALA_TYPE_SOURCE_FILE (vala_source_file_get_type ())
#define VALA_SOURCE_FILE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SOURCE_FILE, ValaSourceFile))
#define VALA_SOURCE_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SOURCE_FILE, ValaSourceFileClass))
#define VALA_IS_SOURCE_FILE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SOURCE_FILE))
#define VALA_IS_SOURCE_FILE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SOURCE_FILE))
#define VALA_SOURCE_FILE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SOURCE_FILE, ValaSourceFileClass))

typedef struct _ValaSourceFile ValaSourceFile;
typedef struct _ValaSourceFileClass ValaSourceFileClass;

#define VALA_TYPE_CODE_NODE (vala_code_node_get_type ())
#define VALA_CODE_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_NODE, ValaCodeNode))
#define VALA_CODE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_NODE, ValaCodeNodeClass))
#define VALA_IS_CODE_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_NODE))
#define VALA_IS_CODE_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_NODE))
#define VALA_CODE_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_NODE, ValaCodeNodeClass))

typedef struct _ValaCodeNode ValaCodeNode;
typedef struct _ValaCodeNodeClass ValaCodeNodeClass;

#define VALA_TYPE_SYMBOL (vala_symbol_get_type ())
#define VALA_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SYMBOL, ValaSymbol))
#define VALA_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SYMBOL, ValaSymbolClass))
#define VALA_IS_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SYMBOL))
#define VALA_IS_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SYMBOL))
#define VALA_SYMBOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SYMBOL, ValaSymbolClass))

typedef struct _ValaSymbol ValaSymbol;
typedef struct _ValaSymbolClass ValaSymbolClass;

#define VALA_TYPE_NAMESPACE (vala_namespace_get_type ())
#define VALA_NAMESPACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_NAMESPACE, ValaNamespace))
#define VALA_NAMESPACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_NAMESPACE, ValaNamespaceClass))
#define VALA_IS_NAMESPACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_NAMESPACE))
#define VALA_IS_NAMESPACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_NAMESPACE))
#define VALA_NAMESPACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_NAMESPACE, ValaNamespaceClass))

typedef struct _ValaNamespace ValaNamespace;
typedef struct _ValaNamespaceClass ValaNamespaceClass;

#define VALA_TYPE_TYPESYMBOL (vala_typesymbol_get_type ())
#define VALA_TYPESYMBOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPESYMBOL, ValaTypeSymbol))
#define VALA_TYPESYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPESYMBOL, ValaTypeSymbolClass))
#define VALA_IS_TYPESYMBOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPESYMBOL))
#define VALA_IS_TYPESYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPESYMBOL))
#define VALA_TYPESYMBOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPESYMBOL, ValaTypeSymbolClass))

typedef struct _ValaTypeSymbol ValaTypeSymbol;
typedef struct _ValaTypeSymbolClass ValaTypeSymbolClass;

#define VALA_TYPE_OBJECT_TYPE_SYMBOL (vala_object_type_symbol_get_type ())
#define VALA_OBJECT_TYPE_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_OBJECT_TYPE_SYMBOL, ValaObjectTypeSymbol))
#define VALA_OBJECT_TYPE_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_OBJECT_TYPE_SYMBOL, ValaObjectTypeSymbolClass))
#define VALA_IS_OBJECT_TYPE_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_OBJECT_TYPE_SYMBOL))
#define VALA_IS_OBJECT_TYPE_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_OBJECT_TYPE_SYMBOL))
#define VALA_OBJECT_TYPE_SYMBOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_OBJECT_TYPE_SYMBOL, ValaObjectTypeSymbolClass))

typedef struct _ValaObjectTypeSymbol ValaObjectTypeSymbol;
typedef struct _ValaObjectTypeSymbolClass ValaObjectTypeSymbolClass;

#define VALA_TYPE_CLASS (vala_class_get_type ())
#define VALA_CLASS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CLASS, ValaClass))
#define VALA_CLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CLASS, ValaClassClass))
#define VALA_IS_CLASS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CLASS))
#define VALA_IS_CLASS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CLASS))
#define VALA_CLASS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CLASS, ValaClassClass))

typedef struct _ValaClass ValaClass;
typedef struct _ValaClassClass ValaClassClass;

#define VALA_TYPE_STRUCT (vala_struct_get_type ())
#define VALA_STRUCT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_STRUCT, ValaStruct))
#define VALA_STRUCT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_STRUCT, ValaStructClass))
#define VALA_IS_STRUCT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_STRUCT))
#define VALA_IS_STRUCT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_STRUCT))
#define VALA_STRUCT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_STRUCT, ValaStructClass))

typedef struct _ValaStruct ValaStruct;
typedef struct _ValaStructClass ValaStructClass;

#define VALA_TYPE_INTERFACE (vala_interface_get_type ())
#define VALA_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_INTERFACE, ValaInterface))
#define VALA_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_INTERFACE, ValaInterfaceClass))
#define VALA_IS_INTERFACE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_INTERFACE))
#define VALA_IS_INTERFACE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_INTERFACE))
#define VALA_INTERFACE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_INTERFACE, ValaInterfaceClass))

typedef struct _ValaInterface ValaInterface;
typedef struct _ValaInterfaceClass ValaInterfaceClass;

#define VALA_TYPE_ENUM (vala_enum_get_type ())
#define VALA_ENUM(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ENUM, ValaEnum))
#define VALA_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ENUM, ValaEnumClass))
#define VALA_IS_ENUM(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ENUM))
#define VALA_IS_ENUM_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ENUM))
#define VALA_ENUM_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ENUM, ValaEnumClass))

typedef struct _ValaEnum ValaEnum;
typedef struct _ValaEnumClass ValaEnumClass;

#define VALA_TYPE_CONSTANT (vala_constant_get_type ())
#define VALA_CONSTANT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CONSTANT, ValaConstant))
#define VALA_CONSTANT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CONSTANT, ValaConstantClass))
#define VALA_IS_CONSTANT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CONSTANT))
#define VALA_IS_CONSTANT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CONSTANT))
#define VALA_CONSTANT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CONSTANT, ValaConstantClass))

typedef struct _ValaConstant ValaConstant;
typedef struct _ValaConstantClass ValaConstantClass;

#define VALA_TYPE_ENUM_VALUE (vala_enum_value_get_type ())
#define VALA_ENUM_VALUE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ENUM_VALUE, ValaEnumValue))
#define VALA_ENUM_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ENUM_VALUE, ValaEnumValueClass))
#define VALA_IS_ENUM_VALUE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ENUM_VALUE))
#define VALA_IS_ENUM_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ENUM_VALUE))
#define VALA_ENUM_VALUE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ENUM_VALUE, ValaEnumValueClass))

typedef struct _ValaEnumValue ValaEnumValue;
typedef struct _ValaEnumValueClass ValaEnumValueClass;

#define VALA_TYPE_ERROR_DOMAIN (vala_error_domain_get_type ())
#define VALA_ERROR_DOMAIN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ERROR_DOMAIN, ValaErrorDomain))
#define VALA_ERROR_DOMAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ERROR_DOMAIN, ValaErrorDomainClass))
#define VALA_IS_ERROR_DOMAIN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ERROR_DOMAIN))
#define VALA_IS_ERROR_DOMAIN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ERROR_DOMAIN))
#define VALA_ERROR_DOMAIN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ERROR_DOMAIN, ValaErrorDomainClass))

typedef struct _ValaErrorDomain ValaErrorDomain;
typedef struct _ValaErrorDomainClass ValaErrorDomainClass;

#define VALA_TYPE_ERROR_CODE (vala_error_code_get_type ())
#define VALA_ERROR_CODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ERROR_CODE, ValaErrorCode))
#define VALA_ERROR_CODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ERROR_CODE, ValaErrorCodeClass))
#define VALA_IS_ERROR_CODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ERROR_CODE))
#define VALA_IS_ERROR_CODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ERROR_CODE))
#define VALA_ERROR_CODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ERROR_CODE, ValaErrorCodeClass))

typedef struct _ValaErrorCode ValaErrorCode;
typedef struct _ValaErrorCodeClass ValaErrorCodeClass;

#define VALA_TYPE_DELEGATE (vala_delegate_get_type ())
#define VALA_DELEGATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DELEGATE, ValaDelegate))
#define VALA_DELEGATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DELEGATE, ValaDelegateClass))
#define VALA_IS_DELEGATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DELEGATE))
#define VALA_IS_DELEGATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DELEGATE))
#define VALA_DELEGATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DELEGATE, ValaDelegateClass))

typedef struct _ValaDelegate ValaDelegate;
typedef struct _ValaDelegateClass ValaDelegateClass;

#define VALA_TYPE_VARIABLE (vala_variable_get_type ())
#define VALA_VARIABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_VARIABLE, ValaVariable))
#define VALA_VARIABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_VARIABLE, ValaVariableClass))
#define VALA_IS_VARIABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_VARIABLE))
#define VALA_IS_VARIABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_VARIABLE))
#define VALA_VARIABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_VARIABLE, ValaVariableClass))

typedef struct _ValaVariable ValaVariable;
typedef struct _ValaVariableClass ValaVariableClass;

#define VALA_TYPE_FIELD (vala_field_get_type ())
#define VALA_FIELD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_FIELD, ValaField))
#define VALA_FIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_FIELD, ValaFieldClass))
#define VALA_IS_FIELD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_FIELD))
#define VALA_IS_FIELD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_FIELD))
#define VALA_FIELD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_FIELD, ValaFieldClass))

typedef struct _ValaField ValaField;
typedef struct _ValaFieldClass ValaFieldClass;

#define VALA_TYPE_METHOD (vala_method_get_type ())
#define VALA_METHOD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_METHOD, ValaMethod))
#define VALA_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_METHOD, ValaMethodClass))
#define VALA_IS_METHOD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_METHOD))
#define VALA_IS_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_METHOD))
#define VALA_METHOD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_METHOD, ValaMethodClass))

typedef struct _ValaMethod ValaMethod;
typedef struct _ValaMethodClass ValaMethodClass;

#define VALA_TYPE_CREATION_METHOD (vala_creation_method_get_type ())
#define VALA_CREATION_METHOD(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CREATION_METHOD, ValaCreationMethod))
#define VALA_CREATION_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CREATION_METHOD, ValaCreationMethodClass))
#define VALA_IS_CREATION_METHOD(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CREATION_METHOD))
#define VALA_IS_CREATION_METHOD_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CREATION_METHOD))
#define VALA_CREATION_METHOD_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CREATION_METHOD, ValaCreationMethodClass))

typedef struct _ValaCreationMethod ValaCreationMethod;
typedef struct _ValaCreationMethodClass ValaCreationMethodClass;

#define VALA_TYPE_FORMAL_PARAMETER (vala_formal_parameter_get_type ())
#define VALA_FORMAL_PARAMETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_FORMAL_PARAMETER, ValaFormalParameter))
#define VALA_FORMAL_PARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_FORMAL_PARAMETER, ValaFormalParameterClass))
#define VALA_IS_FORMAL_PARAMETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_FORMAL_PARAMETER))
#define VALA_IS_FORMAL_PARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_FORMAL_PARAMETER))
#define VALA_FORMAL_PARAMETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_FORMAL_PARAMETER, ValaFormalParameterClass))

typedef struct _ValaFormalParameter ValaFormalParameter;
typedef struct _ValaFormalParameterClass ValaFormalParameterClass;

#define VALA_TYPE_PROPERTY (vala_property_get_type ())
#define VALA_PROPERTY(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_PROPERTY, ValaProperty))
#define VALA_PROPERTY_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_PROPERTY, ValaPropertyClass))
#define VALA_IS_PROPERTY(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_PROPERTY))
#define VALA_IS_PROPERTY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_PROPERTY))
#define VALA_PROPERTY_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_PROPERTY, ValaPropertyClass))

typedef struct _ValaProperty ValaProperty;
typedef struct _ValaPropertyClass ValaPropertyClass;

#define VALA_TYPE_PROPERTY_ACCESSOR (vala_property_accessor_get_type ())
#define VALA_PROPERTY_ACCESSOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_PROPERTY_ACCESSOR, ValaPropertyAccessor))
#define VALA_PROPERTY_ACCESSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_PROPERTY_ACCESSOR, ValaPropertyAccessorClass))
#define VALA_IS_PROPERTY_ACCESSOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_PROPERTY_ACCESSOR))
#define VALA_IS_PROPERTY_ACCESSOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_PROPERTY_ACCESSOR))
#define VALA_PROPERTY_ACCESSOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_PROPERTY_ACCESSOR, ValaPropertyAccessorClass))

typedef struct _ValaPropertyAccessor ValaPropertyAccessor;
typedef struct _ValaPropertyAccessorClass ValaPropertyAccessorClass;

#define VALA_TYPE_SIGNAL (vala_signal_get_type ())
#define VALA_SIGNAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SIGNAL, ValaSignal))
#define VALA_SIGNAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SIGNAL, ValaSignalClass))
#define VALA_IS_SIGNAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SIGNAL))
#define VALA_IS_SIGNAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SIGNAL))
#define VALA_SIGNAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SIGNAL, ValaSignalClass))

typedef struct _ValaSignal ValaSignal;
typedef struct _ValaSignalClass ValaSignalClass;

#define VALA_TYPE_CONSTRUCTOR (vala_constructor_get_type ())
#define VALA_CONSTRUCTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CONSTRUCTOR, ValaConstructor))
#define VALA_CONSTRUCTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CONSTRUCTOR, ValaConstructorClass))
#define VALA_IS_CONSTRUCTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CONSTRUCTOR))
#define VALA_IS_CONSTRUCTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CONSTRUCTOR))
#define VALA_CONSTRUCTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CONSTRUCTOR, ValaConstructorClass))

typedef struct _ValaConstructor ValaConstructor;
typedef struct _ValaConstructorClass ValaConstructorClass;

#define VALA_TYPE_DESTRUCTOR (vala_destructor_get_type ())
#define VALA_DESTRUCTOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DESTRUCTOR, ValaDestructor))
#define VALA_DESTRUCTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DESTRUCTOR, ValaDestructorClass))
#define VALA_IS_DESTRUCTOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DESTRUCTOR))
#define VALA_IS_DESTRUCTOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DESTRUCTOR))
#define VALA_DESTRUCTOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DESTRUCTOR, ValaDestructorClass))

typedef struct _ValaDestructor ValaDestructor;
typedef struct _ValaDestructorClass ValaDestructorClass;

#define VALA_TYPE_TYPEPARAMETER (vala_typeparameter_get_type ())
#define VALA_TYPEPARAMETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPEPARAMETER, ValaTypeParameter))
#define VALA_TYPEPARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPEPARAMETER, ValaTypeParameterClass))
#define VALA_IS_TYPEPARAMETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPEPARAMETER))
#define VALA_IS_TYPEPARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPEPARAMETER))
#define VALA_TYPEPARAMETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPEPARAMETER, ValaTypeParameterClass))

typedef struct _ValaTypeParameter ValaTypeParameter;
typedef struct _ValaTypeParameterClass ValaTypeParameterClass;

#define VALA_TYPE_USING_DIRECTIVE (vala_using_directive_get_type ())
#define VALA_USING_DIRECTIVE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_USING_DIRECTIVE, ValaUsingDirective))
#define VALA_USING_DIRECTIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_USING_DIRECTIVE, ValaUsingDirectiveClass))
#define VALA_IS_USING_DIRECTIVE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_USING_DIRECTIVE))
#define VALA_IS_USING_DIRECTIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_USING_DIRECTIVE))
#define VALA_USING_DIRECTIVE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_USING_DIRECTIVE, ValaUsingDirectiveClass))

typedef struct _ValaUsingDirective ValaUsingDirective;
typedef struct _ValaUsingDirectiveClass ValaUsingDirectiveClass;

#define VALA_TYPE_DATA_TYPE (vala_data_type_get_type ())
#define VALA_DATA_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DATA_TYPE, ValaDataType))
#define VALA_DATA_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DATA_TYPE, ValaDataTypeClass))
#define VALA_IS_DATA_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DATA_TYPE))
#define VALA_IS_DATA_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DATA_TYPE))
#define VALA_DATA_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DATA_TYPE, ValaDataTypeClass))

typedef struct _ValaDataType ValaDataType;
typedef struct _ValaDataTypeClass ValaDataTypeClass;

#define VALA_TYPE_BLOCK (vala_block_get_type ())
#define VALA_BLOCK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BLOCK, ValaBlock))
#define VALA_BLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BLOCK, ValaBlockClass))
#define VALA_IS_BLOCK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BLOCK))
#define VALA_IS_BLOCK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BLOCK))
#define VALA_BLOCK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BLOCK, ValaBlockClass))

typedef struct _ValaBlock ValaBlock;
typedef struct _ValaBlockClass ValaBlockClass;

#define VALA_TYPE_EMPTY_STATEMENT (vala_empty_statement_get_type ())
#define VALA_EMPTY_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_EMPTY_STATEMENT, ValaEmptyStatement))
#define VALA_EMPTY_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_EMPTY_STATEMENT, ValaEmptyStatementClass))
#define VALA_IS_EMPTY_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_EMPTY_STATEMENT))
#define VALA_IS_EMPTY_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_EMPTY_STATEMENT))
#define VALA_EMPTY_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_EMPTY_STATEMENT, ValaEmptyStatementClass))

typedef struct _ValaEmptyStatement ValaEmptyStatement;
typedef struct _ValaEmptyStatementClass ValaEmptyStatementClass;

#define VALA_TYPE_DECLARATION_STATEMENT (vala_declaration_statement_get_type ())
#define VALA_DECLARATION_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DECLARATION_STATEMENT, ValaDeclarationStatement))
#define VALA_DECLARATION_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DECLARATION_STATEMENT, ValaDeclarationStatementClass))
#define VALA_IS_DECLARATION_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DECLARATION_STATEMENT))
#define VALA_IS_DECLARATION_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DECLARATION_STATEMENT))
#define VALA_DECLARATION_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DECLARATION_STATEMENT, ValaDeclarationStatementClass))

typedef struct _ValaDeclarationStatement ValaDeclarationStatement;
typedef struct _ValaDeclarationStatementClass ValaDeclarationStatementClass;

#define VALA_TYPE_LOCAL_VARIABLE (vala_local_variable_get_type ())
#define VALA_LOCAL_VARIABLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LOCAL_VARIABLE, ValaLocalVariable))
#define VALA_LOCAL_VARIABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LOCAL_VARIABLE, ValaLocalVariableClass))
#define VALA_IS_LOCAL_VARIABLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LOCAL_VARIABLE))
#define VALA_IS_LOCAL_VARIABLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LOCAL_VARIABLE))
#define VALA_LOCAL_VARIABLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LOCAL_VARIABLE, ValaLocalVariableClass))

typedef struct _ValaLocalVariable ValaLocalVariable;
typedef struct _ValaLocalVariableClass ValaLocalVariableClass;

#define VALA_TYPE_EXPRESSION (vala_expression_get_type ())
#define VALA_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_EXPRESSION, ValaExpression))
#define VALA_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_EXPRESSION, ValaExpressionClass))
#define VALA_IS_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_EXPRESSION))
#define VALA_IS_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_EXPRESSION))
#define VALA_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_EXPRESSION, ValaExpressionClass))

typedef struct _ValaExpression ValaExpression;
typedef struct _ValaExpressionClass ValaExpressionClass;

#define VALA_TYPE_INITIALIZER_LIST (vala_initializer_list_get_type ())
#define VALA_INITIALIZER_LIST(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_INITIALIZER_LIST, ValaInitializerList))
#define VALA_INITIALIZER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_INITIALIZER_LIST, ValaInitializerListClass))
#define VALA_IS_INITIALIZER_LIST(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_INITIALIZER_LIST))
#define VALA_IS_INITIALIZER_LIST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_INITIALIZER_LIST))
#define VALA_INITIALIZER_LIST_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_INITIALIZER_LIST, ValaInitializerListClass))

typedef struct _ValaInitializerList ValaInitializerList;
typedef struct _ValaInitializerListClass ValaInitializerListClass;

#define VALA_TYPE_EXPRESSION_STATEMENT (vala_expression_statement_get_type ())
#define VALA_EXPRESSION_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_EXPRESSION_STATEMENT, ValaExpressionStatement))
#define VALA_EXPRESSION_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_EXPRESSION_STATEMENT, ValaExpressionStatementClass))
#define VALA_IS_EXPRESSION_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_EXPRESSION_STATEMENT))
#define VALA_IS_EXPRESSION_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_EXPRESSION_STATEMENT))
#define VALA_EXPRESSION_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_EXPRESSION_STATEMENT, ValaExpressionStatementClass))

typedef struct _ValaExpressionStatement ValaExpressionStatement;
typedef struct _ValaExpressionStatementClass ValaExpressionStatementClass;

#define VALA_TYPE_IF_STATEMENT (vala_if_statement_get_type ())
#define VALA_IF_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_IF_STATEMENT, ValaIfStatement))
#define VALA_IF_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_IF_STATEMENT, ValaIfStatementClass))
#define VALA_IS_IF_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_IF_STATEMENT))
#define VALA_IS_IF_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_IF_STATEMENT))
#define VALA_IF_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_IF_STATEMENT, ValaIfStatementClass))

typedef struct _ValaIfStatement ValaIfStatement;
typedef struct _ValaIfStatementClass ValaIfStatementClass;

#define VALA_TYPE_SWITCH_STATEMENT (vala_switch_statement_get_type ())
#define VALA_SWITCH_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SWITCH_STATEMENT, ValaSwitchStatement))
#define VALA_SWITCH_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SWITCH_STATEMENT, ValaSwitchStatementClass))
#define VALA_IS_SWITCH_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SWITCH_STATEMENT))
#define VALA_IS_SWITCH_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SWITCH_STATEMENT))
#define VALA_SWITCH_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SWITCH_STATEMENT, ValaSwitchStatementClass))

typedef struct _ValaSwitchStatement ValaSwitchStatement;
typedef struct _ValaSwitchStatementClass ValaSwitchStatementClass;

#define VALA_TYPE_SWITCH_SECTION (vala_switch_section_get_type ())
#define VALA_SWITCH_SECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SWITCH_SECTION, ValaSwitchSection))
#define VALA_SWITCH_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SWITCH_SECTION, ValaSwitchSectionClass))
#define VALA_IS_SWITCH_SECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SWITCH_SECTION))
#define VALA_IS_SWITCH_SECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SWITCH_SECTION))
#define VALA_SWITCH_SECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SWITCH_SECTION, ValaSwitchSectionClass))

typedef struct _ValaSwitchSection ValaSwitchSection;
typedef struct _ValaSwitchSectionClass ValaSwitchSectionClass;

#define VALA_TYPE_SWITCH_LABEL (vala_switch_label_get_type ())
#define VALA_SWITCH_LABEL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SWITCH_LABEL, ValaSwitchLabel))
#define VALA_SWITCH_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SWITCH_LABEL, ValaSwitchLabelClass))
#define VALA_IS_SWITCH_LABEL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SWITCH_LABEL))
#define VALA_IS_SWITCH_LABEL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SWITCH_LABEL))
#define VALA_SWITCH_LABEL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SWITCH_LABEL, ValaSwitchLabelClass))

typedef struct _ValaSwitchLabel ValaSwitchLabel;
typedef struct _ValaSwitchLabelClass ValaSwitchLabelClass;

#define VALA_TYPE_LOOP (vala_loop_get_type ())
#define VALA_LOOP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LOOP, ValaLoop))
#define VALA_LOOP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LOOP, ValaLoopClass))
#define VALA_IS_LOOP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LOOP))
#define VALA_IS_LOOP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LOOP))
#define VALA_LOOP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LOOP, ValaLoopClass))

typedef struct _ValaLoop ValaLoop;
typedef struct _ValaLoopClass ValaLoopClass;

#define VALA_TYPE_WHILE_STATEMENT (vala_while_statement_get_type ())
#define VALA_WHILE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_WHILE_STATEMENT, ValaWhileStatement))
#define VALA_WHILE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_WHILE_STATEMENT, ValaWhileStatementClass))
#define VALA_IS_WHILE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_WHILE_STATEMENT))
#define VALA_IS_WHILE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_WHILE_STATEMENT))
#define VALA_WHILE_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_WHILE_STATEMENT, ValaWhileStatementClass))

typedef struct _ValaWhileStatement ValaWhileStatement;
typedef struct _ValaWhileStatementClass ValaWhileStatementClass;

#define VALA_TYPE_DO_STATEMENT (vala_do_statement_get_type ())
#define VALA_DO_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DO_STATEMENT, ValaDoStatement))
#define VALA_DO_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DO_STATEMENT, ValaDoStatementClass))
#define VALA_IS_DO_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DO_STATEMENT))
#define VALA_IS_DO_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DO_STATEMENT))
#define VALA_DO_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DO_STATEMENT, ValaDoStatementClass))

typedef struct _ValaDoStatement ValaDoStatement;
typedef struct _ValaDoStatementClass ValaDoStatementClass;

#define VALA_TYPE_FOR_STATEMENT (vala_for_statement_get_type ())
#define VALA_FOR_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_FOR_STATEMENT, ValaForStatement))
#define VALA_FOR_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_FOR_STATEMENT, ValaForStatementClass))
#define VALA_IS_FOR_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_FOR_STATEMENT))
#define VALA_IS_FOR_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_FOR_STATEMENT))
#define VALA_FOR_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_FOR_STATEMENT, ValaForStatementClass))

typedef struct _ValaForStatement ValaForStatement;
typedef struct _ValaForStatementClass ValaForStatementClass;

#define VALA_TYPE_FOREACH_STATEMENT (vala_foreach_statement_get_type ())
#define VALA_FOREACH_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_FOREACH_STATEMENT, ValaForeachStatement))
#define VALA_FOREACH_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_FOREACH_STATEMENT, ValaForeachStatementClass))
#define VALA_IS_FOREACH_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_FOREACH_STATEMENT))
#define VALA_IS_FOREACH_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_FOREACH_STATEMENT))
#define VALA_FOREACH_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_FOREACH_STATEMENT, ValaForeachStatementClass))

typedef struct _ValaForeachStatement ValaForeachStatement;
typedef struct _ValaForeachStatementClass ValaForeachStatementClass;

#define VALA_TYPE_BREAK_STATEMENT (vala_break_statement_get_type ())
#define VALA_BREAK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BREAK_STATEMENT, ValaBreakStatement))
#define VALA_BREAK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BREAK_STATEMENT, ValaBreakStatementClass))
#define VALA_IS_BREAK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BREAK_STATEMENT))
#define VALA_IS_BREAK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BREAK_STATEMENT))
#define VALA_BREAK_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BREAK_STATEMENT, ValaBreakStatementClass))

typedef struct _ValaBreakStatement ValaBreakStatement;
typedef struct _ValaBreakStatementClass ValaBreakStatementClass;

#define VALA_TYPE_CONTINUE_STATEMENT (vala_continue_statement_get_type ())
#define VALA_CONTINUE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CONTINUE_STATEMENT, ValaContinueStatement))
#define VALA_CONTINUE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CONTINUE_STATEMENT, ValaContinueStatementClass))
#define VALA_IS_CONTINUE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CONTINUE_STATEMENT))
#define VALA_IS_CONTINUE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CONTINUE_STATEMENT))
#define VALA_CONTINUE_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CONTINUE_STATEMENT, ValaContinueStatementClass))

typedef struct _ValaContinueStatement ValaContinueStatement;
typedef struct _ValaContinueStatementClass ValaContinueStatementClass;

#define VALA_TYPE_RETURN_STATEMENT (vala_return_statement_get_type ())
#define VALA_RETURN_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_RETURN_STATEMENT, ValaReturnStatement))
#define VALA_RETURN_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_RETURN_STATEMENT, ValaReturnStatementClass))
#define VALA_IS_RETURN_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_RETURN_STATEMENT))
#define VALA_IS_RETURN_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_RETURN_STATEMENT))
#define VALA_RETURN_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_RETURN_STATEMENT, ValaReturnStatementClass))

typedef struct _ValaReturnStatement ValaReturnStatement;
typedef struct _ValaReturnStatementClass ValaReturnStatementClass;

#define VALA_TYPE_YIELD_STATEMENT (vala_yield_statement_get_type ())
#define VALA_YIELD_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_YIELD_STATEMENT, ValaYieldStatement))
#define VALA_YIELD_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_YIELD_STATEMENT, ValaYieldStatementClass))
#define VALA_IS_YIELD_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_YIELD_STATEMENT))
#define VALA_IS_YIELD_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_YIELD_STATEMENT))
#define VALA_YIELD_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_YIELD_STATEMENT, ValaYieldStatementClass))

typedef struct _ValaYieldStatement ValaYieldStatement;
typedef struct _ValaYieldStatementClass ValaYieldStatementClass;

#define VALA_TYPE_THROW_STATEMENT (vala_throw_statement_get_type ())
#define VALA_THROW_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_THROW_STATEMENT, ValaThrowStatement))
#define VALA_THROW_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_THROW_STATEMENT, ValaThrowStatementClass))
#define VALA_IS_THROW_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_THROW_STATEMENT))
#define VALA_IS_THROW_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_THROW_STATEMENT))
#define VALA_THROW_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_THROW_STATEMENT, ValaThrowStatementClass))

typedef struct _ValaThrowStatement ValaThrowStatement;
typedef struct _ValaThrowStatementClass ValaThrowStatementClass;

#define VALA_TYPE_TRY_STATEMENT (vala_try_statement_get_type ())
#define VALA_TRY_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TRY_STATEMENT, ValaTryStatement))
#define VALA_TRY_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TRY_STATEMENT, ValaTryStatementClass))
#define VALA_IS_TRY_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TRY_STATEMENT))
#define VALA_IS_TRY_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TRY_STATEMENT))
#define VALA_TRY_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TRY_STATEMENT, ValaTryStatementClass))

typedef struct _ValaTryStatement ValaTryStatement;
typedef struct _ValaTryStatementClass ValaTryStatementClass;

#define VALA_TYPE_CATCH_CLAUSE (vala_catch_clause_get_type ())
#define VALA_CATCH_CLAUSE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CATCH_CLAUSE, ValaCatchClause))
#define VALA_CATCH_CLAUSE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CATCH_CLAUSE, ValaCatchClauseClass))
#define VALA_IS_CATCH_CLAUSE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CATCH_CLAUSE))
#define VALA_IS_CATCH_CLAUSE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CATCH_CLAUSE))
#define VALA_CATCH_CLAUSE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CATCH_CLAUSE, ValaCatchClauseClass))

typedef struct _ValaCatchClause ValaCatchClause;
typedef struct _ValaCatchClauseClass ValaCatchClauseClass;

#define VALA_TYPE_LOCK_STATEMENT (vala_lock_statement_get_type ())
#define VALA_LOCK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LOCK_STATEMENT, ValaLockStatement))
#define VALA_LOCK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LOCK_STATEMENT, ValaLockStatementClass))
#define VALA_IS_LOCK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LOCK_STATEMENT))
#define VALA_IS_LOCK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LOCK_STATEMENT))
#define VALA_LOCK_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LOCK_STATEMENT, ValaLockStatementClass))

typedef struct _ValaLockStatement ValaLockStatement;
typedef struct _ValaLockStatementClass ValaLockStatementClass;

#define VALA_TYPE_UNLOCK_STATEMENT (vala_unlock_statement_get_type ())
#define VALA_UNLOCK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_UNLOCK_STATEMENT, ValaUnlockStatement))
#define VALA_UNLOCK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_UNLOCK_STATEMENT, ValaUnlockStatementClass))
#define VALA_IS_UNLOCK_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_UNLOCK_STATEMENT))
#define VALA_IS_UNLOCK_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_UNLOCK_STATEMENT))
#define VALA_UNLOCK_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_UNLOCK_STATEMENT, ValaUnlockStatementClass))

typedef struct _ValaUnlockStatement ValaUnlockStatement;
typedef struct _ValaUnlockStatementClass ValaUnlockStatementClass;

#define VALA_TYPE_DELETE_STATEMENT (vala_delete_statement_get_type ())
#define VALA_DELETE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_DELETE_STATEMENT, ValaDeleteStatement))
#define VALA_DELETE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_DELETE_STATEMENT, ValaDeleteStatementClass))
#define VALA_IS_DELETE_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_DELETE_STATEMENT))
#define VALA_IS_DELETE_STATEMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_DELETE_STATEMENT))
#define VALA_DELETE_STATEMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_DELETE_STATEMENT, ValaDeleteStatementClass))

typedef struct _ValaDeleteStatement ValaDeleteStatement;
typedef struct _ValaDeleteStatementClass ValaDeleteStatementClass;

#define VALA_TYPE_ARRAY_CREATION_EXPRESSION (vala_array_creation_expression_get_type ())
#define VALA_ARRAY_CREATION_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ARRAY_CREATION_EXPRESSION, ValaArrayCreationExpression))
#define VALA_ARRAY_CREATION_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ARRAY_CREATION_EXPRESSION, ValaArrayCreationExpressionClass))
#define VALA_IS_ARRAY_CREATION_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ARRAY_CREATION_EXPRESSION))
#define VALA_IS_ARRAY_CREATION_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ARRAY_CREATION_EXPRESSION))
#define VALA_ARRAY_CREATION_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ARRAY_CREATION_EXPRESSION, ValaArrayCreationExpressionClass))

typedef struct _ValaArrayCreationExpression ValaArrayCreationExpression;
typedef struct _ValaArrayCreationExpressionClass ValaArrayCreationExpressionClass;

#define VALA_TYPE_LITERAL (vala_literal_get_type ())
#define VALA_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LITERAL, ValaLiteral))
#define VALA_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LITERAL, ValaLiteralClass))
#define VALA_IS_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LITERAL))
#define VALA_IS_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LITERAL))
#define VALA_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LITERAL, ValaLiteralClass))

typedef struct _ValaLiteral ValaLiteral;
typedef struct _ValaLiteralClass ValaLiteralClass;

#define VALA_TYPE_BOOLEAN_LITERAL (vala_boolean_literal_get_type ())
#define VALA_BOOLEAN_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BOOLEAN_LITERAL, ValaBooleanLiteral))
#define VALA_BOOLEAN_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BOOLEAN_LITERAL, ValaBooleanLiteralClass))
#define VALA_IS_BOOLEAN_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BOOLEAN_LITERAL))
#define VALA_IS_BOOLEAN_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BOOLEAN_LITERAL))
#define VALA_BOOLEAN_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BOOLEAN_LITERAL, ValaBooleanLiteralClass))

typedef struct _ValaBooleanLiteral ValaBooleanLiteral;
typedef struct _ValaBooleanLiteralClass ValaBooleanLiteralClass;

#define VALA_TYPE_CHARACTER_LITERAL (vala_character_literal_get_type ())
#define VALA_CHARACTER_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CHARACTER_LITERAL, ValaCharacterLiteral))
#define VALA_CHARACTER_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CHARACTER_LITERAL, ValaCharacterLiteralClass))
#define VALA_IS_CHARACTER_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CHARACTER_LITERAL))
#define VALA_IS_CHARACTER_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CHARACTER_LITERAL))
#define VALA_CHARACTER_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CHARACTER_LITERAL, ValaCharacterLiteralClass))

typedef struct _ValaCharacterLiteral ValaCharacterLiteral;
typedef struct _ValaCharacterLiteralClass ValaCharacterLiteralClass;

#define VALA_TYPE_INTEGER_LITERAL (vala_integer_literal_get_type ())
#define VALA_INTEGER_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_INTEGER_LITERAL, ValaIntegerLiteral))
#define VALA_INTEGER_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_INTEGER_LITERAL, ValaIntegerLiteralClass))
#define VALA_IS_INTEGER_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_INTEGER_LITERAL))
#define VALA_IS_INTEGER_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_INTEGER_LITERAL))
#define VALA_INTEGER_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_INTEGER_LITERAL, ValaIntegerLiteralClass))

typedef struct _ValaIntegerLiteral ValaIntegerLiteral;
typedef struct _ValaIntegerLiteralClass ValaIntegerLiteralClass;

#define VALA_TYPE_REAL_LITERAL (vala_real_literal_get_type ())
#define VALA_REAL_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REAL_LITERAL, ValaRealLiteral))
#define VALA_REAL_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REAL_LITERAL, ValaRealLiteralClass))
#define VALA_IS_REAL_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REAL_LITERAL))
#define VALA_IS_REAL_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REAL_LITERAL))
#define VALA_REAL_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REAL_LITERAL, ValaRealLiteralClass))

typedef struct _ValaRealLiteral ValaRealLiteral;
typedef struct _ValaRealLiteralClass ValaRealLiteralClass;

#define VALA_TYPE_REGEX_LITERAL (vala_regex_literal_get_type ())
#define VALA_REGEX_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REGEX_LITERAL, ValaRegexLiteral))
#define VALA_REGEX_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REGEX_LITERAL, ValaRegexLiteralClass))
#define VALA_IS_REGEX_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REGEX_LITERAL))
#define VALA_IS_REGEX_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REGEX_LITERAL))
#define VALA_REGEX_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REGEX_LITERAL, ValaRegexLiteralClass))

typedef struct _ValaRegexLiteral ValaRegexLiteral;
typedef struct _ValaRegexLiteralClass ValaRegexLiteralClass;

#define VALA_TYPE_STRING_LITERAL (vala_string_literal_get_type ())
#define VALA_STRING_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_STRING_LITERAL, ValaStringLiteral))
#define VALA_STRING_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_STRING_LITERAL, ValaStringLiteralClass))
#define VALA_IS_STRING_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_STRING_LITERAL))
#define VALA_IS_STRING_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_STRING_LITERAL))
#define VALA_STRING_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_STRING_LITERAL, ValaStringLiteralClass))

typedef struct _ValaStringLiteral ValaStringLiteral;
typedef struct _ValaStringLiteralClass ValaStringLiteralClass;

#define VALA_TYPE_TEMPLATE (vala_template_get_type ())
#define VALA_TEMPLATE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TEMPLATE, ValaTemplate))
#define VALA_TEMPLATE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TEMPLATE, ValaTemplateClass))
#define VALA_IS_TEMPLATE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TEMPLATE))
#define VALA_IS_TEMPLATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TEMPLATE))
#define VALA_TEMPLATE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TEMPLATE, ValaTemplateClass))

typedef struct _ValaTemplate ValaTemplate;
typedef struct _ValaTemplateClass ValaTemplateClass;

#define VALA_TYPE_LIST_LITERAL (vala_list_literal_get_type ())
#define VALA_LIST_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LIST_LITERAL, ValaListLiteral))
#define VALA_LIST_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LIST_LITERAL, ValaListLiteralClass))
#define VALA_IS_LIST_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LIST_LITERAL))
#define VALA_IS_LIST_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LIST_LITERAL))
#define VALA_LIST_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LIST_LITERAL, ValaListLiteralClass))

typedef struct _ValaListLiteral ValaListLiteral;
typedef struct _ValaListLiteralClass ValaListLiteralClass;

#define VALA_TYPE_SET_LITERAL (vala_set_literal_get_type ())
#define VALA_SET_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SET_LITERAL, ValaSetLiteral))
#define VALA_SET_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SET_LITERAL, ValaSetLiteralClass))
#define VALA_IS_SET_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SET_LITERAL))
#define VALA_IS_SET_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SET_LITERAL))
#define VALA_SET_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SET_LITERAL, ValaSetLiteralClass))

typedef struct _ValaSetLiteral ValaSetLiteral;
typedef struct _ValaSetLiteralClass ValaSetLiteralClass;

#define VALA_TYPE_MAP_LITERAL (vala_map_literal_get_type ())
#define VALA_MAP_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_MAP_LITERAL, ValaMapLiteral))
#define VALA_MAP_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_MAP_LITERAL, ValaMapLiteralClass))
#define VALA_IS_MAP_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_MAP_LITERAL))
#define VALA_IS_MAP_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_MAP_LITERAL))
#define VALA_MAP_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_MAP_LITERAL, ValaMapLiteralClass))

typedef struct _ValaMapLiteral ValaMapLiteral;
typedef struct _ValaMapLiteralClass ValaMapLiteralClass;

#define VALA_TYPE_TUPLE (vala_tuple_get_type ())
#define VALA_TUPLE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TUPLE, ValaTuple))
#define VALA_TUPLE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TUPLE, ValaTupleClass))
#define VALA_IS_TUPLE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TUPLE))
#define VALA_IS_TUPLE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TUPLE))
#define VALA_TUPLE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TUPLE, ValaTupleClass))

typedef struct _ValaTuple ValaTuple;
typedef struct _ValaTupleClass ValaTupleClass;

#define VALA_TYPE_NULL_LITERAL (vala_null_literal_get_type ())
#define VALA_NULL_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_NULL_LITERAL, ValaNullLiteral))
#define VALA_NULL_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_NULL_LITERAL, ValaNullLiteralClass))
#define VALA_IS_NULL_LITERAL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_NULL_LITERAL))
#define VALA_IS_NULL_LITERAL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_NULL_LITERAL))
#define VALA_NULL_LITERAL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_NULL_LITERAL, ValaNullLiteralClass))

typedef struct _ValaNullLiteral ValaNullLiteral;
typedef struct _ValaNullLiteralClass ValaNullLiteralClass;

#define VALA_TYPE_MEMBER_ACCESS (vala_member_access_get_type ())
#define VALA_MEMBER_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_MEMBER_ACCESS, ValaMemberAccess))
#define VALA_MEMBER_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_MEMBER_ACCESS, ValaMemberAccessClass))
#define VALA_IS_MEMBER_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_MEMBER_ACCESS))
#define VALA_IS_MEMBER_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_MEMBER_ACCESS))
#define VALA_MEMBER_ACCESS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_MEMBER_ACCESS, ValaMemberAccessClass))

typedef struct _ValaMemberAccess ValaMemberAccess;
typedef struct _ValaMemberAccessClass ValaMemberAccessClass;

#define VALA_TYPE_METHOD_CALL (vala_method_call_get_type ())
#define VALA_METHOD_CALL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_METHOD_CALL, ValaMethodCall))
#define VALA_METHOD_CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_METHOD_CALL, ValaMethodCallClass))
#define VALA_IS_METHOD_CALL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_METHOD_CALL))
#define VALA_IS_METHOD_CALL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_METHOD_CALL))
#define VALA_METHOD_CALL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_METHOD_CALL, ValaMethodCallClass))

typedef struct _ValaMethodCall ValaMethodCall;
typedef struct _ValaMethodCallClass ValaMethodCallClass;

#define VALA_TYPE_ELEMENT_ACCESS (vala_element_access_get_type ())
#define VALA_ELEMENT_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ELEMENT_ACCESS, ValaElementAccess))
#define VALA_ELEMENT_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ELEMENT_ACCESS, ValaElementAccessClass))
#define VALA_IS_ELEMENT_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ELEMENT_ACCESS))
#define VALA_IS_ELEMENT_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ELEMENT_ACCESS))
#define VALA_ELEMENT_ACCESS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ELEMENT_ACCESS, ValaElementAccessClass))

typedef struct _ValaElementAccess ValaElementAccess;
typedef struct _ValaElementAccessClass ValaElementAccessClass;

#define VALA_TYPE_SLICE_EXPRESSION (vala_slice_expression_get_type ())
#define VALA_SLICE_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SLICE_EXPRESSION, ValaSliceExpression))
#define VALA_SLICE_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SLICE_EXPRESSION, ValaSliceExpressionClass))
#define VALA_IS_SLICE_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SLICE_EXPRESSION))
#define VALA_IS_SLICE_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SLICE_EXPRESSION))
#define VALA_SLICE_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SLICE_EXPRESSION, ValaSliceExpressionClass))

typedef struct _ValaSliceExpression ValaSliceExpression;
typedef struct _ValaSliceExpressionClass ValaSliceExpressionClass;

#define VALA_TYPE_BASE_ACCESS (vala_base_access_get_type ())
#define VALA_BASE_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BASE_ACCESS, ValaBaseAccess))
#define VALA_BASE_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BASE_ACCESS, ValaBaseAccessClass))
#define VALA_IS_BASE_ACCESS(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BASE_ACCESS))
#define VALA_IS_BASE_ACCESS_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BASE_ACCESS))
#define VALA_BASE_ACCESS_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BASE_ACCESS, ValaBaseAccessClass))

typedef struct _ValaBaseAccess ValaBaseAccess;
typedef struct _ValaBaseAccessClass ValaBaseAccessClass;

#define VALA_TYPE_POSTFIX_EXPRESSION (vala_postfix_expression_get_type ())
#define VALA_POSTFIX_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_POSTFIX_EXPRESSION, ValaPostfixExpression))
#define VALA_POSTFIX_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_POSTFIX_EXPRESSION, ValaPostfixExpressionClass))
#define VALA_IS_POSTFIX_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_POSTFIX_EXPRESSION))
#define VALA_IS_POSTFIX_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_POSTFIX_EXPRESSION))
#define VALA_POSTFIX_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_POSTFIX_EXPRESSION, ValaPostfixExpressionClass))

typedef struct _ValaPostfixExpression ValaPostfixExpression;
typedef struct _ValaPostfixExpressionClass ValaPostfixExpressionClass;

#define VALA_TYPE_OBJECT_CREATION_EXPRESSION (vala_object_creation_expression_get_type ())
#define VALA_OBJECT_CREATION_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_OBJECT_CREATION_EXPRESSION, ValaObjectCreationExpression))
#define VALA_OBJECT_CREATION_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_OBJECT_CREATION_EXPRESSION, ValaObjectCreationExpressionClass))
#define VALA_IS_OBJECT_CREATION_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_OBJECT_CREATION_EXPRESSION))
#define VALA_IS_OBJECT_CREATION_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_OBJECT_CREATION_EXPRESSION))
#define VALA_OBJECT_CREATION_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_OBJECT_CREATION_EXPRESSION, ValaObjectCreationExpressionClass))

typedef struct _ValaObjectCreationExpression ValaObjectCreationExpression;
typedef struct _ValaObjectCreationExpressionClass ValaObjectCreationExpressionClass;

#define VALA_TYPE_SIZEOF_EXPRESSION (vala_sizeof_expression_get_type ())
#define VALA_SIZEOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SIZEOF_EXPRESSION, ValaSizeofExpression))
#define VALA_SIZEOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SIZEOF_EXPRESSION, ValaSizeofExpressionClass))
#define VALA_IS_SIZEOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SIZEOF_EXPRESSION))
#define VALA_IS_SIZEOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SIZEOF_EXPRESSION))
#define VALA_SIZEOF_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SIZEOF_EXPRESSION, ValaSizeofExpressionClass))

typedef struct _ValaSizeofExpression ValaSizeofExpression;
typedef struct _ValaSizeofExpressionClass ValaSizeofExpressionClass;

#define VALA_TYPE_TYPEOF_EXPRESSION (vala_typeof_expression_get_type ())
#define VALA_TYPEOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPEOF_EXPRESSION, ValaTypeofExpression))
#define VALA_TYPEOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPEOF_EXPRESSION, ValaTypeofExpressionClass))
#define VALA_IS_TYPEOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPEOF_EXPRESSION))
#define VALA_IS_TYPEOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPEOF_EXPRESSION))
#define VALA_TYPEOF_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPEOF_EXPRESSION, ValaTypeofExpressionClass))

typedef struct _ValaTypeofExpression ValaTypeofExpression;
typedef struct _ValaTypeofExpressionClass ValaTypeofExpressionClass;

#define VALA_TYPE_UNARY_EXPRESSION (vala_unary_expression_get_type ())
#define VALA_UNARY_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_UNARY_EXPRESSION, ValaUnaryExpression))
#define VALA_UNARY_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_UNARY_EXPRESSION, ValaUnaryExpressionClass))
#define VALA_IS_UNARY_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_UNARY_EXPRESSION))
#define VALA_IS_UNARY_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_UNARY_EXPRESSION))
#define VALA_UNARY_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_UNARY_EXPRESSION, ValaUnaryExpressionClass))

typedef struct _ValaUnaryExpression ValaUnaryExpression;
typedef struct _ValaUnaryExpressionClass ValaUnaryExpressionClass;

#define VALA_TYPE_CAST_EXPRESSION (vala_cast_expression_get_type ())
#define VALA_CAST_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CAST_EXPRESSION, ValaCastExpression))
#define VALA_CAST_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CAST_EXPRESSION, ValaCastExpressionClass))
#define VALA_IS_CAST_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CAST_EXPRESSION))
#define VALA_IS_CAST_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CAST_EXPRESSION))
#define VALA_CAST_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CAST_EXPRESSION, ValaCastExpressionClass))

typedef struct _ValaCastExpression ValaCastExpression;
typedef struct _ValaCastExpressionClass ValaCastExpressionClass;

#define VALA_TYPE_NAMED_ARGUMENT (vala_named_argument_get_type ())
#define VALA_NAMED_ARGUMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_NAMED_ARGUMENT, ValaNamedArgument))
#define VALA_NAMED_ARGUMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_NAMED_ARGUMENT, ValaNamedArgumentClass))
#define VALA_IS_NAMED_ARGUMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_NAMED_ARGUMENT))
#define VALA_IS_NAMED_ARGUMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_NAMED_ARGUMENT))
#define VALA_NAMED_ARGUMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_NAMED_ARGUMENT, ValaNamedArgumentClass))

typedef struct _ValaNamedArgument ValaNamedArgument;
typedef struct _ValaNamedArgumentClass ValaNamedArgumentClass;

#define VALA_TYPE_POINTER_INDIRECTION (vala_pointer_indirection_get_type ())
#define VALA_POINTER_INDIRECTION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_POINTER_INDIRECTION, ValaPointerIndirection))
#define VALA_POINTER_INDIRECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_POINTER_INDIRECTION, ValaPointerIndirectionClass))
#define VALA_IS_POINTER_INDIRECTION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_POINTER_INDIRECTION))
#define VALA_IS_POINTER_INDIRECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_POINTER_INDIRECTION))
#define VALA_POINTER_INDIRECTION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_POINTER_INDIRECTION, ValaPointerIndirectionClass))

typedef struct _ValaPointerIndirection ValaPointerIndirection;
typedef struct _ValaPointerIndirectionClass ValaPointerIndirectionClass;

#define VALA_TYPE_ADDRESSOF_EXPRESSION (vala_addressof_expression_get_type ())
#define VALA_ADDRESSOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ADDRESSOF_EXPRESSION, ValaAddressofExpression))
#define VALA_ADDRESSOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ADDRESSOF_EXPRESSION, ValaAddressofExpressionClass))
#define VALA_IS_ADDRESSOF_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ADDRESSOF_EXPRESSION))
#define VALA_IS_ADDRESSOF_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ADDRESSOF_EXPRESSION))
#define VALA_ADDRESSOF_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ADDRESSOF_EXPRESSION, ValaAddressofExpressionClass))

typedef struct _ValaAddressofExpression ValaAddressofExpression;
typedef struct _ValaAddressofExpressionClass ValaAddressofExpressionClass;

#define VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION (vala_reference_transfer_expression_get_type ())
#define VALA_REFERENCE_TRANSFER_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION, ValaReferenceTransferExpression))
#define VALA_REFERENCE_TRANSFER_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION, ValaReferenceTransferExpressionClass))
#define VALA_IS_REFERENCE_TRANSFER_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION))
#define VALA_IS_REFERENCE_TRANSFER_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION))
#define VALA_REFERENCE_TRANSFER_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REFERENCE_TRANSFER_EXPRESSION, ValaReferenceTransferExpressionClass))

typedef struct _ValaReferenceTransferExpression ValaReferenceTransferExpression;
typedef struct _ValaReferenceTransferExpressionClass ValaReferenceTransferExpressionClass;

#define VALA_TYPE_BINARY_EXPRESSION (vala_binary_expression_get_type ())
#define VALA_BINARY_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_BINARY_EXPRESSION, ValaBinaryExpression))
#define VALA_BINARY_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_BINARY_EXPRESSION, ValaBinaryExpressionClass))
#define VALA_IS_BINARY_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_BINARY_EXPRESSION))
#define VALA_IS_BINARY_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_BINARY_EXPRESSION))
#define VALA_BINARY_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_BINARY_EXPRESSION, ValaBinaryExpressionClass))

typedef struct _ValaBinaryExpression ValaBinaryExpression;
typedef struct _ValaBinaryExpressionClass ValaBinaryExpressionClass;

#define VALA_TYPE_TYPECHECK (vala_typecheck_get_type ())
#define VALA_TYPECHECK(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_TYPECHECK, ValaTypeCheck))
#define VALA_TYPECHECK_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_TYPECHECK, ValaTypeCheckClass))
#define VALA_IS_TYPECHECK(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_TYPECHECK))
#define VALA_IS_TYPECHECK_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_TYPECHECK))
#define VALA_TYPECHECK_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_TYPECHECK, ValaTypeCheckClass))

typedef struct _ValaTypeCheck ValaTypeCheck;
typedef struct _ValaTypeCheckClass ValaTypeCheckClass;

#define VALA_TYPE_CONDITIONAL_EXPRESSION (vala_conditional_expression_get_type ())
#define VALA_CONDITIONAL_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CONDITIONAL_EXPRESSION, ValaConditionalExpression))
#define VALA_CONDITIONAL_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CONDITIONAL_EXPRESSION, ValaConditionalExpressionClass))
#define VALA_IS_CONDITIONAL_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CONDITIONAL_EXPRESSION))
#define VALA_IS_CONDITIONAL_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CONDITIONAL_EXPRESSION))
#define VALA_CONDITIONAL_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CONDITIONAL_EXPRESSION, ValaConditionalExpressionClass))

typedef struct _ValaConditionalExpression ValaConditionalExpression;
typedef struct _ValaConditionalExpressionClass ValaConditionalExpressionClass;

#define VALA_TYPE_LAMBDA_EXPRESSION (vala_lambda_expression_get_type ())
#define VALA_LAMBDA_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_LAMBDA_EXPRESSION, ValaLambdaExpression))
#define VALA_LAMBDA_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_LAMBDA_EXPRESSION, ValaLambdaExpressionClass))
#define VALA_IS_LAMBDA_EXPRESSION(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_LAMBDA_EXPRESSION))
#define VALA_IS_LAMBDA_EXPRESSION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_LAMBDA_EXPRESSION))
#define VALA_LAMBDA_EXPRESSION_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_LAMBDA_EXPRESSION, ValaLambdaExpressionClass))

typedef struct _ValaLambdaExpression ValaLambdaExpression;
typedef struct _ValaLambdaExpressionClass ValaLambdaExpressionClass;

#define VALA_TYPE_ASSIGNMENT (vala_assignment_get_type ())
#define VALA_ASSIGNMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ASSIGNMENT, ValaAssignment))
#define VALA_ASSIGNMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ASSIGNMENT, ValaAssignmentClass))
#define VALA_IS_ASSIGNMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ASSIGNMENT))
#define VALA_IS_ASSIGNMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ASSIGNMENT))
#define VALA_ASSIGNMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ASSIGNMENT, ValaAssignmentClass))

typedef struct _ValaAssignment ValaAssignment;
typedef struct _ValaAssignmentClass ValaAssignmentClass;

#define VALA_TYPE_PARSER (vala_parser_get_type ())
#define VALA_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_PARSER, ValaParser))
#define VALA_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_PARSER, ValaParserClass))
#define VALA_IS_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_PARSER))
#define VALA_IS_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_PARSER))
#define VALA_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_PARSER, ValaParserClass))

typedef struct _ValaParser ValaParser;
typedef struct _ValaParserClass ValaParserClass;
typedef struct _ValaParserPrivate ValaParserPrivate;

#define VALA_TYPE_SCANNER (vala_scanner_get_type ())
#define VALA_SCANNER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SCANNER, ValaScanner))
#define VALA_SCANNER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SCANNER, ValaScannerClass))
#define VALA_IS_SCANNER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SCANNER))
#define VALA_IS_SCANNER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SCANNER))
#define VALA_SCANNER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SCANNER, ValaScannerClass))

typedef struct _ValaScanner ValaScanner;
typedef struct _ValaScannerClass ValaScannerClass;

#define VALA_TYPE_CODE_CONTEXT (vala_code_context_get_type ())
#define VALA_CODE_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_CONTEXT, ValaCodeContext))
#define VALA_CODE_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_CONTEXT, ValaCodeContextClass))
#define VALA_IS_CODE_CONTEXT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_CONTEXT))
#define VALA_IS_CODE_CONTEXT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_CONTEXT))
#define VALA_CODE_CONTEXT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_CONTEXT, ValaCodeContextClass))

typedef struct _ValaCodeContext ValaCodeContext;
typedef struct _ValaCodeContextClass ValaCodeContextClass;

#define VALA_PARSER_TYPE_TOKEN_INFO (vala_parser_token_info_get_type ())

#define VALA_TYPE_TOKEN_TYPE (vala_token_type_get_type ())

#define VALA_TYPE_SOURCE_LOCATION (vala_source_location_get_type ())
typedef struct _ValaSourceLocation ValaSourceLocation;
typedef struct _ValaParserTokenInfo ValaParserTokenInfo;

#define VALA_TYPE_COMMENT (vala_comment_get_type ())
#define VALA_COMMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_COMMENT, ValaComment))
#define VALA_COMMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_COMMENT, ValaCommentClass))
#define VALA_IS_COMMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_COMMENT))
#define VALA_IS_COMMENT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_COMMENT))
#define VALA_COMMENT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_COMMENT, ValaCommentClass))

typedef struct _ValaComment ValaComment;
typedef struct _ValaCommentClass ValaCommentClass;

#define VALA_PARSER_TYPE_MODIFIER_FLAGS (vala_parser_modifier_flags_get_type ())

#define VALA_PARSER_TYPE_RECOVERY_STATE (vala_parser_recovery_state_get_type ())
#define _vala_scanner_unref0(var) ((var == NULL) ? NULL : (var = (vala_scanner_unref (var), NULL)))
#define _vala_code_context_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_context_unref (var), NULL)))
#define _vala_comment_unref0(var) ((var == NULL) ? NULL : (var = (vala_comment_unref (var), NULL)))

#define VALA_TYPE_SOURCE_REFERENCE (vala_source_reference_get_type ())
#define VALA_SOURCE_REFERENCE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SOURCE_REFERENCE, ValaSourceReference))
#define VALA_SOURCE_REFERENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SOURCE_REFERENCE, ValaSourceReferenceClass))
#define VALA_IS_SOURCE_REFERENCE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SOURCE_REFERENCE))
#define VALA_IS_SOURCE_REFERENCE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SOURCE_REFERENCE))
#define VALA_SOURCE_REFERENCE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SOURCE_REFERENCE, ValaSourceReferenceClass))

typedef struct _ValaSourceReference ValaSourceReference;
typedef struct _ValaSourceReferenceClass ValaSourceReferenceClass;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _vala_source_reference_unref0(var) ((var == NULL) ? NULL : (var = (vala_source_reference_unref (var), NULL)))
#define _vala_code_node_unref0(var) ((var == NULL) ? NULL : (var = (vala_code_node_unref (var), NULL)))

#define VALA_TYPE_REPORT (vala_report_get_type ())
#define VALA_REPORT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REPORT, ValaReport))
#define VALA_REPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REPORT, ValaReportClass))
#define VALA_IS_REPORT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REPORT))
#define VALA_IS_REPORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REPORT))
#define VALA_REPORT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REPORT, ValaReportClass))

typedef struct _ValaReport ValaReport;
typedef struct _ValaReportClass ValaReportClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define VALA_TYPE_UNRESOLVED_SYMBOL (vala_unresolved_symbol_get_type ())
#define VALA_UNRESOLVED_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_UNRESOLVED_SYMBOL, ValaUnresolvedSymbol))
#define VALA_UNRESOLVED_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_UNRESOLVED_SYMBOL, ValaUnresolvedSymbolClass))
#define VALA_IS_UNRESOLVED_SYMBOL(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_UNRESOLVED_SYMBOL))
#define VALA_IS_UNRESOLVED_SYMBOL_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_UNRESOLVED_SYMBOL))
#define VALA_UNRESOLVED_SYMBOL_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_UNRESOLVED_SYMBOL, ValaUnresolvedSymbolClass))

typedef struct _ValaUnresolvedSymbol ValaUnresolvedSymbol;
typedef struct _ValaUnresolvedSymbolClass ValaUnresolvedSymbolClass;

#define VALA_TYPE_VOID_TYPE (vala_void_type_get_type ())
#define VALA_VOID_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_VOID_TYPE, ValaVoidType))
#define VALA_VOID_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_VOID_TYPE, ValaVoidTypeClass))
#define VALA_IS_VOID_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_VOID_TYPE))
#define VALA_IS_VOID_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_VOID_TYPE))
#define VALA_VOID_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_VOID_TYPE, ValaVoidTypeClass))

typedef struct _ValaVoidType ValaVoidType;
typedef struct _ValaVoidTypeClass ValaVoidTypeClass;

#define VALA_TYPE_POINTER_TYPE (vala_pointer_type_get_type ())
#define VALA_POINTER_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_POINTER_TYPE, ValaPointerType))
#define VALA_POINTER_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_POINTER_TYPE, ValaPointerTypeClass))
#define VALA_IS_POINTER_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_POINTER_TYPE))
#define VALA_IS_POINTER_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_POINTER_TYPE))
#define VALA_POINTER_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_POINTER_TYPE, ValaPointerTypeClass))

typedef struct _ValaPointerType ValaPointerType;
typedef struct _ValaPointerTypeClass ValaPointerTypeClass;

#define VALA_TYPE_PROFILE (vala_profile_get_type ())

#define VALA_TYPE_UNRESOLVED_TYPE (vala_unresolved_type_get_type ())
#define VALA_UNRESOLVED_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_UNRESOLVED_TYPE, ValaUnresolvedType))
#define VALA_UNRESOLVED_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_UNRESOLVED_TYPE, ValaUnresolvedTypeClass))
#define VALA_IS_UNRESOLVED_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_UNRESOLVED_TYPE))
#define VALA_IS_UNRESOLVED_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_UNRESOLVED_TYPE))
#define VALA_UNRESOLVED_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_UNRESOLVED_TYPE, ValaUnresolvedTypeClass))

typedef struct _ValaUnresolvedType ValaUnresolvedType;
typedef struct _ValaUnresolvedTypeClass ValaUnresolvedTypeClass;
#define _vala_collection_object_unref0(var) ((var == NULL) ? NULL : (var = (vala_collection_object_unref (var), NULL)))

#define VALA_TYPE_REFERENCE_TYPE (vala_reference_type_get_type ())
#define VALA_REFERENCE_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_REFERENCE_TYPE, ValaReferenceType))
#define VALA_REFERENCE_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_REFERENCE_TYPE, ValaReferenceTypeClass))
#define VALA_IS_REFERENCE_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_REFERENCE_TYPE))
#define VALA_IS_REFERENCE_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_REFERENCE_TYPE))
#define VALA_REFERENCE_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_REFERENCE_TYPE, ValaReferenceTypeClass))

typedef struct _ValaReferenceType ValaReferenceType;
typedef struct _ValaReferenceTypeClass ValaReferenceTypeClass;

#define VALA_TYPE_ARRAY_TYPE (vala_array_type_get_type ())
#define VALA_ARRAY_TYPE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ARRAY_TYPE, ValaArrayType))
#define VALA_ARRAY_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ARRAY_TYPE, ValaArrayTypeClass))
#define VALA_IS_ARRAY_TYPE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ARRAY_TYPE))
#define VALA_IS_ARRAY_TYPE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ARRAY_TYPE))
#define VALA_ARRAY_TYPE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ARRAY_TYPE, ValaArrayTypeClass))

typedef struct _ValaArrayType ValaArrayType;
typedef struct _ValaArrayTypeClass ValaArrayTypeClass;

#define VALA_TYPE_UNARY_OPERATOR (vala_unary_operator_get_type ())

#define VALA_TYPE_MEMBER_INITIALIZER (vala_member_initializer_get_type ())
#define VALA_MEMBER_INITIALIZER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_MEMBER_INITIALIZER, ValaMemberInitializer))
#define VALA_MEMBER_INITIALIZER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_MEMBER_INITIALIZER, ValaMemberInitializerClass))
#define VALA_IS_MEMBER_INITIALIZER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_MEMBER_INITIALIZER))
#define VALA_IS_MEMBER_INITIALIZER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_MEMBER_INITIALIZER))
#define VALA_MEMBER_INITIALIZER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_MEMBER_INITIALIZER, ValaMemberInitializerClass))

typedef struct _ValaMemberInitializer ValaMemberInitializer;
typedef struct _ValaMemberInitializerClass ValaMemberInitializerClass;

#define VALA_TYPE_BINARY_OPERATOR (vala_binary_operator_get_type ())
typedef struct _ValaCodeNodePrivate ValaCodeNodePrivate;

#define VALA_TYPE_SEMANTIC_ANALYZER (vala_semantic_analyzer_get_type ())
#define VALA_SEMANTIC_ANALYZER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_SEMANTIC_ANALYZER, ValaSemanticAnalyzer))
#define VALA_SEMANTIC_ANALYZER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_SEMANTIC_ANALYZER, ValaSemanticAnalyzerClass))
#define VALA_IS_SEMANTIC_ANALYZER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_SEMANTIC_ANALYZER))
#define VALA_IS_SEMANTIC_ANALYZER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_SEMANTIC_ANALYZER))
#define VALA_SEMANTIC_ANALYZER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_SEMANTIC_ANALYZER, ValaSemanticAnalyzerClass))

typedef struct _ValaSemanticAnalyzer ValaSemanticAnalyzer;
typedef struct _ValaSemanticAnalyzerClass ValaSemanticAnalyzerClass;

#define VALA_TYPE_CODE_GENERATOR (vala_code_generator_get_type ())
#define VALA_CODE_GENERATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_CODE_GENERATOR, ValaCodeGenerator))
#define VALA_CODE_GENERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_CODE_GENERATOR, ValaCodeGeneratorClass))
#define VALA_IS_CODE_GENERATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_CODE_GENERATOR))
#define VALA_IS_CODE_GENERATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_CODE_GENERATOR))
#define VALA_CODE_GENERATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_CODE_GENERATOR, ValaCodeGeneratorClass))

typedef struct _ValaCodeGenerator ValaCodeGenerator;
typedef struct _ValaCodeGeneratorClass ValaCodeGeneratorClass;

#define VALA_TYPE_ATTRIBUTE (vala_attribute_get_type ())
#define VALA_ATTRIBUTE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_ATTRIBUTE, ValaAttribute))
#define VALA_ATTRIBUTE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), VALA_TYPE_ATTRIBUTE, ValaAttributeClass))
#define VALA_IS_ATTRIBUTE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_ATTRIBUTE))
#define VALA_IS_ATTRIBUTE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), VALA_TYPE_ATTRIBUTE))
#define VALA_ATTRIBUTE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), VALA_TYPE_ATTRIBUTE, ValaAttributeClass))

typedef struct _ValaAttribute ValaAttribute;
typedef struct _ValaAttributeClass ValaAttributeClass;
typedef struct _ValaExpressionPrivate ValaExpressionPrivate;
typedef struct _ValaBinaryExpressionPrivate ValaBinaryExpressionPrivate;

#define VALA_TYPE_ASSIGNMENT_OPERATOR (vala_assignment_operator_get_type ())

#define VALA_TYPE_STATEMENT (vala_statement_get_type ())
#define VALA_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), VALA_TYPE_STATEMENT, ValaStatement))
#define VALA_IS_STATEMENT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), VALA_TYPE_STATEMENT))
#define VALA_STATEMENT_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), VALA_TYPE_STATEMENT, ValaStatementIface))

typedef struct _ValaStatement ValaStatement;
typedef struct _ValaStatementIface ValaStatementIface;

#define TYPE_MEMBER_BINDING (member_binding_get_type ())

#define VALA_TYPE_SYMBOL_ACCESSIBILITY (vala_symbol_accessibility_get_type ())

#define VALA_TYPE_PARAMETER_DIRECTION (vala_parameter_direction_get_type ())

struct _ValaCodeVisitor {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ValaCodeVisitorPrivate * priv;
};

struct _ValaCodeVisitorClass {
	GTypeClass parent_class;
	void (*finalize) (ValaCodeVisitor *self);
	void (*visit_source_file) (ValaCodeVisitor* self, ValaSourceFile* source_file);
	void (*visit_namespace) (ValaCodeVisitor* self, ValaNamespace* ns);
	void (*visit_class) (ValaCodeVisitor* self, ValaClass* cl);
	void (*visit_struct) (ValaCodeVisitor* self, ValaStruct* st);
	void (*visit_interface) (ValaCodeVisitor* self, ValaInterface* iface);
	void (*visit_enum) (ValaCodeVisitor* self, ValaEnum* en);
	void (*visit_enum_value) (ValaCodeVisitor* self, ValaEnumValue* ev);
	void (*visit_error_domain) (ValaCodeVisitor* self, ValaErrorDomain* edomain);
	void (*visit_error_code) (ValaCodeVisitor* self, ValaErrorCode* ecode);
	void (*visit_delegate) (ValaCodeVisitor* self, ValaDelegate* d);
	void (*visit_constant) (ValaCodeVisitor* self, ValaConstant* c);
	void (*visit_field) (ValaCodeVisitor* self, ValaField* f);
	void (*visit_method) (ValaCodeVisitor* self, ValaMethod* m);
	void (*visit_creation_method) (ValaCodeVisitor* self, ValaCreationMethod* m);
	void (*visit_formal_parameter) (ValaCodeVisitor* self, ValaFormalParameter* p);
	void (*visit_property) (ValaCodeVisitor* self, ValaProperty* prop);
	void (*visit_property_accessor) (ValaCodeVisitor* self, ValaPropertyAccessor* acc);
	void (*visit_signal) (ValaCodeVisitor* self, ValaSignal* sig);
	void (*visit_constructor) (ValaCodeVisitor* self, ValaConstructor* c);
	void (*visit_destructor) (ValaCodeVisitor* self, ValaDestructor* d);
	void (*visit_type_parameter) (ValaCodeVisitor* self, ValaTypeParameter* p);
	void (*visit_using_directive) (ValaCodeVisitor* self, ValaUsingDirective* ns);
	void (*visit_data_type) (ValaCodeVisitor* self, ValaDataType* type);
	void (*visit_block) (ValaCodeVisitor* self, ValaBlock* b);
	void (*visit_empty_statement) (ValaCodeVisitor* self, ValaEmptyStatement* stmt);
	void (*visit_declaration_statement) (ValaCodeVisitor* self, ValaDeclarationStatement* stmt);
	void (*visit_local_variable) (ValaCodeVisitor* self, ValaLocalVariable* local);
	void (*visit_initializer_list) (ValaCodeVisitor* self, ValaInitializerList* list);
	void (*visit_expression_statement) (ValaCodeVisitor* self, ValaExpressionStatement* stmt);
	void (*visit_if_statement) (ValaCodeVisitor* self, ValaIfStatement* stmt);
	void (*visit_switch_statement) (ValaCodeVisitor* self, ValaSwitchStatement* stmt);
	void (*visit_switch_section) (ValaCodeVisitor* self, ValaSwitchSection* section);
	void (*visit_switch_label) (ValaCodeVisitor* self, ValaSwitchLabel* label);
	void (*visit_loop) (ValaCodeVisitor* self, ValaLoop* stmt);
	void (*visit_while_statement) (ValaCodeVisitor* self, ValaWhileStatement* stmt);
	void (*visit_do_statement) (ValaCodeVisitor* self, ValaDoStatement* stmt);
	void (*visit_for_statement) (ValaCodeVisitor* self, ValaForStatement* stmt);
	void (*visit_foreach_statement) (ValaCodeVisitor* self, ValaForeachStatement* stmt);
	void (*visit_break_statement) (ValaCodeVisitor* self, ValaBreakStatement* stmt);
	void (*visit_continue_statement) (ValaCodeVisitor* self, ValaContinueStatement* stmt);
	void (*visit_return_statement) (ValaCodeVisitor* self, ValaReturnStatement* stmt);
	void (*visit_yield_statement) (ValaCodeVisitor* self, ValaYieldStatement* y);
	void (*visit_throw_statement) (ValaCodeVisitor* self, ValaThrowStatement* stmt);
	void (*visit_try_statement) (ValaCodeVisitor* self, ValaTryStatement* stmt);
	void (*visit_catch_clause) (ValaCodeVisitor* self, ValaCatchClause* clause);
	void (*visit_lock_statement) (ValaCodeVisitor* self, ValaLockStatement* stmt);
	void (*visit_unlock_statement) (ValaCodeVisitor* self, ValaUnlockStatement* stmt);
	void (*visit_delete_statement) (ValaCodeVisitor* self, ValaDeleteStatement* stmt);
	void (*visit_expression) (ValaCodeVisitor* self, ValaExpression* expr);
	void (*visit_array_creation_expression) (ValaCodeVisitor* self, ValaArrayCreationExpression* expr);
	void (*visit_boolean_literal) (ValaCodeVisitor* self, ValaBooleanLiteral* lit);
	void (*visit_character_literal) (ValaCodeVisitor* self, ValaCharacterLiteral* lit);
	void (*visit_integer_literal) (ValaCodeVisitor* self, ValaIntegerLiteral* lit);
	void (*visit_real_literal) (ValaCodeVisitor* self, ValaRealLiteral* lit);
	void (*visit_regex_literal) (ValaCodeVisitor* self, ValaRegexLiteral* lit);
	void (*visit_string_literal) (ValaCodeVisitor* self, ValaStringLiteral* lit);
	void (*visit_template) (ValaCodeVisitor* self, ValaTemplate* tmpl);
	void (*visit_list_literal) (ValaCodeVisitor* self, ValaListLiteral* lit);
	void (*visit_set_literal) (ValaCodeVisitor* self, ValaSetLiteral* lit);
	void (*visit_map_literal) (ValaCodeVisitor* self, ValaMapLiteral* lit);
	void (*visit_tuple) (ValaCodeVisitor* self, ValaTuple* tuple);
	void (*visit_null_literal) (ValaCodeVisitor* self, ValaNullLiteral* lit);
	void (*visit_member_access) (ValaCodeVisitor* self, ValaMemberAccess* expr);
	void (*visit_method_call) (ValaCodeVisitor* self, ValaMethodCall* expr);
	void (*visit_element_access) (ValaCodeVisitor* self, ValaElementAccess* expr);
	void (*visit_slice_expression) (ValaCodeVisitor* self, ValaSliceExpression* expr);
	void (*visit_base_access) (ValaCodeVisitor* self, ValaBaseAccess* expr);
	void (*visit_postfix_expression) (ValaCodeVisitor* self, ValaPostfixExpression* expr);
	void (*visit_object_creation_expression) (ValaCodeVisitor* self, ValaObjectCreationExpression* expr);
	void (*visit_sizeof_expression) (ValaCodeVisitor* self, ValaSizeofExpression* expr);
	void (*visit_typeof_expression) (ValaCodeVisitor* self, ValaTypeofExpression* expr);
	void (*visit_unary_expression) (ValaCodeVisitor* self, ValaUnaryExpression* expr);
	void (*visit_cast_expression) (ValaCodeVisitor* self, ValaCastExpression* expr);
	void (*visit_named_argument) (ValaCodeVisitor* self, ValaNamedArgument* expr);
	void (*visit_pointer_indirection) (ValaCodeVisitor* self, ValaPointerIndirection* expr);
	void (*visit_addressof_expression) (ValaCodeVisitor* self, ValaAddressofExpression* expr);
	void (*visit_reference_transfer_expression) (ValaCodeVisitor* self, ValaReferenceTransferExpression* expr);
	void (*visit_binary_expression) (ValaCodeVisitor* self, ValaBinaryExpression* expr);
	void (*visit_type_check) (ValaCodeVisitor* self, ValaTypeCheck* expr);
	void (*visit_conditional_expression) (ValaCodeVisitor* self, ValaConditionalExpression* expr);
	void (*visit_lambda_expression) (ValaCodeVisitor* self, ValaLambdaExpression* expr);
	void (*visit_assignment) (ValaCodeVisitor* self, ValaAssignment* a);
	void (*visit_end_full_expression) (ValaCodeVisitor* self, ValaExpression* expr);
};

struct _ValaParser {
	ValaCodeVisitor parent_instance;
	ValaParserPrivate * priv;
};

struct _ValaParserClass {
	ValaCodeVisitorClass parent_class;
};

typedef enum  {
	VALA_TOKEN_TYPE_NONE,
	VALA_TOKEN_TYPE_ABSTRACT,
	VALA_TOKEN_TYPE_AS,
	VALA_TOKEN_TYPE_ASSIGN,
	VALA_TOKEN_TYPE_ASSIGN_ADD,
	VALA_TOKEN_TYPE_ASSIGN_BITWISE_AND,
	VALA_TOKEN_TYPE_ASSIGN_BITWISE_OR,
	VALA_TOKEN_TYPE_ASSIGN_BITWISE_XOR,
	VALA_TOKEN_TYPE_ASSIGN_DIV,
	VALA_TOKEN_TYPE_ASSIGN_MUL,
	VALA_TOKEN_TYPE_ASSIGN_PERCENT,
	VALA_TOKEN_TYPE_ASSIGN_SHIFT_LEFT,
	VALA_TOKEN_TYPE_ASSIGN_SUB,
	VALA_TOKEN_TYPE_ASYNC,
	VALA_TOKEN_TYPE_BASE,
	VALA_TOKEN_TYPE_BITWISE_AND,
	VALA_TOKEN_TYPE_BITWISE_OR,
	VALA_TOKEN_TYPE_BREAK,
	VALA_TOKEN_TYPE_CARRET,
	VALA_TOKEN_TYPE_CASE,
	VALA_TOKEN_TYPE_CATCH,
	VALA_TOKEN_TYPE_CHARACTER_LITERAL,
	VALA_TOKEN_TYPE_CLASS,
	VALA_TOKEN_TYPE_CLOSE_BRACE,
	VALA_TOKEN_TYPE_CLOSE_BRACKET,
	VALA_TOKEN_TYPE_CLOSE_PARENS,
	VALA_TOKEN_TYPE_CLOSE_REGEX_LITERAL,
	VALA_TOKEN_TYPE_CLOSE_TEMPLATE,
	VALA_TOKEN_TYPE_COLON,
	VALA_TOKEN_TYPE_COMMA,
	VALA_TOKEN_TYPE_CONST,
	VALA_TOKEN_TYPE_CONSTRUCT,
	VALA_TOKEN_TYPE_CONTINUE,
	VALA_TOKEN_TYPE_DEFAULT,
	VALA_TOKEN_TYPE_DELEGATE,
	VALA_TOKEN_TYPE_DELETE,
	VALA_TOKEN_TYPE_DIV,
	VALA_TOKEN_TYPE_DO,
	VALA_TOKEN_TYPE_DOUBLE_COLON,
	VALA_TOKEN_TYPE_DOT,
	VALA_TOKEN_TYPE_DYNAMIC,
	VALA_TOKEN_TYPE_ELLIPSIS,
	VALA_TOKEN_TYPE_ELSE,
	VALA_TOKEN_TYPE_ENUM,
	VALA_TOKEN_TYPE_ENSURES,
	VALA_TOKEN_TYPE_ERRORDOMAIN,
	VALA_TOKEN_TYPE_EOF,
	VALA_TOKEN_TYPE_EXTERN,
	VALA_TOKEN_TYPE_FALSE,
	VALA_TOKEN_TYPE_FINALLY,
	VALA_TOKEN_TYPE_FOR,
	VALA_TOKEN_TYPE_FOREACH,
	VALA_TOKEN_TYPE_GET,
	VALA_TOKEN_TYPE_HASH,
	VALA_TOKEN_TYPE_IDENTIFIER,
	VALA_TOKEN_TYPE_IF,
	VALA_TOKEN_TYPE_IN,
	VALA_TOKEN_TYPE_INLINE,
	VALA_TOKEN_TYPE_INTEGER_LITERAL,
	VALA_TOKEN_TYPE_INTERFACE,
	VALA_TOKEN_TYPE_INTERNAL,
	VALA_TOKEN_TYPE_INTERR,
	VALA_TOKEN_TYPE_IS,
	VALA_TOKEN_TYPE_LAMBDA,
	VALA_TOKEN_TYPE_LOCK,
	VALA_TOKEN_TYPE_MINUS,
	VALA_TOKEN_TYPE_NAMESPACE,
	VALA_TOKEN_TYPE_NEW,
	VALA_TOKEN_TYPE_NULL,
	VALA_TOKEN_TYPE_OUT,
	VALA_TOKEN_TYPE_OP_AND,
	VALA_TOKEN_TYPE_OP_COALESCING,
	VALA_TOKEN_TYPE_OP_DEC,
	VALA_TOKEN_TYPE_OP_EQ,
	VALA_TOKEN_TYPE_OP_GE,
	VALA_TOKEN_TYPE_OP_GT,
	VALA_TOKEN_TYPE_OP_INC,
	VALA_TOKEN_TYPE_OP_LE,
	VALA_TOKEN_TYPE_OP_LT,
	VALA_TOKEN_TYPE_OP_NE,
	VALA_TOKEN_TYPE_OP_NEG,
	VALA_TOKEN_TYPE_OP_OR,
	VALA_TOKEN_TYPE_OP_PTR,
	VALA_TOKEN_TYPE_OP_SHIFT_LEFT,
	VALA_TOKEN_TYPE_OPEN_BRACE,
	VALA_TOKEN_TYPE_OPEN_BRACKET,
	VALA_TOKEN_TYPE_OPEN_PARENS,
	VALA_TOKEN_TYPE_OPEN_REGEX_LITERAL,
	VALA_TOKEN_TYPE_OPEN_TEMPLATE,
	VALA_TOKEN_TYPE_OVERRIDE,
	VALA_TOKEN_TYPE_OWNED,
	VALA_TOKEN_TYPE_PARAMS,
	VALA_TOKEN_TYPE_PERCENT,
	VALA_TOKEN_TYPE_PLUS,
	VALA_TOKEN_TYPE_PRIVATE,
	VALA_TOKEN_TYPE_PROTECTED,
	VALA_TOKEN_TYPE_PUBLIC,
	VALA_TOKEN_TYPE_REAL_LITERAL,
	VALA_TOKEN_TYPE_REF,
	VALA_TOKEN_TYPE_REGEX_LITERAL,
	VALA_TOKEN_TYPE_REQUIRES,
	VALA_TOKEN_TYPE_RETURN,
	VALA_TOKEN_TYPE_SEALED,
	VALA_TOKEN_TYPE_SEMICOLON,
	VALA_TOKEN_TYPE_SET,
	VALA_TOKEN_TYPE_SIGNAL,
	VALA_TOKEN_TYPE_SIZEOF,
	VALA_TOKEN_TYPE_STAR,
	VALA_TOKEN_TYPE_STATIC,
	VALA_TOKEN_TYPE_STRING_LITERAL,
	VALA_TOKEN_TYPE_STRUCT,
	VALA_TOKEN_TYPE_SWITCH,
	VALA_TOKEN_TYPE_TEMPLATE_STRING_LITERAL,
	VALA_TOKEN_TYPE_THIS,
	VALA_TOKEN_TYPE_THROW,
	VALA_TOKEN_TYPE_THROWS,
	VALA_TOKEN_TYPE_TILDE,
	VALA_TOKEN_TYPE_TRUE,
	VALA_TOKEN_TYPE_TRY,
	VALA_TOKEN_TYPE_TYPEOF,
	VALA_TOKEN_TYPE_UNOWNED,
	VALA_TOKEN_TYPE_USING,
	VALA_TOKEN_TYPE_VAR,
	VALA_TOKEN_TYPE_VERBATIM_STRING_LITERAL,
	VALA_TOKEN_TYPE_VIRTUAL,
	VALA_TOKEN_TYPE_VOID,
	VALA_TOKEN_TYPE_VOLATILE,
	VALA_TOKEN_TYPE_WEAK,
	VALA_TOKEN_TYPE_WHILE,
	VALA_TOKEN_TYPE_YIELD
} ValaTokenType;

struct _ValaSourceLocation {
	gchar* pos;
	gint line;
	gint column;
};

struct _ValaParserTokenInfo {
	ValaTokenType type;
	ValaSourceLocation begin;
	ValaSourceLocation end;
};

struct _ValaParserPrivate {
	ValaScanner* scanner;
	ValaCodeContext* context;
	ValaParserTokenInfo* tokens;
	gint tokens_length1;
	gint _tokens_size_;
	gint index;
	gint size;
	ValaComment* comment;
};

typedef enum  {
	VALA_PARSER_MODIFIER_FLAGS_NONE,
	VALA_PARSER_MODIFIER_FLAGS_ABSTRACT = 1 << 0,
	VALA_PARSER_MODIFIER_FLAGS_CLASS = 1 << 1,
	VALA_PARSER_MODIFIER_FLAGS_EXTERN = 1 << 2,
	VALA_PARSER_MODIFIER_FLAGS_INLINE = 1 << 3,
	VALA_PARSER_MODIFIER_FLAGS_NEW = 1 << 4,
	VALA_PARSER_MODIFIER_FLAGS_OVERRIDE = 1 << 5,
	VALA_PARSER_MODIFIER_FLAGS_STATIC = 1 << 6,
	VALA_PARSER_MODIFIER_FLAGS_VIRTUAL = 1 << 7,
	VALA_PARSER_MODIFIER_FLAGS_ASYNC = 1 << 8,
	VALA_PARSER_MODIFIER_FLAGS_SEALED = 1 << 9
} ValaParserModifierFlags;

typedef enum  {
	VALA_PARSER_RECOVERY_STATE_EOF,
	VALA_PARSER_RECOVERY_STATE_DECLARATION_BEGIN,
	VALA_PARSER_RECOVERY_STATE_STATEMENT_BEGIN
} ValaParserRecoveryState;

typedef enum  {
	VALA_PARSE_ERROR_FAILED,
	VALA_PARSE_ERROR_SYNTAX
} ValaParseError;
#define VALA_PARSE_ERROR vala_parse_error_quark ()
typedef enum  {
	VALA_PROFILE_POSIX,
	VALA_PROFILE_GOBJECT,
	VALA_PROFILE_DOVA
} ValaProfile;

typedef enum  {
	VALA_UNARY_OPERATOR_NONE,
	VALA_UNARY_OPERATOR_PLUS,
	VALA_UNARY_OPERATOR_MINUS,
	VALA_UNARY_OPERATOR_LOGICAL_NEGATION,
	VALA_UNARY_OPERATOR_BITWISE_COMPLEMENT,
	VALA_UNARY_OPERATOR_INCREMENT,
	VALA_UNARY_OPERATOR_DECREMENT,
	VALA_UNARY_OPERATOR_REF,
	VALA_UNARY_OPERATOR_OUT
} ValaUnaryOperator;

typedef enum  {
	VALA_BINARY_OPERATOR_NONE,
	VALA_BINARY_OPERATOR_PLUS,
	VALA_BINARY_OPERATOR_MINUS,
	VALA_BINARY_OPERATOR_MUL,
	VALA_BINARY_OPERATOR_DIV,
	VALA_BINARY_OPERATOR_MOD,
	VALA_BINARY_OPERATOR_SHIFT_LEFT,
	VALA_BINARY_OPERATOR_SHIFT_RIGHT,
	VALA_BINARY_OPERATOR_LESS_THAN,
	VALA_BINARY_OPERATOR_GREATER_THAN,
	VALA_BINARY_OPERATOR_LESS_THAN_OR_EQUAL,
	VALA_BINARY_OPERATOR_GREATER_THAN_OR_EQUAL,
	VALA_BINARY_OPERATOR_EQUALITY,
	VALA_BINARY_OPERATOR_INEQUALITY,
	VALA_BINARY_OPERATOR_BITWISE_AND,
	VALA_BINARY_OPERATOR_BITWISE_OR,
	VALA_BINARY_OPERATOR_BITWISE_XOR,
	VALA_BINARY_OPERATOR_AND,
	VALA_BINARY_OPERATOR_OR,
	VALA_BINARY_OPERATOR_IN,
	VALA_BINARY_OPERATOR_COALESCE
} ValaBinaryOperator;

struct _ValaCodeNode {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ValaCodeNodePrivate * priv;
	GList* attributes;
};

struct _ValaCodeNodeClass {
	GTypeClass parent_class;
	void (*finalize) (ValaCodeNode *self);
	void (*accept) (ValaCodeNode* self, ValaCodeVisitor* visitor);
	void (*accept_children) (ValaCodeNode* self, ValaCodeVisitor* visitor);
	gboolean (*check) (ValaCodeNode* self, ValaSemanticAnalyzer* analyzer);
	void (*emit) (ValaCodeNode* self, ValaCodeGenerator* codegen);
	void (*replace_type) (ValaCodeNode* self, ValaDataType* old_type, ValaDataType* new_type);
	void (*replace_expression) (ValaCodeNode* self, ValaExpression* old_node, ValaExpression* new_node);
	char* (*to_string) (ValaCodeNode* self);
	void (*get_defined_variables) (ValaCodeNode* self, ValaCollection* collection);
	void (*get_used_variables) (ValaCodeNode* self, ValaCollection* collection);
};

struct _ValaExpression {
	ValaCodeNode parent_instance;
	ValaExpressionPrivate * priv;
	ValaArrayList* temp_vars;
};

struct _ValaExpressionClass {
	ValaCodeNodeClass parent_class;
	gboolean (*is_constant) (ValaExpression* self);
	gboolean (*is_pure) (ValaExpression* self);
	gboolean (*is_non_null) (ValaExpression* self);
};

struct _ValaBinaryExpression {
	ValaExpression parent_instance;
	ValaBinaryExpressionPrivate * priv;
	gboolean chained;
};

struct _ValaBinaryExpressionClass {
	ValaExpressionClass parent_class;
};

typedef enum  {
	VALA_ASSIGNMENT_OPERATOR_NONE,
	VALA_ASSIGNMENT_OPERATOR_SIMPLE,
	VALA_ASSIGNMENT_OPERATOR_BITWISE_OR,
	VALA_ASSIGNMENT_OPERATOR_BITWISE_AND,
	VALA_ASSIGNMENT_OPERATOR_BITWISE_XOR,
	VALA_ASSIGNMENT_OPERATOR_ADD,
	VALA_ASSIGNMENT_OPERATOR_SUB,
	VALA_ASSIGNMENT_OPERATOR_MUL,
	VALA_ASSIGNMENT_OPERATOR_DIV,
	VALA_ASSIGNMENT_OPERATOR_PERCENT,
	VALA_ASSIGNMENT_OPERATOR_SHIFT_LEFT,
	VALA_ASSIGNMENT_OPERATOR_SHIFT_RIGHT
} ValaAssignmentOperator;

struct _ValaStatementIface {
	GTypeInterface parent_iface;
};

typedef enum  {
	MEMBER_BINDING_INSTANCE,
	MEMBER_BINDING_CLASS,
	MEMBER_BINDING_STATIC
} MemberBinding;

typedef enum  {
	VALA_SYMBOL_ACCESSIBILITY_PRIVATE,
	VALA_SYMBOL_ACCESSIBILITY_INTERNAL,
	VALA_SYMBOL_ACCESSIBILITY_PROTECTED,
	VALA_SYMBOL_ACCESSIBILITY_PUBLIC
} ValaSymbolAccessibility;

typedef enum  {
	VALA_PARAMETER_DIRECTION_IN,
	VALA_PARAMETER_DIRECTION_OUT,
	VALA_PARAMETER_DIRECTION_REF
} ValaParameterDirection;


static gpointer vala_parser_parent_class = NULL;

gpointer vala_code_visitor_ref (gpointer instance);
void vala_code_visitor_unref (gpointer instance);
GParamSpec* vala_param_spec_code_visitor (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_code_visitor (GValue* value, gpointer v_object);
void vala_value_take_code_visitor (GValue* value, gpointer v_object);
gpointer vala_value_get_code_visitor (const GValue* value);
GType vala_code_visitor_get_type (void) G_GNUC_CONST;
gpointer vala_source_file_ref (gpointer instance);
void vala_source_file_unref (gpointer instance);
GParamSpec* vala_param_spec_source_file (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_source_file (GValue* value, gpointer v_object);
void vala_value_take_source_file (GValue* value, gpointer v_object);
gpointer vala_value_get_source_file (const GValue* value);
GType vala_source_file_get_type (void) G_GNUC_CONST;
gpointer vala_code_node_ref (gpointer instance);
void vala_code_node_unref (gpointer instance);
GParamSpec* vala_param_spec_code_node (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_code_node (GValue* value, gpointer v_object);
void vala_value_take_code_node (GValue* value, gpointer v_object);
gpointer vala_value_get_code_node (const GValue* value);
GType vala_code_node_get_type (void) G_GNUC_CONST;
GType vala_symbol_get_type (void) G_GNUC_CONST;
GType vala_namespace_get_type (void) G_GNUC_CONST;
GType vala_typesymbol_get_type (void) G_GNUC_CONST;
GType vala_object_type_symbol_get_type (void) G_GNUC_CONST;
GType vala_class_get_type (void) G_GNUC_CONST;
GType vala_struct_get_type (void) G_GNUC_CONST;
GType vala_interface_get_type (void) G_GNUC_CONST;
GType vala_enum_get_type (void) G_GNUC_CONST;
GType vala_constant_get_type (void) G_GNUC_CONST;
GType vala_enum_value_get_type (void) G_GNUC_CONST;
GType vala_error_domain_get_type (void) G_GNUC_CONST;
GType vala_error_code_get_type (void) G_GNUC_CONST;
GType vala_delegate_get_type (void) G_GNUC_CONST;
GType vala_variable_get_type (void) G_GNUC_CONST;
GType vala_field_get_type (void) G_GNUC_CONST;
GType vala_method_get_type (void) G_GNUC_CONST;
GType vala_creation_method_get_type (void) G_GNUC_CONST;
GType vala_formal_parameter_get_type (void) G_GNUC_CONST;
GType vala_property_get_type (void) G_GNUC_CONST;
GType vala_property_accessor_get_type (void) G_GNUC_CONST;
GType vala_signal_get_type (void) G_GNUC_CONST;
GType vala_constructor_get_type (void) G_GNUC_CONST;
GType vala_destructor_get_type (void) G_GNUC_CONST;
GType vala_typeparameter_get_type (void) G_GNUC_CONST;
GType vala_using_directive_get_type (void) G_GNUC_CONST;
GType vala_data_type_get_type (void) G_GNUC_CONST;
GType vala_block_get_type (void) G_GNUC_CONST;
GType vala_empty_statement_get_type (void) G_GNUC_CONST;
GType vala_declaration_statement_get_type (void) G_GNUC_CONST;
GType vala_local_variable_get_type (void) G_GNUC_CONST;
GType vala_expression_get_type (void) G_GNUC_CONST;
GType vala_initializer_list_get_type (void) G_GNUC_CONST;
GType vala_expression_statement_get_type (void) G_GNUC_CONST;
GType vala_if_statement_get_type (void) G_GNUC_CONST;
GType vala_switch_statement_get_type (void) G_GNUC_CONST;
GType vala_switch_section_get_type (void) G_GNUC_CONST;
GType vala_switch_label_get_type (void) G_GNUC_CONST;
GType vala_loop_get_type (void) G_GNUC_CONST;
GType vala_while_statement_get_type (void) G_GNUC_CONST;
GType vala_do_statement_get_type (void) G_GNUC_CONST;
GType vala_for_statement_get_type (void) G_GNUC_CONST;
GType vala_foreach_statement_get_type (void) G_GNUC_CONST;
GType vala_break_statement_get_type (void) G_GNUC_CONST;
GType vala_continue_statement_get_type (void) G_GNUC_CONST;
GType vala_return_statement_get_type (void) G_GNUC_CONST;
GType vala_yield_statement_get_type (void) G_GNUC_CONST;
GType vala_throw_statement_get_type (void) G_GNUC_CONST;
GType vala_try_statement_get_type (void) G_GNUC_CONST;
GType vala_catch_clause_get_type (void) G_GNUC_CONST;
GType vala_lock_statement_get_type (void) G_GNUC_CONST;
GType vala_unlock_statement_get_type (void) G_GNUC_CONST;
GType vala_delete_statement_get_type (void) G_GNUC_CONST;
GType vala_array_creation_expression_get_type (void) G_GNUC_CONST;
GType vala_literal_get_type (void) G_GNUC_CONST;
GType vala_boolean_literal_get_type (void) G_GNUC_CONST;
GType vala_character_literal_get_type (void) G_GNUC_CONST;
GType vala_integer_literal_get_type (void) G_GNUC_CONST;
GType vala_real_literal_get_type (void) G_GNUC_CONST;
GType vala_regex_literal_get_type (void) G_GNUC_CONST;
GType vala_string_literal_get_type (void) G_GNUC_CONST;
GType vala_template_get_type (void) G_GNUC_CONST;
GType vala_list_literal_get_type (void) G_GNUC_CONST;
GType vala_set_literal_get_type (void) G_GNUC_CONST;
GType vala_map_literal_get_type (void) G_GNUC_CONST;
GType vala_tuple_get_type (void) G_GNUC_CONST;
GType vala_null_literal_get_type (void) G_GNUC_CONST;
GType vala_member_access_get_type (void) G_GNUC_CONST;
GType vala_method_call_get_type (void) G_GNUC_CONST;
GType vala_element_access_get_type (void) G_GNUC_CONST;
GType vala_slice_expression_get_type (void) G_GNUC_CONST;
GType vala_base_access_get_type (void) G_GNUC_CONST;
GType vala_postfix_expression_get_type (void) G_GNUC_CONST;
GType vala_object_creation_expression_get_type (void) G_GNUC_CONST;
GType vala_sizeof_expression_get_type (void) G_GNUC_CONST;
GType vala_typeof_expression_get_type (void) G_GNUC_CONST;
GType vala_unary_expression_get_type (void) G_GNUC_CONST;
GType vala_cast_expression_get_type (void) G_GNUC_CONST;
GType vala_named_argument_get_type (void) G_GNUC_CONST;
GType vala_pointer_indirection_get_type (void) G_GNUC_CONST;
GType vala_addressof_expression_get_type (void) G_GNUC_CONST;
GType vala_reference_transfer_expression_get_type (void) G_GNUC_CONST;
GType vala_binary_expression_get_type (void) G_GNUC_CONST;
GType vala_typecheck_get_type (void) G_GNUC_CONST;
GType vala_conditional_expression_get_type (void) G_GNUC_CONST;
GType vala_lambda_expression_get_type (void) G_GNUC_CONST;
GType vala_assignment_get_type (void) G_GNUC_CONST;
GType vala_parser_get_type (void) G_GNUC_CONST;
gpointer vala_scanner_ref (gpointer instance);
void vala_scanner_unref (gpointer instance);
GParamSpec* vala_param_spec_scanner (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_scanner (GValue* value, gpointer v_object);
void vala_value_take_scanner (GValue* value, gpointer v_object);
gpointer vala_value_get_scanner (const GValue* value);
GType vala_scanner_get_type (void) G_GNUC_CONST;
gpointer vala_code_context_ref (gpointer instance);
void vala_code_context_unref (gpointer instance);
GParamSpec* vala_param_spec_code_context (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_code_context (GValue* value, gpointer v_object);
void vala_value_take_code_context (GValue* value, gpointer v_object);
gpointer vala_value_get_code_context (const GValue* value);
GType vala_code_context_get_type (void) G_GNUC_CONST;
static GType vala_parser_token_info_get_type (void) G_GNUC_CONST G_GNUC_UNUSED;
GType vala_token_type_get_type (void) G_GNUC_CONST;
GType vala_source_location_get_type (void) G_GNUC_CONST;
ValaSourceLocation* vala_source_location_dup (const ValaSourceLocation* self);
void vala_source_location_free (ValaSourceLocation* self);
static ValaParserTokenInfo* vala_parser_token_info_dup (const ValaParserTokenInfo* self);
static void vala_parser_token_info_free (ValaParserTokenInfo* self);
gpointer vala_comment_ref (gpointer instance);
void vala_comment_unref (gpointer instance);
GParamSpec* vala_param_spec_comment (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_comment (GValue* value, gpointer v_object);
void vala_value_take_comment (GValue* value, gpointer v_object);
gpointer vala_value_get_comment (const GValue* value);
GType vala_comment_get_type (void) G_GNUC_CONST;
#define VALA_PARSER_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), VALA_TYPE_PARSER, ValaParserPrivate))
enum  {
	VALA_PARSER_DUMMY_PROPERTY
};
static GType vala_parser_modifier_flags_get_type (void) G_GNUC_UNUSED;
static GType vala_parser_recovery_state_get_type (void) G_GNUC_UNUSED;
#define VALA_PARSER_BUFFER_SIZE 32
ValaParser* vala_parser_new (void);
ValaParser* vala_parser_construct (GType object_type);
ValaCodeVisitor* vala_code_visitor_construct (GType object_type);
void vala_parser_parse (ValaParser* self, ValaCodeContext* context);
void vala_code_context_accept (ValaCodeContext* self, ValaCodeVisitor* visitor);
static void vala_parser_real_visit_source_file (ValaCodeVisitor* base, ValaSourceFile* source_file);
gboolean vala_code_context_get_run_output (ValaCodeContext* self);
const char* vala_source_file_get_filename (ValaSourceFile* self);
void vala_parser_parse_file (ValaParser* self, ValaSourceFile* source_file);
static inline gboolean vala_parser_next (ValaParser* self);
ValaTokenType vala_scanner_read_token (ValaScanner* self, ValaSourceLocation* token_begin, ValaSourceLocation* token_end);
static inline void vala_parser_prev (ValaParser* self);
static inline ValaTokenType vala_parser_current (ValaParser* self);
static inline gboolean vala_parser_accept (ValaParser* self, ValaTokenType type);
static char* vala_parser_get_error (ValaParser* self, const char* msg);
static inline void vala_parser_get_location (ValaParser* self, ValaSourceLocation* result);
gpointer vala_source_reference_ref (gpointer instance);
void vala_source_reference_unref (gpointer instance);
GParamSpec* vala_param_spec_source_reference (const gchar* name, const gchar* nick, const gchar* blurb, GType object_type, GParamFlags flags);
void vala_value_set_source_reference (GValue* value, gpointer v_object);
void vala_value_take_source_reference (GValue* value, gpointer v_object);
gpointer vala_value_get_source_reference (const GValue* value);
GType vala_source_reference_get_type (void) G_GNUC_CONST;
void vala_report_error (ValaSourceReference* source, const char* message);
static ValaSourceReference* vala_parser_get_src (ValaParser* self, ValaSourceLocation* begin);
GQuark vala_parse_error_quark (void);
static inline gboolean vala_parser_expect (ValaParser* self, ValaTokenType type, GError** error);
const char* vala_token_type_to_string (ValaTokenType self);
static char* vala_parser_get_current_string (ValaParser* self);
static char* vala_parser_get_last_string (ValaParser* self);
ValaSourceFile* vala_scanner_get_source_file (ValaScanner* self);
ValaSourceReference* vala_source_reference_new (ValaSourceFile* _file, gint _first_line, gint _first_column, gint _last_line, gint _last_column);
ValaSourceReference* vala_source_reference_construct (GType object_type, ValaSourceFile* _file, gint _first_line, gint _first_column, gint _last_line, gint _last_column);
static ValaSourceReference* vala_parser_get_current_src (ValaParser* self);
static ValaSourceReference* vala_parser_get_last_src (ValaParser* self);
static void vala_parser_rollback (ValaParser* self, ValaSourceLocation* location);
void vala_scanner_seek (ValaScanner* self, ValaSourceLocation* location);
static void vala_parser_skip_identifier (ValaParser* self, GError** error);
static char* vala_parser_parse_identifier (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_literal (ValaParser* self, GError** error);
ValaBooleanLiteral* vala_boolean_literal_new (gboolean b, ValaSourceReference* source);
ValaBooleanLiteral* vala_boolean_literal_construct (GType object_type, gboolean b, ValaSourceReference* source);
ValaIntegerLiteral* vala_integer_literal_new (const char* i, ValaSourceReference* source);
ValaIntegerLiteral* vala_integer_literal_construct (GType object_type, const char* i, ValaSourceReference* source);
ValaRealLiteral* vala_real_literal_new (const char* r, ValaSourceReference* source);
ValaRealLiteral* vala_real_literal_construct (GType object_type, const char* r, ValaSourceReference* source);
ValaCharacterLiteral* vala_character_literal_new (const char* c, ValaSourceReference* source);
ValaCharacterLiteral* vala_character_literal_construct (GType object_type, const char* c, ValaSourceReference* source);
gboolean vala_code_node_get_error (ValaCodeNode* self);
ValaSourceReference* vala_code_node_get_source_reference (ValaCodeNode* self);
ValaRegexLiteral* vala_regex_literal_new (const char* value, ValaSourceReference* source_reference);
ValaRegexLiteral* vala_regex_literal_construct (GType object_type, const char* value, ValaSourceReference* source_reference);
ValaStringLiteral* vala_string_literal_new (const char* value, ValaSourceReference* source_reference);
ValaStringLiteral* vala_string_literal_construct (GType object_type, const char* value, ValaSourceReference* source_reference);
ValaNullLiteral* vala_null_literal_new (ValaSourceReference* source);
ValaNullLiteral* vala_null_literal_construct (GType object_type, ValaSourceReference* source);
ValaScanner* vala_scanner_new (ValaSourceFile* source_file);
ValaScanner* vala_scanner_construct (GType object_type, ValaSourceFile* source_file);
static void vala_parser_parse_file_comments (ValaParser* self);
static void vala_parser_parse_using_directives (ValaParser* self, ValaNamespace* ns, GError** error);
ValaNamespace* vala_code_context_get_root (ValaCodeContext* self);
static void vala_parser_parse_declarations (ValaParser* self, ValaSymbol* parent, gboolean root, GError** error);
GType vala_report_get_type (void) G_GNUC_CONST;
ValaReport* vala_code_context_get_report (ValaCodeContext* self);
gint vala_report_get_errors (ValaReport* self);
void vala_scanner_parse_file_comments (ValaScanner* self);
static void vala_parser_skip_symbol_name (ValaParser* self, GError** error);
GType vala_unresolved_symbol_get_type (void) G_GNUC_CONST;
static ValaUnresolvedSymbol* vala_parser_parse_symbol_name (ValaParser* self, GError** error);
ValaUnresolvedSymbol* vala_unresolved_symbol_new (ValaUnresolvedSymbol* inner, const char* name, ValaSourceReference* source_reference);
ValaUnresolvedSymbol* vala_unresolved_symbol_construct (GType object_type, ValaUnresolvedSymbol* inner, const char* name, ValaSourceReference* source_reference);
void vala_unresolved_symbol_set_qualified (ValaUnresolvedSymbol* self, gboolean value);
static void vala_parser_skip_type (ValaParser* self, GError** error);
static void vala_parser_skip_type_argument_list (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_expression (ValaParser* self, GError** error);
static ValaDataType* vala_parser_parse_type (ValaParser* self, gboolean owned_by_default, gboolean can_weak_ref, GError** error);
ValaVoidType* vala_void_type_new (ValaSourceReference* source_reference);
ValaVoidType* vala_void_type_construct (GType object_type, ValaSourceReference* source_reference);
GType vala_void_type_get_type (void) G_GNUC_CONST;
ValaPointerType* vala_pointer_type_new (ValaDataType* base_type, ValaSourceReference* source_reference);
ValaPointerType* vala_pointer_type_construct (GType object_type, ValaDataType* base_type, ValaSourceReference* source_reference);
GType vala_pointer_type_get_type (void) G_GNUC_CONST;
GType vala_profile_get_type (void) G_GNUC_CONST;
ValaProfile vala_code_context_get_profile (ValaCodeContext* self);
gboolean vala_code_context_get_deprecated (ValaCodeContext* self);
void vala_report_warning (ValaSourceReference* source, const char* message);
static ValaList* vala_parser_parse_type_argument_list (ValaParser* self, gboolean maybe_expression, GError** error);
ValaUnresolvedType* vala_unresolved_type_new_from_symbol (ValaUnresolvedSymbol* symbol, ValaSourceReference* source);
ValaUnresolvedType* vala_unresolved_type_construct_from_symbol (GType object_type, ValaUnresolvedSymbol* symbol, ValaSourceReference* source);
GType vala_unresolved_type_get_type (void) G_GNUC_CONST;
void vala_data_type_add_type_argument (ValaDataType* self, ValaDataType* arg);
void vala_data_type_set_nullable (ValaDataType* self, gboolean value);
void vala_data_type_set_value_owned (ValaDataType* self, gboolean value);
ValaArrayType* vala_array_type_new (ValaDataType* element_type, gint rank, ValaSourceReference* source_reference);
ValaArrayType* vala_array_type_construct (GType object_type, ValaDataType* element_type, gint rank, ValaSourceReference* source_reference);
GType vala_reference_type_get_type (void) G_GNUC_CONST;
GType vala_array_type_get_type (void) G_GNUC_CONST;
void vala_array_type_set_invalid_syntax (ValaArrayType* self, gboolean value);
void vala_data_type_set_is_dynamic (ValaDataType* self, gboolean value);
static ValaDataType* vala_parser_parse_inline_array_type (ValaParser* self, ValaDataType* type, GError** error);
const char* vala_integer_literal_get_value (ValaIntegerLiteral* self);
void vala_array_type_set_inline_allocated (ValaArrayType* self, gboolean value);
void vala_array_type_set_fixed_length (ValaArrayType* self, gboolean value);
void vala_array_type_set_length (ValaArrayType* self, gint value);
gboolean vala_data_type_get_value_owned (ValaDataType* self);
static ValaList* vala_parser_parse_argument_list (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_argument (ValaParser* self, GError** error);
GType vala_unary_operator_get_type (void) G_GNUC_CONST;
ValaUnaryExpression* vala_unary_expression_new (ValaUnaryOperator op, ValaExpression* _inner, ValaSourceReference* source);
ValaUnaryExpression* vala_unary_expression_construct (GType object_type, ValaUnaryOperator op, ValaExpression* _inner, ValaSourceReference* source);
ValaExpression* vala_member_access_get_inner (ValaMemberAccess* self);
const char* vala_member_access_get_member_name (ValaMemberAccess* self);
ValaNamedArgument* vala_named_argument_new (const char* name, ValaExpression* inner, ValaSourceReference* source_reference);
ValaNamedArgument* vala_named_argument_construct (GType object_type, const char* name, ValaExpression* inner, ValaSourceReference* source_reference);
static ValaExpression* vala_parser_parse_primary_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_set_literal (ValaParser* self, GError** error);
static ValaInitializerList* vala_parser_parse_initializer (ValaParser* self, GError** error);
static ValaListLiteral* vala_parser_parse_list_literal (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_simple_name (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_tuple (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_template (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_regex_literal (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_this_access (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_base_access (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_object_or_array_creation_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_yield_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_sizeof_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_typeof_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_member_access (ValaParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_parser_parse_pointer_member_access (ValaParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_parser_parse_method_call (ValaParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_parser_parse_element_access (ValaParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_parser_parse_object_literal (ValaParser* self, ValaSourceLocation* begin, ValaMemberAccess* member, GError** error);
static ValaExpression* vala_parser_parse_post_increment_expression (ValaParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
static ValaExpression* vala_parser_parse_post_decrement_expression (ValaParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error);
ValaMemberAccess* vala_member_access_new (ValaExpression* inner, const char* member_name, ValaSourceReference* source_reference);
ValaMemberAccess* vala_member_access_construct (GType object_type, ValaExpression* inner, const char* member_name, ValaSourceReference* source_reference);
void vala_member_access_set_qualified (ValaMemberAccess* self, gboolean value);
void vala_member_access_add_type_argument (ValaMemberAccess* self, ValaDataType* arg);
ValaTuple* vala_tuple_new (ValaSourceReference* source_reference);
ValaTuple* vala_tuple_construct (GType object_type, ValaSourceReference* source_reference);
void vala_tuple_add_expression (ValaTuple* self, ValaExpression* expr);
ValaTemplate* vala_template_new (ValaSourceReference* source_reference);
ValaTemplate* vala_template_construct (GType object_type, ValaSourceReference* source_reference);
void vala_template_add_expression (ValaTemplate* self, ValaExpression* expr);
void vala_code_node_set_source_reference (ValaCodeNode* self, ValaSourceReference* value);
ValaMemberAccess* vala_member_access_new_pointer (ValaExpression* inner, const char* member_name, ValaSourceReference* source_reference);
ValaMemberAccess* vala_member_access_construct_pointer (GType object_type, ValaExpression* inner, const char* member_name, ValaSourceReference* source_reference);
GType vala_member_initializer_get_type (void) G_GNUC_CONST;
static ValaList* vala_parser_parse_object_initializer (ValaParser* self, GError** error);
void vala_member_access_set_creation_member (ValaMemberAccess* self, gboolean value);
ValaObjectCreationExpression* vala_object_creation_expression_new (ValaMemberAccess* member_name, ValaSourceReference* source_reference);
ValaObjectCreationExpression* vala_object_creation_expression_construct (GType object_type, ValaMemberAccess* member_name, ValaSourceReference* source_reference);
void vala_object_creation_expression_set_struct_creation (ValaObjectCreationExpression* self, gboolean value);
void vala_object_creation_expression_add_argument (ValaObjectCreationExpression* self, ValaExpression* arg);
void vala_object_creation_expression_add_member_initializer (ValaObjectCreationExpression* self, ValaMemberInitializer* init);
ValaMethodCall* vala_method_call_new (ValaExpression* call, ValaSourceReference* source_reference);
ValaMethodCall* vala_method_call_construct (GType object_type, ValaExpression* call, ValaSourceReference* source_reference);
void vala_method_call_add_argument (ValaMethodCall* self, ValaExpression* arg);
static ValaList* vala_parser_parse_expression_list (ValaParser* self, GError** error);
ValaElementAccess* vala_element_access_new (ValaExpression* container, ValaSourceReference* source_reference);
ValaElementAccess* vala_element_access_construct (GType object_type, ValaExpression* container, ValaSourceReference* source_reference);
void vala_element_access_append_index (ValaElementAccess* self, ValaExpression* index);
ValaSliceExpression* vala_slice_expression_new (ValaExpression* container, ValaExpression* start, ValaExpression* stop, ValaSourceReference* source_reference);
ValaSliceExpression* vala_slice_expression_construct (GType object_type, ValaExpression* container, ValaExpression* start, ValaExpression* stop, ValaSourceReference* source_reference);
ValaBaseAccess* vala_base_access_new (ValaSourceReference* source);
ValaBaseAccess* vala_base_access_construct (GType object_type, ValaSourceReference* source);
ValaPostfixExpression* vala_postfix_expression_new (ValaExpression* _inner, gboolean inc, ValaSourceReference* source);
ValaPostfixExpression* vala_postfix_expression_construct (GType object_type, ValaExpression* _inner, gboolean inc, ValaSourceReference* source);
static ValaMemberAccess* vala_parser_parse_member_name (ValaParser* self, ValaExpression* base_expr, GError** error);
static ValaExpression* vala_parser_parse_object_creation_expression (ValaParser* self, ValaSourceLocation* begin, ValaMemberAccess* member, GError** error);
static ValaExpression* vala_parser_parse_array_creation_expression (ValaParser* self, ValaSourceLocation* begin, ValaMemberAccess* member, GError** error);
ValaMemberInitializer* vala_member_initializer_new (const char* name, ValaExpression* initializer, ValaSourceReference* source_reference);
ValaMemberInitializer* vala_member_initializer_construct (GType object_type, const char* name, ValaExpression* initializer, ValaSourceReference* source_reference);
ValaUnresolvedType* vala_unresolved_type_new_from_expression (ValaExpression* expr);
ValaArrayCreationExpression* vala_array_creation_expression_new (ValaDataType* element_type, gint rank, ValaInitializerList* initializer_list, ValaSourceReference* source_reference);
ValaArrayCreationExpression* vala_array_creation_expression_construct (GType object_type, ValaDataType* element_type, gint rank, ValaInitializerList* initializer_list, ValaSourceReference* source_reference);
void vala_array_creation_expression_append_size (ValaArrayCreationExpression* self, ValaExpression* size);
static ValaMemberInitializer* vala_parser_parse_member_initializer (ValaParser* self, GError** error);
void vala_method_call_set_is_yield_expression (ValaMethodCall* self, gboolean value);
ValaSizeofExpression* vala_sizeof_expression_new (ValaDataType* type, ValaSourceReference* source);
ValaSizeofExpression* vala_sizeof_expression_construct (GType object_type, ValaDataType* type, ValaSourceReference* source);
ValaTypeofExpression* vala_typeof_expression_new (ValaDataType* type, ValaSourceReference* source);
ValaTypeofExpression* vala_typeof_expression_construct (GType object_type, ValaDataType* type, ValaSourceReference* source);
static ValaUnaryOperator vala_parser_get_unary_operator (ValaParser* self, ValaTokenType token_type);
static ValaExpression* vala_parser_parse_unary_expression (ValaParser* self, GError** error);
ValaReferenceTransferExpression* vala_reference_transfer_expression_new (ValaExpression* inner, ValaSourceReference* source_reference);
ValaReferenceTransferExpression* vala_reference_transfer_expression_construct (GType object_type, ValaExpression* inner, ValaSourceReference* source_reference);
ValaCastExpression* vala_cast_expression_new (ValaExpression* inner, ValaDataType* type_reference, ValaSourceReference* source_reference, gboolean is_silent_cast);
ValaCastExpression* vala_cast_expression_construct (GType object_type, ValaExpression* inner, ValaDataType* type_reference, ValaSourceReference* source_reference, gboolean is_silent_cast);
ValaCastExpression* vala_cast_expression_new_non_null (ValaExpression* inner, ValaSourceReference* source_reference);
ValaCastExpression* vala_cast_expression_construct_non_null (GType object_type, ValaExpression* inner, ValaSourceReference* source_reference);
ValaPointerIndirection* vala_pointer_indirection_new (ValaExpression* inner, ValaSourceReference* source_reference);
ValaPointerIndirection* vala_pointer_indirection_construct (GType object_type, ValaExpression* inner, ValaSourceReference* source_reference);
ValaAddressofExpression* vala_addressof_expression_new (ValaExpression* inner, ValaSourceReference* source_reference);
ValaAddressofExpression* vala_addressof_expression_construct (GType object_type, ValaExpression* inner, ValaSourceReference* source_reference);
GType vala_binary_operator_get_type (void) G_GNUC_CONST;
static ValaBinaryOperator vala_parser_get_binary_operator (ValaParser* self, ValaTokenType token_type);
static ValaExpression* vala_parser_parse_multiplicative_expression (ValaParser* self, GError** error);
ValaBinaryExpression* vala_binary_expression_new (ValaBinaryOperator op, ValaExpression* _left, ValaExpression* _right, ValaSourceReference* source);
ValaBinaryExpression* vala_binary_expression_construct (GType object_type, ValaBinaryOperator op, ValaExpression* _left, ValaExpression* _right, ValaSourceReference* source);
static ValaExpression* vala_parser_parse_additive_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_shift_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_relational_expression (ValaParser* self, GError** error);
GType vala_semantic_analyzer_get_type (void) G_GNUC_CONST;
GType vala_code_generator_get_type (void) G_GNUC_CONST;
GType vala_attribute_get_type (void) G_GNUC_CONST;
gboolean vala_code_context_get_experimental (ValaCodeContext* self);
ValaTypeCheck* vala_typecheck_new (ValaExpression* expr, ValaDataType* type, ValaSourceReference* source);
ValaTypeCheck* vala_typecheck_construct (GType object_type, ValaExpression* expr, ValaDataType* type, ValaSourceReference* source);
static ValaExpression* vala_parser_parse_equality_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_and_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_exclusive_or_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_inclusive_or_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_in_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_conditional_and_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_conditional_or_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_coalescing_expression (ValaParser* self, GError** error);
static ValaExpression* vala_parser_parse_conditional_expression (ValaParser* self, GError** error);
ValaConditionalExpression* vala_conditional_expression_new (ValaExpression* cond, ValaExpression* true_expr, ValaExpression* false_expr, ValaSourceReference* source);
ValaConditionalExpression* vala_conditional_expression_construct (GType object_type, ValaExpression* cond, ValaExpression* true_expr, ValaExpression* false_expr, ValaSourceReference* source);
static ValaExpression* vala_parser_parse_lambda_expression (ValaParser* self, GError** error);
static ValaBlock* vala_parser_parse_block (ValaParser* self, GError** error);
ValaLambdaExpression* vala_lambda_expression_new_with_statement_body (ValaBlock* statement_body, ValaSourceReference* source_reference);
ValaLambdaExpression* vala_lambda_expression_construct_with_statement_body (GType object_type, ValaBlock* statement_body, ValaSourceReference* source_reference);
ValaLambdaExpression* vala_lambda_expression_new (ValaExpression* expression_body, ValaSourceReference* source_reference);
ValaLambdaExpression* vala_lambda_expression_construct (GType object_type, ValaExpression* expression_body, ValaSourceReference* source_reference);
void vala_lambda_expression_add_parameter (ValaLambdaExpression* self, const char* param);
GType vala_assignment_operator_get_type (void) G_GNUC_CONST;
static ValaAssignmentOperator vala_parser_get_assignment_operator (ValaParser* self, ValaTokenType token_type);
ValaAssignment* vala_assignment_new (ValaExpression* left, ValaExpression* right, ValaAssignmentOperator operator, ValaSourceReference* source_reference);
ValaAssignment* vala_assignment_construct (GType object_type, ValaExpression* left, ValaExpression* right, ValaAssignmentOperator operator, ValaSourceReference* source_reference);
static void vala_parser_parse_statements (ValaParser* self, ValaBlock* block, GError** error);
GType vala_statement_get_type (void) G_GNUC_CONST;
ValaComment* vala_scanner_pop_comment (ValaScanner* self);
static ValaStatement* vala_parser_parse_empty_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_if_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_switch_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_while_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_do_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_for_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_foreach_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_break_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_continue_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_return_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_yield_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_throw_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_try_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_lock_statement (ValaParser* self, GError** error);
static ValaStatement* vala_parser_parse_delete_statement (ValaParser* self, GError** error);
static void vala_parser_parse_local_variable_declarations (ValaParser* self, ValaBlock* block, GError** error);
static ValaStatement* vala_parser_parse_expression_statement (ValaParser* self, GError** error);
static gboolean vala_parser_is_expression (ValaParser* self, GError** error);
ValaExpression* vala_return_statement_get_return_expression (ValaReturnStatement* self);
ValaMemberAccess* vala_member_access_new_simple (const char* member_name, ValaSourceReference* source_reference);
ValaMemberAccess* vala_member_access_construct_simple (GType object_type, const char* member_name, ValaSourceReference* source_reference);
void vala_return_statement_set_return_expression (ValaReturnStatement* self, ValaExpression* value);
void vala_block_add_statement (ValaBlock* self, ValaStatement* stmt);
ValaExpressionStatement* vala_expression_statement_new (ValaExpression* expression, ValaSourceReference* source_reference);
ValaExpressionStatement* vala_expression_statement_construct (GType object_type, ValaExpression* expression, ValaSourceReference* source_reference);
static ValaParserRecoveryState vala_parser_recover (ValaParser* self);
static ValaBlock* vala_parser_parse_embedded_statement (ValaParser* self, GError** error);
ValaBlock* vala_block_new (ValaSourceReference* source_reference);
ValaBlock* vala_block_construct (GType object_type, ValaSourceReference* source_reference);
static ValaStatement* vala_parser_parse_embedded_statement_without_block (ValaParser* self, GError** error);
gint vala_source_reference_get_last_line (ValaSourceReference* self);
void vala_source_reference_set_last_line (ValaSourceReference* self, gint value);
gint vala_source_reference_get_last_column (ValaSourceReference* self);
void vala_source_reference_set_last_column (ValaSourceReference* self, gint value);
ValaEmptyStatement* vala_empty_statement_new (ValaSourceReference* source);
ValaEmptyStatement* vala_empty_statement_construct (GType object_type, ValaSourceReference* source);
static void _vala_array_add13 (char*** array, int* length, int* size, char* value);
char* vala_code_node_get_temp_name (void);
ValaLocalVariable* vala_local_variable_new (ValaDataType* variable_type, const char* name, ValaExpression* initializer, ValaSourceReference* source_reference);
ValaLocalVariable* vala_local_variable_construct (GType object_type, ValaDataType* variable_type, const char* name, ValaExpression* initializer, ValaSourceReference* source_reference);
ValaDeclarationStatement* vala_declaration_statement_new (ValaSymbol* declaration, ValaSourceReference* source_reference);
ValaDeclarationStatement* vala_declaration_statement_construct (GType object_type, ValaSymbol* declaration, ValaSourceReference* source_reference);
const char* vala_symbol_get_name (ValaSymbol* self);
ValaDataType* vala_data_type_copy (ValaDataType* self);
static ValaLocalVariable* vala_parser_parse_local_variable (ValaParser* self, ValaDataType* variable_type, GError** error);
static ValaExpression* vala_parser_parse_statement_expression (ValaParser* self, GError** error);
ValaIfStatement* vala_if_statement_new (ValaExpression* cond, ValaBlock* true_stmt, ValaBlock* false_stmt, ValaSourceReference* source);
ValaIfStatement* vala_if_statement_construct (GType object_type, ValaExpression* cond, ValaBlock* true_stmt, ValaBlock* false_stmt, ValaSourceReference* source);
ValaSwitchStatement* vala_switch_statement_new (ValaExpression* expression, ValaSourceReference* source_reference);
ValaSwitchStatement* vala_switch_statement_construct (GType object_type, ValaExpression* expression, ValaSourceReference* source_reference);
ValaSwitchSection* vala_switch_section_new (ValaSourceReference* source_reference);
ValaSwitchSection* vala_switch_section_construct (GType object_type, ValaSourceReference* source_reference);
void vala_switch_section_add_label (ValaSwitchSection* self, ValaSwitchLabel* label);
ValaSwitchLabel* vala_switch_label_new (ValaExpression* expr, ValaSourceReference* source);
ValaSwitchLabel* vala_switch_label_construct (GType object_type, ValaExpression* expr, ValaSourceReference* source);
ValaSwitchLabel* vala_switch_label_new_with_default (ValaSourceReference* source);
ValaSwitchLabel* vala_switch_label_construct_with_default (GType object_type, ValaSourceReference* source);
void vala_switch_statement_add_section (ValaSwitchStatement* self, ValaSwitchSection* section);
ValaWhileStatement* vala_while_statement_new (ValaExpression* condition, ValaBlock* body, ValaSourceReference* source_reference);
ValaWhileStatement* vala_while_statement_construct (GType object_type, ValaExpression* condition, ValaBlock* body, ValaSourceReference* source_reference);
ValaDoStatement* vala_do_statement_new (ValaBlock* body, ValaExpression* condition, ValaSourceReference* source_reference);
ValaDoStatement* vala_do_statement_construct (GType object_type, ValaBlock* body, ValaExpression* condition, ValaSourceReference* source_reference);
ValaForStatement* vala_for_statement_new (ValaExpression* condition, ValaBlock* body, ValaSourceReference* source_reference);
ValaForStatement* vala_for_statement_construct (GType object_type, ValaExpression* condition, ValaBlock* body, ValaSourceReference* source_reference);
void vala_for_statement_add_initializer (ValaForStatement* self, ValaExpression* init);
void vala_for_statement_add_iterator (ValaForStatement* self, ValaExpression* iter);
ValaForeachStatement* vala_foreach_statement_new (ValaDataType* type_reference, const char* variable_name, ValaExpression* collection, ValaBlock* body, ValaSourceReference* source_reference);
ValaForeachStatement* vala_foreach_statement_construct (GType object_type, ValaDataType* type_reference, const char* variable_name, ValaExpression* collection, ValaBlock* body, ValaSourceReference* source_reference);
ValaBreakStatement* vala_break_statement_new (ValaSourceReference* source);
ValaBreakStatement* vala_break_statement_construct (GType object_type, ValaSourceReference* source);
ValaContinueStatement* vala_continue_statement_new (ValaSourceReference* source);
ValaContinueStatement* vala_continue_statement_construct (GType object_type, ValaSourceReference* source);
ValaReturnStatement* vala_return_statement_new (ValaExpression* return_expression, ValaSourceReference* source_reference);
ValaReturnStatement* vala_return_statement_construct (GType object_type, ValaExpression* return_expression, ValaSourceReference* source_reference);
ValaYieldStatement* vala_yield_statement_new (ValaExpression* yield_expression, ValaSourceReference* source_reference);
ValaYieldStatement* vala_yield_statement_construct (GType object_type, ValaExpression* yield_expression, ValaSourceReference* source_reference);
ValaThrowStatement* vala_throw_statement_new (ValaExpression* error_expression, ValaSourceReference* source_reference);
ValaThrowStatement* vala_throw_statement_construct (GType object_type, ValaExpression* error_expression, ValaSourceReference* source_reference);
static void vala_parser_parse_catch_clauses (ValaParser* self, ValaList* catch_clauses, GError** error);
static ValaBlock* vala_parser_parse_finally_clause (ValaParser* self, GError** error);
ValaTryStatement* vala_try_statement_new (ValaBlock* body, ValaBlock* finally_body, ValaSourceReference* source_reference);
ValaTryStatement* vala_try_statement_construct (GType object_type, ValaBlock* body, ValaBlock* finally_body, ValaSourceReference* source_reference);
void vala_try_statement_add_catch_clause (ValaTryStatement* self, ValaCatchClause* clause);
ValaCatchClause* vala_catch_clause_new (ValaDataType* error_type, const char* variable_name, ValaBlock* body, ValaSourceReference* source_reference);
ValaCatchClause* vala_catch_clause_construct (GType object_type, ValaDataType* error_type, const char* variable_name, ValaBlock* body, ValaSourceReference* source_reference);
ValaLockStatement* vala_lock_statement_new (ValaExpression* resource, ValaBlock* body, ValaSourceReference* source_reference);
ValaLockStatement* vala_lock_statement_construct (GType object_type, ValaExpression* resource, ValaBlock* body, ValaSourceReference* source_reference);
ValaDeleteStatement* vala_delete_statement_new (ValaExpression* expression, ValaSourceReference* source_reference);
ValaDeleteStatement* vala_delete_statement_construct (GType object_type, ValaExpression* expression, ValaSourceReference* source_reference);
static ValaList* vala_parser_parse_attributes (ValaParser* self, GError** error);
ValaAttribute* vala_attribute_new (const char* name, ValaSourceReference* source_reference);
ValaAttribute* vala_attribute_construct (GType object_type, const char* name, ValaSourceReference* source_reference);
void vala_attribute_add_argument (ValaAttribute* self, const char* key, ValaExpression* value);
static void vala_parser_set_attributes (ValaParser* self, ValaCodeNode* node, ValaList* attributes);
static ValaMethod* vala_parser_parse_main_block (ValaParser* self, GError** error);
ValaMethod* vala_method_new (const char* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
ValaMethod* vala_method_construct (GType object_type, const char* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
void vala_method_set_body (ValaMethod* self, ValaBlock* value);
ValaBlock* vala_method_get_body (ValaMethod* self);
static ValaSymbol* vala_parser_parse_declaration (ValaParser* self, gboolean root, GError** error);
static gboolean vala_parser_is_declaration_keyword (ValaParser* self, ValaTokenType type);
static ValaConstructor* vala_parser_parse_constructor_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaDestructor* vala_parser_parse_destructor_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_parser_parse_class_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_parser_parse_enum_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_parser_parse_errordomain_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_parser_parse_interface_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaNamespace* vala_parser_parse_namespace_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_parser_parse_struct_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaCreationMethod* vala_parser_parse_creation_method_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaSymbol* vala_parser_parse_delegate_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaSignal* vala_parser_parse_signal_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaMethod* vala_parser_parse_method_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaConstant* vala_parser_parse_constant_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaField* vala_parser_parse_field_declaration (ValaParser* self, ValaList* attrs, GError** error);
static ValaProperty* vala_parser_parse_property_declaration (ValaParser* self, ValaList* attrs, GError** error);
static void vala_parser_parse_namespace_member (ValaParser* self, ValaNamespace* ns, gboolean root, GError** error);
static void vala_parser_parse_class_member (ValaParser* self, ValaClass* cl, GError** error);
static void vala_parser_parse_struct_member (ValaParser* self, ValaStruct* st, GError** error);
static void vala_parser_parse_interface_member (ValaParser* self, ValaInterface* iface, GError** error);
ValaNamespace* vala_namespace_new (const char* name, ValaSourceReference* source_reference);
ValaNamespace* vala_namespace_construct (GType object_type, const char* name, ValaSourceReference* source_reference);
void vala_namespace_add_comment (ValaNamespace* self, ValaComment* comment);
ValaList* vala_source_file_get_current_using_directives (ValaSourceFile* self);
void vala_source_file_set_current_using_directives (ValaSourceFile* self, ValaList* value);
ValaUnresolvedSymbol* vala_unresolved_symbol_get_inner (ValaUnresolvedSymbol* self);
void vala_namespace_add_namespace (ValaNamespace* self, ValaNamespace* ns);
void vala_namespace_add_class (ValaNamespace* self, ValaClass* cl);
void vala_namespace_add_interface (ValaNamespace* self, ValaInterface* iface);
void vala_namespace_add_struct (ValaNamespace* self, ValaStruct* st);
void vala_namespace_add_enum (ValaNamespace* self, ValaEnum* en);
void vala_namespace_add_error_domain (ValaNamespace* self, ValaErrorDomain* edomain);
void vala_namespace_add_delegate (ValaNamespace* self, ValaDelegate* d);
GType member_binding_get_type (void) G_GNUC_CONST;
MemberBinding vala_method_get_binding (ValaMethod* self);
void vala_method_set_binding (ValaMethod* self, MemberBinding value);
void vala_namespace_add_method (ValaNamespace* self, ValaMethod* m);
MemberBinding vala_field_get_binding (ValaField* self);
void vala_field_set_binding (ValaField* self, MemberBinding value);
void vala_namespace_add_field (ValaNamespace* self, ValaField* f);
void vala_namespace_add_constant (ValaNamespace* self, ValaConstant* constant);
void vala_source_file_add_node (ValaSourceFile* self, ValaCodeNode* node);
ValaUsingDirective* vala_using_directive_new (ValaSymbol* namespace_symbol, ValaSourceReference* source_reference);
ValaUsingDirective* vala_using_directive_construct (GType object_type, ValaSymbol* namespace_symbol, ValaSourceReference* source_reference);
void vala_source_file_add_using_directive (ValaSourceFile* self, ValaUsingDirective* ns);
void vala_namespace_add_using_directive (ValaNamespace* self, ValaUsingDirective* ns);
GType vala_symbol_accessibility_get_type (void) G_GNUC_CONST;
static ValaSymbolAccessibility vala_parser_parse_access_modifier (ValaParser* self, ValaSymbolAccessibility default_access);
static ValaParserModifierFlags vala_parser_parse_type_declaration_modifiers (ValaParser* self);
static ValaList* vala_parser_parse_type_parameter_list (ValaParser* self, GError** error);
ValaClass* vala_class_new (const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaClass* vala_class_construct (GType object_type, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_symbol_set_access (ValaSymbol* self, ValaSymbolAccessibility value);
void vala_class_set_is_abstract (ValaClass* self, gboolean value);
gboolean vala_source_file_get_external_package (ValaSourceFile* self);
void vala_symbol_set_external (ValaSymbol* self, gboolean value);
void vala_object_type_symbol_add_type_parameter (ValaObjectTypeSymbol* self, ValaTypeParameter* p);
void vala_class_add_base_type (ValaClass* self, ValaDataType* type);
ValaMethod* vala_class_get_default_construction_method (ValaClass* self);
ValaCreationMethod* vala_creation_method_new (const char* class_name, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaCreationMethod* vala_creation_method_construct (GType object_type, const char* class_name, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_class_add_method (ValaClass* self, ValaMethod* m);
void vala_class_add_class (ValaClass* self, ValaClass* cl);
void vala_class_add_struct (ValaClass* self, ValaStruct* st);
void vala_class_add_enum (ValaClass* self, ValaEnum* en);
void vala_class_add_delegate (ValaClass* self, ValaDelegate* d);
void vala_class_add_signal (ValaClass* self, ValaSignal* sig);
void vala_class_add_field (ValaClass* self, ValaField* f);
void vala_class_add_constant (ValaClass* self, ValaConstant* c);
void vala_class_add_property (ValaClass* self, ValaProperty* prop);
MemberBinding vala_constructor_get_binding (ValaConstructor* self);
ValaConstructor* vala_class_get_constructor (ValaClass* self);
void vala_class_set_constructor (ValaClass* self, ValaConstructor* value);
ValaConstructor* vala_class_get_class_constructor (ValaClass* self);
void vala_class_set_class_constructor (ValaClass* self, ValaConstructor* value);
ValaConstructor* vala_class_get_static_constructor (ValaClass* self);
void vala_class_set_static_constructor (ValaClass* self, ValaConstructor* value);
MemberBinding vala_destructor_get_binding (ValaDestructor* self);
ValaDestructor* vala_class_get_static_destructor (ValaClass* self);
void vala_class_set_static_destructor (ValaClass* self, ValaDestructor* value);
ValaDestructor* vala_class_get_class_destructor (ValaClass* self);
void vala_class_set_class_destructor (ValaClass* self, ValaDestructor* value);
ValaDestructor* vala_class_get_destructor (ValaClass* self);
void vala_class_set_destructor (ValaClass* self, ValaDestructor* value);
static ValaParserModifierFlags vala_parser_parse_member_declaration_modifiers (ValaParser* self);
ValaDataType* vala_array_type_get_element_type (ValaArrayType* self);
ValaConstant* vala_constant_new (const char* name, ValaDataType* type_reference, ValaExpression* value, ValaSourceReference* source_reference, ValaComment* comment);
ValaConstant* vala_constant_construct (GType object_type, const char* name, ValaDataType* type_reference, ValaExpression* value, ValaSourceReference* source_reference, ValaComment* comment);
void vala_symbol_set_hides (ValaSymbol* self, gboolean value);
ValaField* vala_field_new (const char* name, ValaDataType* variable_type, ValaExpression* initializer, ValaSourceReference* source_reference, ValaComment* comment);
ValaField* vala_field_construct (GType object_type, const char* name, ValaDataType* variable_type, ValaExpression* initializer, ValaSourceReference* source_reference, ValaComment* comment);
void vala_variable_set_initializer (ValaVariable* self, ValaExpression* value);
ValaInitializerList* vala_initializer_list_new (ValaSourceReference* source_reference);
ValaInitializerList* vala_initializer_list_construct (GType object_type, ValaSourceReference* source_reference);
void vala_initializer_list_append (ValaInitializerList* self, ValaExpression* expr);
ValaListLiteral* vala_list_literal_new (ValaSourceReference* source_reference);
ValaListLiteral* vala_list_literal_construct (GType object_type, ValaSourceReference* source_reference);
void vala_list_literal_add_expression (ValaListLiteral* self, ValaExpression* expr);
ValaSetLiteral* vala_set_literal_new (ValaSourceReference* source_reference);
ValaSetLiteral* vala_set_literal_construct (GType object_type, ValaSourceReference* source_reference);
static ValaExpression* vala_parser_parse_map_literal (ValaParser* self, GError** error);
void vala_set_literal_add_expression (ValaSetLiteral* self, ValaExpression* expr);
ValaMapLiteral* vala_map_literal_new (ValaSourceReference* source_reference);
ValaMapLiteral* vala_map_literal_construct (GType object_type, ValaSourceReference* source_reference);
void vala_map_literal_add_key (ValaMapLiteral* self, ValaExpression* expr);
void vala_map_literal_add_value (ValaMapLiteral* self, ValaExpression* expr);
void vala_method_add_type_parameter (ValaMethod* self, ValaTypeParameter* p);
void vala_method_set_coroutine (ValaMethod* self, gboolean value);
void vala_method_set_is_abstract (ValaMethod* self, gboolean value);
void vala_method_set_is_virtual (ValaMethod* self, gboolean value);
void vala_method_set_overrides (ValaMethod* self, gboolean value);
gboolean vala_method_get_is_abstract (ValaMethod* self);
gboolean vala_method_get_is_virtual (ValaMethod* self);
gboolean vala_method_get_overrides (ValaMethod* self);
void vala_method_set_is_inline (ValaMethod* self, gboolean value);
static ValaFormalParameter* vala_parser_parse_parameter (ValaParser* self, GError** error);
void vala_method_add_parameter (ValaMethod* self, ValaFormalParameter* param);
void vala_code_node_add_error_type (ValaCodeNode* self, ValaDataType* error_type);
void vala_method_add_precondition (ValaMethod* self, ValaExpression* precondition);
void vala_method_add_postcondition (ValaMethod* self, ValaExpression* postcondition);
ValaProperty* vala_property_new (const char* name, ValaDataType* property_type, ValaPropertyAccessor* get_accessor, ValaPropertyAccessor* set_accessor, ValaSourceReference* source_reference, ValaComment* comment);
ValaProperty* vala_property_construct (GType object_type, const char* name, ValaDataType* property_type, ValaPropertyAccessor* get_accessor, ValaPropertyAccessor* set_accessor, ValaSourceReference* source_reference, ValaComment* comment);
void vala_property_set_binding (ValaProperty* self, MemberBinding value);
void vala_property_set_is_abstract (ValaProperty* self, gboolean value);
void vala_property_set_is_virtual (ValaProperty* self, gboolean value);
void vala_property_set_overrides (ValaProperty* self, gboolean value);
ValaExpression* vala_property_get_initializer (ValaProperty* self);
void vala_property_set_initializer (ValaProperty* self, ValaExpression* value);
ValaPropertyAccessor* vala_property_get_get_accessor (ValaProperty* self);
ValaPropertyAccessor* vala_property_accessor_new (gboolean readable, gboolean writable, gboolean construction, ValaDataType* value_type, ValaBlock* body, ValaSourceReference* source_reference, ValaComment* comment);
ValaPropertyAccessor* vala_property_accessor_construct (GType object_type, gboolean readable, gboolean writable, gboolean construction, ValaDataType* value_type, ValaBlock* body, ValaSourceReference* source_reference, ValaComment* comment);
void vala_property_set_get_accessor (ValaProperty* self, ValaPropertyAccessor* value);
ValaPropertyAccessor* vala_property_get_set_accessor (ValaProperty* self);
void vala_property_set_set_accessor (ValaProperty* self, ValaPropertyAccessor* value);
gboolean vala_property_get_is_abstract (ValaProperty* self);
gboolean vala_symbol_get_external (ValaSymbol* self);
ValaBlock* vala_property_accessor_get_body (ValaPropertyAccessor* self);
void vala_code_node_set_error (ValaCodeNode* self, gboolean value);
ValaDataType* vala_property_get_property_type (ValaProperty* self);
void vala_property_set_field (ValaProperty* self, ValaField* value);
ValaField* vala_property_get_field (ValaProperty* self);
MemberBinding vala_property_get_binding (ValaProperty* self);
ValaSignal* vala_signal_new (const char* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
ValaSignal* vala_signal_construct (GType object_type, const char* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
void vala_signal_set_is_virtual (ValaSignal* self, gboolean value);
void vala_signal_add_parameter (ValaSignal* self, ValaFormalParameter* param);
void vala_signal_set_body (ValaSignal* self, ValaBlock* value);
ValaConstructor* vala_constructor_new (ValaSourceReference* source);
ValaConstructor* vala_constructor_construct (GType object_type, ValaSourceReference* source);
void vala_constructor_set_binding (ValaConstructor* self, MemberBinding value);
void vala_constructor_set_body (ValaConstructor* self, ValaBlock* value);
ValaDestructor* vala_destructor_new (ValaSourceReference* source_reference);
ValaDestructor* vala_destructor_construct (GType object_type, ValaSourceReference* source_reference);
void vala_destructor_set_binding (ValaDestructor* self, MemberBinding value);
void vala_destructor_set_body (ValaDestructor* self, ValaBlock* value);
ValaStruct* vala_struct_new (const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaStruct* vala_struct_construct (GType object_type, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_struct_add_type_parameter (ValaStruct* self, ValaTypeParameter* p);
void vala_struct_set_base_type (ValaStruct* self, ValaDataType* value);
void vala_struct_add_method (ValaStruct* self, ValaMethod* m);
void vala_struct_add_field (ValaStruct* self, ValaField* f);
void vala_struct_add_constant (ValaStruct* self, ValaConstant* c);
void vala_struct_add_property (ValaStruct* self, ValaProperty* prop);
ValaInterface* vala_interface_new (const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaInterface* vala_interface_construct (GType object_type, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_interface_add_prerequisite (ValaInterface* self, ValaDataType* type);
void vala_interface_add_class (ValaInterface* self, ValaClass* cl);
void vala_interface_add_struct (ValaInterface* self, ValaStruct* st);
void vala_interface_add_enum (ValaInterface* self, ValaEnum* en);
void vala_interface_add_delegate (ValaInterface* self, ValaDelegate* d);
void vala_interface_add_method (ValaInterface* self, ValaMethod* m);
void vala_interface_add_signal (ValaInterface* self, ValaSignal* sig);
void vala_interface_add_field (ValaInterface* self, ValaField* f);
void vala_interface_add_constant (ValaInterface* self, ValaConstant* c);
void vala_interface_add_property (ValaInterface* self, ValaProperty* prop);
ValaEnum* vala_enum_new (const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaEnum* vala_enum_construct (GType object_type, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaList* vala_enum_get_values (ValaEnum* self);
ValaEnumValue* vala_enum_value_new (const char* name, ValaExpression* value, ValaSourceReference* source_reference, ValaComment* comment);
ValaEnumValue* vala_enum_value_construct (GType object_type, const char* name, ValaExpression* value, ValaSourceReference* source_reference, ValaComment* comment);
void vala_enum_add_value (ValaEnum* self, ValaEnumValue* value);
void vala_enum_add_method (ValaEnum* self, ValaMethod* m);
void vala_enum_add_constant (ValaEnum* self, ValaConstant* c);
ValaErrorDomain* vala_error_domain_new (const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaErrorDomain* vala_error_domain_construct (GType object_type, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaList* vala_error_domain_get_codes (ValaErrorDomain* self);
ValaErrorCode* vala_error_code_new (const char* name, ValaSourceReference* source_reference, ValaComment* comment);
ValaErrorCode* vala_error_code_construct (GType object_type, const char* name, ValaSourceReference* source_reference, ValaComment* comment);
void vala_error_code_set_value (ValaErrorCode* self, ValaExpression* value);
void vala_error_domain_add_code (ValaErrorDomain* self, ValaErrorCode* ecode);
void vala_error_domain_add_method (ValaErrorDomain* self, ValaMethod* m);
ValaFormalParameter* vala_formal_parameter_new_with_ellipsis (ValaSourceReference* source_reference);
ValaFormalParameter* vala_formal_parameter_construct_with_ellipsis (GType object_type, ValaSourceReference* source_reference);
GType vala_parameter_direction_get_type (void) G_GNUC_CONST;
ValaFormalParameter* vala_formal_parameter_new (const char* name, ValaDataType* variable_type, ValaSourceReference* source_reference);
ValaFormalParameter* vala_formal_parameter_construct (GType object_type, const char* name, ValaDataType* variable_type, ValaSourceReference* source_reference);
void vala_formal_parameter_set_direction (ValaFormalParameter* self, ValaParameterDirection value);
void vala_formal_parameter_set_params_array (ValaFormalParameter* self, gboolean value);
ValaDelegate* vala_delegate_new (const char* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
ValaDelegate* vala_delegate_construct (GType object_type, const char* name, ValaDataType* return_type, ValaSourceReference* source_reference, ValaComment* comment);
void vala_delegate_set_has_target (ValaDelegate* self, gboolean value);
void vala_delegate_add_type_parameter (ValaDelegate* self, ValaTypeParameter* p);
void vala_delegate_add_parameter (ValaDelegate* self, ValaFormalParameter* param);
ValaTypeParameter* vala_typeparameter_new (const char* name, ValaSourceReference* source_reference);
ValaTypeParameter* vala_typeparameter_construct (GType object_type, const char* name, ValaSourceReference* source_reference);
static void vala_parser_finalize (ValaCodeVisitor* obj);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static int _vala_strcmp0 (const char * str1, const char * str2);



static GType vala_parser_modifier_flags_get_type (void) {
	static volatile gsize vala_parser_modifier_flags_type_id__volatile = 0;
	if (g_once_init_enter (&vala_parser_modifier_flags_type_id__volatile)) {
		static const GEnumValue values[] = {{VALA_PARSER_MODIFIER_FLAGS_NONE, "VALA_PARSER_MODIFIER_FLAGS_NONE", "none"}, {VALA_PARSER_MODIFIER_FLAGS_ABSTRACT, "VALA_PARSER_MODIFIER_FLAGS_ABSTRACT", "abstract"}, {VALA_PARSER_MODIFIER_FLAGS_CLASS, "VALA_PARSER_MODIFIER_FLAGS_CLASS", "class"}, {VALA_PARSER_MODIFIER_FLAGS_EXTERN, "VALA_PARSER_MODIFIER_FLAGS_EXTERN", "extern"}, {VALA_PARSER_MODIFIER_FLAGS_INLINE, "VALA_PARSER_MODIFIER_FLAGS_INLINE", "inline"}, {VALA_PARSER_MODIFIER_FLAGS_NEW, "VALA_PARSER_MODIFIER_FLAGS_NEW", "new"}, {VALA_PARSER_MODIFIER_FLAGS_OVERRIDE, "VALA_PARSER_MODIFIER_FLAGS_OVERRIDE", "override"}, {VALA_PARSER_MODIFIER_FLAGS_STATIC, "VALA_PARSER_MODIFIER_FLAGS_STATIC", "static"}, {VALA_PARSER_MODIFIER_FLAGS_VIRTUAL, "VALA_PARSER_MODIFIER_FLAGS_VIRTUAL", "virtual"}, {VALA_PARSER_MODIFIER_FLAGS_ASYNC, "VALA_PARSER_MODIFIER_FLAGS_ASYNC", "async"}, {VALA_PARSER_MODIFIER_FLAGS_SEALED, "VALA_PARSER_MODIFIER_FLAGS_SEALED", "sealed"}, {0, NULL, NULL}};
		GType vala_parser_modifier_flags_type_id;
		vala_parser_modifier_flags_type_id = g_enum_register_static ("ValaParserModifierFlags", values);
		g_once_init_leave (&vala_parser_modifier_flags_type_id__volatile, vala_parser_modifier_flags_type_id);
	}
	return vala_parser_modifier_flags_type_id__volatile;
}


static GType vala_parser_recovery_state_get_type (void) {
	static volatile gsize vala_parser_recovery_state_type_id__volatile = 0;
	if (g_once_init_enter (&vala_parser_recovery_state_type_id__volatile)) {
		static const GEnumValue values[] = {{VALA_PARSER_RECOVERY_STATE_EOF, "VALA_PARSER_RECOVERY_STATE_EOF", "eof"}, {VALA_PARSER_RECOVERY_STATE_DECLARATION_BEGIN, "VALA_PARSER_RECOVERY_STATE_DECLARATION_BEGIN", "declaration-begin"}, {VALA_PARSER_RECOVERY_STATE_STATEMENT_BEGIN, "VALA_PARSER_RECOVERY_STATE_STATEMENT_BEGIN", "statement-begin"}, {0, NULL, NULL}};
		GType vala_parser_recovery_state_type_id;
		vala_parser_recovery_state_type_id = g_enum_register_static ("ValaParserRecoveryState", values);
		g_once_init_leave (&vala_parser_recovery_state_type_id__volatile, vala_parser_recovery_state_type_id);
	}
	return vala_parser_recovery_state_type_id__volatile;
}


ValaParser* vala_parser_construct (GType object_type) {
	ValaParser* self = NULL;
	ValaParserTokenInfo* _tmp0_;
	self = (ValaParser*) vala_code_visitor_construct (object_type);
	self->priv->tokens = (_tmp0_ = g_new0 (ValaParserTokenInfo, VALA_PARSER_BUFFER_SIZE), self->priv->tokens = (g_free (self->priv->tokens), NULL), self->priv->tokens_length1 = VALA_PARSER_BUFFER_SIZE, self->priv->_tokens_size_ = self->priv->tokens_length1, _tmp0_);
	return self;
}


ValaParser* vala_parser_new (void) {
	return vala_parser_construct (VALA_TYPE_PARSER);
}


/**
 * Parses all .vala and .vapi source files in the specified code
 * context and builds a code tree.
 *
 * @param context a code context
 */
static gpointer _vala_code_context_ref0 (gpointer self) {
	return self ? vala_code_context_ref (self) : NULL;
}


void vala_parser_parse (ValaParser* self, ValaCodeContext* context) {
	ValaCodeContext* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (context != NULL);
	self->priv->context = (_tmp0_ = _vala_code_context_ref0 (context), _vala_code_context_unref0 (self->priv->context), _tmp0_);
	vala_code_context_accept (context, (ValaCodeVisitor*) self);
}


static void vala_parser_real_visit_source_file (ValaCodeVisitor* base, ValaSourceFile* source_file) {
	ValaParser * self;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	self = (ValaParser*) base;
	g_return_if_fail (source_file != NULL);
	if (vala_code_context_get_run_output (self->priv->context)) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = g_str_has_suffix (vala_source_file_get_filename (source_file), ".vala");
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_str_has_suffix (vala_source_file_get_filename (source_file), ".vapi");
	}
	if (_tmp0_) {
		vala_parser_parse_file (self, source_file);
	}
}


static inline gboolean vala_parser_next (ValaParser* self) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	self->priv->index = (self->priv->index + 1) % VALA_PARSER_BUFFER_SIZE;
	self->priv->size--;
	if (self->priv->size <= 0) {
		ValaSourceLocation begin = {0};
		ValaSourceLocation end = {0};
		ValaTokenType type;
		type = vala_scanner_read_token (self->priv->scanner, &begin, &end);
		self->priv->tokens[self->priv->index].type = type;
		self->priv->tokens[self->priv->index].begin = begin;
		self->priv->tokens[self->priv->index].end = end;
		self->priv->size = 1;
	}
	result = self->priv->tokens[self->priv->index].type != VALA_TOKEN_TYPE_EOF;
	return result;
}


static inline void vala_parser_prev (ValaParser* self) {
	g_return_if_fail (self != NULL);
	self->priv->index = ((self->priv->index - 1) + VALA_PARSER_BUFFER_SIZE) % VALA_PARSER_BUFFER_SIZE;
	self->priv->size++;
	g_assert (self->priv->size <= VALA_PARSER_BUFFER_SIZE);
}


static inline ValaTokenType vala_parser_current (ValaParser* self) {
	ValaTokenType result = 0;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->tokens[self->priv->index].type;
	return result;
}


static inline gboolean vala_parser_accept (ValaParser* self, ValaTokenType type) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	if (vala_parser_current (self) == type) {
		vala_parser_next (self);
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}


static char* vala_parser_get_error (ValaParser* self, const char* msg) {
	char* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	char* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (msg != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_next (self);
	vala_report_error (_tmp1_ = vala_parser_get_src (self, &begin), _tmp2_ = g_strconcat ("syntax error, ", msg, NULL));
	_g_free0 (_tmp2_);
	_vala_source_reference_unref0 (_tmp1_);
	result = g_strdup (msg);
	return result;
}


static inline gboolean vala_parser_expect (ValaParser* self, ValaTokenType type, GError** error) {
	gboolean result = FALSE;
	char* _tmp0_;
	char* _tmp1_;
	GError* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	if (vala_parser_accept (self, type)) {
		result = TRUE;
		return result;
	}
	_inner_error_ = (_tmp2_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp1_ = vala_parser_get_error (self, _tmp0_ = g_strdup_printf ("expected %s", vala_token_type_to_string (type)))), _g_free0 (_tmp1_), _g_free0 (_tmp0_), _tmp2_);
	{
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
}


static inline void vala_parser_get_location (ValaParser* self, ValaSourceLocation* result) {
	g_return_if_fail (self != NULL);
	*result = self->priv->tokens[self->priv->index].begin;
	return;
}


static char* vala_parser_get_current_string (ValaParser* self) {
	char* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = g_strndup ((const char*) self->priv->tokens[self->priv->index].begin.pos, self->priv->tokens[self->priv->index].end.pos - self->priv->tokens[self->priv->index].begin.pos);
	return result;
}


static char* vala_parser_get_last_string (ValaParser* self) {
	char* result = NULL;
	gint last_index;
	g_return_val_if_fail (self != NULL, NULL);
	last_index = ((self->priv->index + VALA_PARSER_BUFFER_SIZE) - 1) % VALA_PARSER_BUFFER_SIZE;
	result = g_strndup ((const char*) self->priv->tokens[last_index].begin.pos, self->priv->tokens[last_index].end.pos - self->priv->tokens[last_index].begin.pos);
	return result;
}


static ValaSourceReference* vala_parser_get_src (ValaParser* self, ValaSourceLocation* begin) {
	ValaSourceReference* result = NULL;
	gint last_index;
	g_return_val_if_fail (self != NULL, NULL);
	last_index = ((self->priv->index + VALA_PARSER_BUFFER_SIZE) - 1) % VALA_PARSER_BUFFER_SIZE;
	result = vala_source_reference_new (vala_scanner_get_source_file (self->priv->scanner), (*begin).line, (*begin).column, self->priv->tokens[last_index].end.line, self->priv->tokens[last_index].end.column);
	return result;
}


static ValaSourceReference* vala_parser_get_current_src (ValaParser* self) {
	ValaSourceReference* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = vala_source_reference_new (vala_scanner_get_source_file (self->priv->scanner), self->priv->tokens[self->priv->index].begin.line, self->priv->tokens[self->priv->index].begin.column, self->priv->tokens[self->priv->index].end.line, self->priv->tokens[self->priv->index].end.column);
	return result;
}


static ValaSourceReference* vala_parser_get_last_src (ValaParser* self) {
	ValaSourceReference* result = NULL;
	gint last_index;
	g_return_val_if_fail (self != NULL, NULL);
	last_index = ((self->priv->index + VALA_PARSER_BUFFER_SIZE) - 1) % VALA_PARSER_BUFFER_SIZE;
	result = vala_source_reference_new (vala_scanner_get_source_file (self->priv->scanner), self->priv->tokens[last_index].begin.line, self->priv->tokens[last_index].begin.column, self->priv->tokens[last_index].end.line, self->priv->tokens[last_index].end.column);
	return result;
}


static void vala_parser_rollback (ValaParser* self, ValaSourceLocation* location) {
	g_return_if_fail (self != NULL);
	while (TRUE) {
		if (!(self->priv->tokens[self->priv->index].begin.pos != (*location).pos)) {
			break;
		}
		self->priv->index = ((self->priv->index - 1) + VALA_PARSER_BUFFER_SIZE) % VALA_PARSER_BUFFER_SIZE;
		self->priv->size++;
		if (self->priv->size > VALA_PARSER_BUFFER_SIZE) {
			vala_scanner_seek (self->priv->scanner, location);
			self->priv->size = 0;
			self->priv->index = 0;
			vala_parser_next (self);
		}
	}
}


static glong string_get_length (const char* self) {
	glong result;
	g_return_val_if_fail (self != NULL, 0L);
	result = g_utf8_strlen (self, (gssize) (-1));
	return result;
}


static gboolean string_contains (const char* self, const char* needle) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (needle != NULL, FALSE);
	result = strstr (self, needle) != NULL;
	return result;
}


static void vala_parser_skip_identifier (ValaParser* self, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	switch (vala_parser_current (self)) {
		case VALA_TOKEN_TYPE_ABSTRACT:
		case VALA_TOKEN_TYPE_AS:
		case VALA_TOKEN_TYPE_ASYNC:
		case VALA_TOKEN_TYPE_BASE:
		case VALA_TOKEN_TYPE_BREAK:
		case VALA_TOKEN_TYPE_CASE:
		case VALA_TOKEN_TYPE_CATCH:
		case VALA_TOKEN_TYPE_CLASS:
		case VALA_TOKEN_TYPE_CONST:
		case VALA_TOKEN_TYPE_CONSTRUCT:
		case VALA_TOKEN_TYPE_CONTINUE:
		case VALA_TOKEN_TYPE_DEFAULT:
		case VALA_TOKEN_TYPE_DELEGATE:
		case VALA_TOKEN_TYPE_DELETE:
		case VALA_TOKEN_TYPE_DO:
		case VALA_TOKEN_TYPE_DYNAMIC:
		case VALA_TOKEN_TYPE_ELSE:
		case VALA_TOKEN_TYPE_ENUM:
		case VALA_TOKEN_TYPE_ENSURES:
		case VALA_TOKEN_TYPE_ERRORDOMAIN:
		case VALA_TOKEN_TYPE_EXTERN:
		case VALA_TOKEN_TYPE_FALSE:
		case VALA_TOKEN_TYPE_FINALLY:
		case VALA_TOKEN_TYPE_FOR:
		case VALA_TOKEN_TYPE_FOREACH:
		case VALA_TOKEN_TYPE_GET:
		case VALA_TOKEN_TYPE_IDENTIFIER:
		case VALA_TOKEN_TYPE_IF:
		case VALA_TOKEN_TYPE_IN:
		case VALA_TOKEN_TYPE_INLINE:
		case VALA_TOKEN_TYPE_INTERFACE:
		case VALA_TOKEN_TYPE_INTERNAL:
		case VALA_TOKEN_TYPE_IS:
		case VALA_TOKEN_TYPE_LOCK:
		case VALA_TOKEN_TYPE_NAMESPACE:
		case VALA_TOKEN_TYPE_NEW:
		case VALA_TOKEN_TYPE_NULL:
		case VALA_TOKEN_TYPE_OUT:
		case VALA_TOKEN_TYPE_OVERRIDE:
		case VALA_TOKEN_TYPE_OWNED:
		case VALA_TOKEN_TYPE_PARAMS:
		case VALA_TOKEN_TYPE_PRIVATE:
		case VALA_TOKEN_TYPE_PROTECTED:
		case VALA_TOKEN_TYPE_PUBLIC:
		case VALA_TOKEN_TYPE_REF:
		case VALA_TOKEN_TYPE_REQUIRES:
		case VALA_TOKEN_TYPE_RETURN:
		case VALA_TOKEN_TYPE_SEALED:
		case VALA_TOKEN_TYPE_SET:
		case VALA_TOKEN_TYPE_SIGNAL:
		case VALA_TOKEN_TYPE_SIZEOF:
		case VALA_TOKEN_TYPE_STATIC:
		case VALA_TOKEN_TYPE_STRUCT:
		case VALA_TOKEN_TYPE_SWITCH:
		case VALA_TOKEN_TYPE_THIS:
		case VALA_TOKEN_TYPE_THROW:
		case VALA_TOKEN_TYPE_THROWS:
		case VALA_TOKEN_TYPE_TRUE:
		case VALA_TOKEN_TYPE_TRY:
		case VALA_TOKEN_TYPE_TYPEOF:
		case VALA_TOKEN_TYPE_UNOWNED:
		case VALA_TOKEN_TYPE_USING:
		case VALA_TOKEN_TYPE_VAR:
		case VALA_TOKEN_TYPE_VIRTUAL:
		case VALA_TOKEN_TYPE_VOID:
		case VALA_TOKEN_TYPE_VOLATILE:
		case VALA_TOKEN_TYPE_WEAK:
		case VALA_TOKEN_TYPE_WHILE:
		case VALA_TOKEN_TYPE_YIELD:
		{
			vala_parser_next (self);
			return;
		}
		case VALA_TOKEN_TYPE_INTEGER_LITERAL:
		case VALA_TOKEN_TYPE_REAL_LITERAL:
		{
			char* id;
			gboolean _tmp0_ = FALSE;
			id = vala_parser_get_current_string (self);
			if (g_unichar_isalpha (g_utf8_get_char (g_utf8_offset_to_pointer (id, string_get_length (id) - 1)))) {
				_tmp0_ = !string_contains (id, ".");
			} else {
				_tmp0_ = FALSE;
			}
			if (_tmp0_) {
				vala_parser_next (self);
				_g_free0 (id);
				return;
			}
			_g_free0 (id);
			break;
		}
		default:
		{
			char* _tmp1_;
			GError* _tmp2_;
			_inner_error_ = (_tmp2_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp1_ = vala_parser_get_error (self, "expected identifier")), _g_free0 (_tmp1_), _tmp2_);
			{
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


static char* vala_parser_parse_identifier (ValaParser* self, GError** error) {
	char* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_parser_skip_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = vala_parser_get_last_string (self);
	return result;
}


static char* string_substring (const char* self, glong offset, glong len) {
	char* result = NULL;
	glong string_length;
	const char* start;
	g_return_val_if_fail (self != NULL, NULL);
	string_length = string_get_length (self);
	if (offset < 0) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= 0, NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < 0) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	start = g_utf8_offset_to_pointer (self, offset);
	result = g_strndup (start, ((gchar*) g_utf8_offset_to_pointer (start, len)) - ((gchar*) start));
	return result;
}


static ValaExpression* vala_parser_parse_literal (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	switch (vala_parser_current (self)) {
		case VALA_TOKEN_TYPE_TRUE:
		{
			ValaSourceReference* _tmp1_;
			ValaExpression* _tmp2_;
			vala_parser_next (self);
			result = (_tmp2_ = (ValaExpression*) vala_boolean_literal_new (TRUE, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
			return result;
		}
		case VALA_TOKEN_TYPE_FALSE:
		{
			ValaSourceReference* _tmp3_;
			ValaExpression* _tmp4_;
			vala_parser_next (self);
			result = (_tmp4_ = (ValaExpression*) vala_boolean_literal_new (FALSE, _tmp3_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
			return result;
		}
		case VALA_TOKEN_TYPE_INTEGER_LITERAL:
		{
			char* _tmp5_;
			ValaSourceReference* _tmp6_;
			ValaExpression* _tmp7_;
			vala_parser_next (self);
			result = (_tmp7_ = (ValaExpression*) vala_integer_literal_new (_tmp5_ = vala_parser_get_last_string (self), _tmp6_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp6_), _g_free0 (_tmp5_), _tmp7_);
			return result;
		}
		case VALA_TOKEN_TYPE_REAL_LITERAL:
		{
			char* _tmp8_;
			ValaSourceReference* _tmp9_;
			ValaExpression* _tmp10_;
			vala_parser_next (self);
			result = (_tmp10_ = (ValaExpression*) vala_real_literal_new (_tmp8_ = vala_parser_get_last_string (self), _tmp9_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp9_), _g_free0 (_tmp8_), _tmp10_);
			return result;
		}
		case VALA_TOKEN_TYPE_CHARACTER_LITERAL:
		{
			char* _tmp11_;
			ValaSourceReference* _tmp12_;
			ValaCharacterLiteral* _tmp13_;
			ValaCharacterLiteral* lit;
			vala_parser_next (self);
			lit = (_tmp13_ = vala_character_literal_new (_tmp11_ = vala_parser_get_last_string (self), _tmp12_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp12_), _g_free0 (_tmp11_), _tmp13_);
			if (vala_code_node_get_error ((ValaCodeNode*) lit)) {
				vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) lit), "invalid character literal");
			}
			result = (ValaExpression*) lit;
			return result;
		}
		case VALA_TOKEN_TYPE_REGEX_LITERAL:
		{
			char* match_part;
			ValaSourceReference* src_begin;
			char* close_token;
			char* _tmp14_;
			ValaExpression* _tmp15_;
			vala_parser_next (self);
			match_part = vala_parser_get_last_string (self);
			src_begin = vala_parser_get_src (self, &begin);
			vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_REGEX_LITERAL, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_source_reference_unref0 (src_begin);
					_g_free0 (match_part);
					return NULL;
				} else {
					_vala_source_reference_unref0 (src_begin);
					_g_free0 (match_part);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			close_token = vala_parser_get_last_string (self);
			result = (_tmp15_ = (ValaExpression*) vala_regex_literal_new (_tmp14_ = g_strdup_printf ("%s/%s", close_token, match_part), src_begin), _g_free0 (_tmp14_), _tmp15_);
			_g_free0 (close_token);
			_vala_source_reference_unref0 (src_begin);
			_g_free0 (match_part);
			return result;
			_g_free0 (close_token);
			_vala_source_reference_unref0 (src_begin);
			_g_free0 (match_part);
		}
		case VALA_TOKEN_TYPE_STRING_LITERAL:
		{
			char* _tmp16_;
			ValaSourceReference* _tmp17_;
			ValaExpression* _tmp18_;
			vala_parser_next (self);
			result = (_tmp18_ = (ValaExpression*) vala_string_literal_new (_tmp16_ = vala_parser_get_last_string (self), _tmp17_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp17_), _g_free0 (_tmp16_), _tmp18_);
			return result;
		}
		case VALA_TOKEN_TYPE_TEMPLATE_STRING_LITERAL:
		{
			char* _tmp19_;
			char* _tmp20_;
			ValaSourceReference* _tmp21_;
			ValaExpression* _tmp22_;
			vala_parser_next (self);
			result = (_tmp22_ = (ValaExpression*) vala_string_literal_new (_tmp20_ = g_strdup_printf ("\"%s\"", _tmp19_ = vala_parser_get_last_string (self)), _tmp21_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp21_), _g_free0 (_tmp20_), _g_free0 (_tmp19_), _tmp22_);
			return result;
		}
		case VALA_TOKEN_TYPE_VERBATIM_STRING_LITERAL:
		{
			char* raw_string;
			char* _tmp23_;
			char* _tmp24_;
			char* escaped_string;
			char* _tmp25_;
			ValaSourceReference* _tmp26_;
			ValaExpression* _tmp27_;
			vala_parser_next (self);
			raw_string = vala_parser_get_last_string (self);
			escaped_string = (_tmp24_ = g_strescape (_tmp23_ = string_substring (raw_string, (glong) 3, string_get_length (raw_string) - 6), ""), _g_free0 (_tmp23_), _tmp24_);
			result = (_tmp27_ = (ValaExpression*) vala_string_literal_new (_tmp25_ = g_strdup_printf ("\"%s\"", escaped_string), _tmp26_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp26_), _g_free0 (_tmp25_), _tmp27_);
			_g_free0 (escaped_string);
			_g_free0 (raw_string);
			return result;
			_g_free0 (escaped_string);
			_g_free0 (raw_string);
		}
		case VALA_TOKEN_TYPE_NULL:
		{
			ValaSourceReference* _tmp28_;
			ValaExpression* _tmp29_;
			vala_parser_next (self);
			result = (_tmp29_ = (ValaExpression*) vala_null_literal_new (_tmp28_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp28_), _tmp29_);
			return result;
		}
		default:
		{
			char* _tmp30_;
			GError* _tmp31_;
			_inner_error_ = (_tmp31_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp30_ = vala_parser_get_error (self, "expected literal")), _g_free0 (_tmp30_), _tmp31_);
			{
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	}
}


void vala_parser_parse_file (ValaParser* self, ValaSourceFile* source_file) {
	ValaScanner* _tmp0_;
	ValaScanner* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (source_file != NULL);
	self->priv->scanner = (_tmp0_ = vala_scanner_new (source_file), _vala_scanner_unref0 (self->priv->scanner), _tmp0_);
	vala_parser_parse_file_comments (self);
	self->priv->index = -1;
	self->priv->size = 0;
	vala_parser_next (self);
	{
		vala_parser_parse_using_directives (self, vala_code_context_get_root (self->priv->context), &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				goto __catch5_vala_parse_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		vala_parser_parse_declarations (self, (ValaSymbol*) vala_code_context_get_root (self->priv->context), TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				goto __catch5_vala_parse_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_CLOSE_BRACE)) {
			if (vala_report_get_errors (vala_code_context_get_report (self->priv->context)) == 0) {
				ValaSourceReference* _tmp1_;
				vala_report_error (_tmp1_ = vala_parser_get_last_src (self), "unexpected `}'");
				_vala_source_reference_unref0 (_tmp1_);
			}
		}
	}
	goto __finally5;
	__catch5_vala_parse_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			_g_error_free0 (e);
		}
	}
	__finally5:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	self->priv->scanner = (_tmp2_ = NULL, _vala_scanner_unref0 (self->priv->scanner), _tmp2_);
}


static void vala_parser_parse_file_comments (ValaParser* self) {
	g_return_if_fail (self != NULL);
	vala_scanner_parse_file_comments (self->priv->scanner);
}


static void vala_parser_skip_symbol_name (ValaParser* self, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	{
		gboolean _tmp0_;
		_tmp0_ = TRUE;
		while (TRUE) {
			if (!_tmp0_) {
				gboolean _tmp1_ = FALSE;
				if (vala_parser_accept (self, VALA_TOKEN_TYPE_DOT)) {
					_tmp1_ = TRUE;
				} else {
					_tmp1_ = vala_parser_accept (self, VALA_TOKEN_TYPE_DOUBLE_COLON);
				}
				if (!_tmp1_) {
					break;
				}
			}
			_tmp0_ = FALSE;
			vala_parser_skip_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
	}
}


static ValaUnresolvedSymbol* vala_parser_parse_symbol_name (ValaParser* self, GError** error) {
	ValaUnresolvedSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaUnresolvedSymbol* sym;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	sym = NULL;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			char* name;
			gboolean _tmp2_ = FALSE;
			ValaSourceReference* _tmp7_;
			ValaUnresolvedSymbol* _tmp8_;
			if (!_tmp1_) {
				if (!vala_parser_accept (self, VALA_TOKEN_TYPE_DOT)) {
					break;
				}
			}
			_tmp1_ = FALSE;
			name = vala_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			if (_vala_strcmp0 (name, "global") == 0) {
				_tmp2_ = vala_parser_accept (self, VALA_TOKEN_TYPE_DOUBLE_COLON);
			} else {
				_tmp2_ = FALSE;
			}
			if (_tmp2_) {
				char* _tmp3_;
				char* _tmp4_;
				ValaSourceReference* _tmp5_;
				ValaUnresolvedSymbol* _tmp6_;
				_tmp3_ = vala_parser_parse_identifier (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_free0 (name);
						_vala_code_node_unref0 (sym);
						return NULL;
					} else {
						_g_free0 (name);
						_vala_code_node_unref0 (sym);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				name = (_tmp4_ = _tmp3_, _g_free0 (name), _tmp4_);
				sym = (_tmp6_ = vala_unresolved_symbol_new (sym, name, _tmp5_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (sym), _tmp6_);
				_vala_source_reference_unref0 (_tmp5_);
				vala_unresolved_symbol_set_qualified (sym, TRUE);
				_g_free0 (name);
				continue;
			}
			sym = (_tmp8_ = vala_unresolved_symbol_new (sym, name, _tmp7_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (sym), _tmp8_);
			_vala_source_reference_unref0 (_tmp7_);
			_g_free0 (name);
		}
	}
	result = sym;
	return result;
}


static void vala_parser_skip_type (ValaParser* self, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_VOID)) {
		while (TRUE) {
			if (!vala_parser_accept (self, VALA_TOKEN_TYPE_STAR)) {
				break;
			}
		}
		return;
	}
	vala_parser_accept (self, VALA_TOKEN_TYPE_DYNAMIC);
	vala_parser_accept (self, VALA_TOKEN_TYPE_OWNED);
	vala_parser_accept (self, VALA_TOKEN_TYPE_UNOWNED);
	vala_parser_accept (self, VALA_TOKEN_TYPE_WEAK);
	vala_parser_skip_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	vala_parser_skip_type_argument_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	while (TRUE) {
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_STAR)) {
			break;
		}
	}
	vala_parser_accept (self, VALA_TOKEN_TYPE_INTERR);
	while (TRUE) {
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_OPEN_BRACKET)) {
			break;
		}
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				gboolean _tmp1_ = FALSE;
				if (!_tmp0_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				if (vala_parser_current (self) != VALA_TOKEN_TYPE_COMMA) {
					_tmp1_ = vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACKET;
				} else {
					_tmp1_ = FALSE;
				}
				if (_tmp1_) {
					ValaExpression* _tmp2_;
					_tmp2_ = vala_parser_parse_expression (self, &_inner_error_);
					_vala_code_node_unref0 (_tmp2_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							return;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
				}
			}
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		vala_parser_accept (self, VALA_TOKEN_TYPE_INTERR);
	}
	vala_parser_accept (self, VALA_TOKEN_TYPE_OP_NEG);
	vala_parser_accept (self, VALA_TOKEN_TYPE_HASH);
}


static gpointer _vala_code_node_ref0 (gpointer self) {
	return self ? vala_code_node_ref (self) : NULL;
}


static ValaDataType* vala_parser_parse_type (ValaParser* self, gboolean owned_by_default, gboolean can_weak_ref, GError** error) {
	ValaDataType* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	gboolean is_dynamic;
	gboolean value_owned;
	ValaUnresolvedSymbol* sym;
	ValaList* type_arg_list;
	ValaSourceReference* _tmp8_;
	ValaDataType* _tmp9_;
	ValaDataType* type;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_VOID)) {
		ValaSourceReference* _tmp1_;
		ValaDataType* _tmp2_;
		ValaDataType* type;
		type = (_tmp2_ = (ValaDataType*) vala_void_type_new (_tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
		while (TRUE) {
			ValaDataType* _tmp3_;
			if (!vala_parser_accept (self, VALA_TOKEN_TYPE_STAR)) {
				break;
			}
			type = (_tmp3_ = (ValaDataType*) vala_pointer_type_new (type, NULL), _vala_code_node_unref0 (type), _tmp3_);
		}
		result = type;
		return result;
	}
	is_dynamic = vala_parser_accept (self, VALA_TOKEN_TYPE_DYNAMIC);
	value_owned = owned_by_default;
	if (owned_by_default) {
		if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
			gboolean _tmp4_ = FALSE;
			if (can_weak_ref) {
				_tmp4_ = vala_parser_accept (self, VALA_TOKEN_TYPE_WEAK);
			} else {
				_tmp4_ = FALSE;
			}
			if (_tmp4_) {
				value_owned = FALSE;
			}
		} else {
			if (vala_parser_accept (self, VALA_TOKEN_TYPE_UNOWNED)) {
				value_owned = FALSE;
			} else {
				if (vala_parser_accept (self, VALA_TOKEN_TYPE_WEAK)) {
					gboolean _tmp5_ = FALSE;
					if (!can_weak_ref) {
						_tmp5_ = !vala_code_context_get_deprecated (self->priv->context);
					} else {
						_tmp5_ = FALSE;
					}
					if (_tmp5_) {
						ValaSourceReference* _tmp6_;
						vala_report_warning (_tmp6_ = vala_parser_get_last_src (self), "deprecated syntax, use `unowned` modifier");
						_vala_source_reference_unref0 (_tmp6_);
					}
					value_owned = FALSE;
				}
			}
		}
	} else {
		gboolean _tmp7_ = FALSE;
		if (vala_code_context_get_profile (self->priv->context) != VALA_PROFILE_DOVA) {
			_tmp7_ = vala_parser_accept (self, VALA_TOKEN_TYPE_OWNED);
		} else {
			_tmp7_ = FALSE;
		}
		value_owned = _tmp7_;
	}
	sym = vala_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_arg_list = vala_parser_parse_type_argument_list (self, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = (_tmp9_ = (ValaDataType*) vala_unresolved_type_new_from_symbol (sym, _tmp8_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp8_), _tmp9_);
	if (type_arg_list != NULL) {
		{
			ValaIterator* _type_arg_it;
			_type_arg_it = vala_iterable_iterator ((ValaIterable*) type_arg_list);
			while (TRUE) {
				ValaDataType* type_arg;
				if (!vala_iterator_next (_type_arg_it)) {
					break;
				}
				type_arg = (ValaDataType*) vala_iterator_get (_type_arg_it);
				vala_data_type_add_type_argument (type, type_arg);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_collection_object_unref0 (_type_arg_it);
		}
	}
	while (TRUE) {
		ValaSourceReference* _tmp10_;
		ValaDataType* _tmp11_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_STAR)) {
			break;
		}
		type = (_tmp11_ = (ValaDataType*) vala_pointer_type_new (type, _tmp10_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (type), _tmp11_);
		_vala_source_reference_unref0 (_tmp10_);
	}
	if (!VALA_IS_POINTER_TYPE (type)) {
		vala_data_type_set_nullable (type, vala_parser_accept (self, VALA_TOKEN_TYPE_INTERR));
	}
	while (TRUE) {
		gboolean invalid_array;
		gint array_rank;
		ValaSourceReference* _tmp16_;
		ValaArrayType* _tmp17_;
		ValaArrayType* array_type;
		ValaDataType* _tmp18_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_OPEN_BRACKET)) {
			break;
		}
		invalid_array = FALSE;
		array_rank = 0;
		{
			gboolean _tmp12_;
			_tmp12_ = TRUE;
			while (TRUE) {
				gboolean _tmp14_ = FALSE;
				if (!_tmp12_) {
					gboolean _tmp13_ = FALSE;
					if (vala_code_context_get_profile (self->priv->context) != VALA_PROFILE_DOVA) {
						_tmp13_ = vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA);
					} else {
						_tmp13_ = FALSE;
					}
					if (!_tmp13_) {
						break;
					}
				}
				_tmp12_ = FALSE;
				array_rank++;
				if (vala_parser_current (self) != VALA_TOKEN_TYPE_COMMA) {
					_tmp14_ = vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACKET;
				} else {
					_tmp14_ = FALSE;
				}
				if (_tmp14_) {
					ValaExpression* _tmp15_;
					_tmp15_ = vala_parser_parse_expression (self, &_inner_error_);
					_vala_code_node_unref0 (_tmp15_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (type);
							_vala_collection_object_unref0 (type_arg_list);
							_vala_code_node_unref0 (sym);
							return NULL;
						} else {
							_vala_code_node_unref0 (type);
							_vala_collection_object_unref0 (type_arg_list);
							_vala_code_node_unref0 (sym);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					invalid_array = TRUE;
				}
			}
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (type);
				_vala_collection_object_unref0 (type_arg_list);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (type);
				_vala_collection_object_unref0 (type_arg_list);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_data_type_set_value_owned (type, TRUE);
		array_type = (_tmp17_ = vala_array_type_new (type, array_rank, _tmp16_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp16_), _tmp17_);
		vala_data_type_set_nullable ((ValaDataType*) array_type, vala_parser_accept (self, VALA_TOKEN_TYPE_INTERR));
		vala_array_type_set_invalid_syntax (array_type, invalid_array);
		type = (_tmp18_ = _vala_code_node_ref0 ((ValaDataType*) array_type), _vala_code_node_unref0 (type), _tmp18_);
		_vala_code_node_unref0 (array_type);
	}
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_OP_NEG)) {
		ValaSourceReference* _tmp19_;
		vala_report_warning (_tmp19_ = vala_parser_get_last_src (self), "obsolete syntax, types are non-null by default");
		_vala_source_reference_unref0 (_tmp19_);
	}
	if (!owned_by_default) {
		gboolean _tmp20_ = FALSE;
		if (vala_code_context_get_profile (self->priv->context) != VALA_PROFILE_DOVA) {
			_tmp20_ = vala_parser_accept (self, VALA_TOKEN_TYPE_HASH);
		} else {
			_tmp20_ = FALSE;
		}
		if (_tmp20_) {
			if (!vala_code_context_get_deprecated (self->priv->context)) {
				ValaSourceReference* _tmp21_;
				vala_report_warning (_tmp21_ = vala_parser_get_last_src (self), "deprecated syntax, use `owned` modifier");
				_vala_source_reference_unref0 (_tmp21_);
			}
			value_owned = TRUE;
		}
	}
	vala_data_type_set_is_dynamic (type, is_dynamic);
	vala_data_type_set_value_owned (type, value_owned);
	result = type;
	_vala_collection_object_unref0 (type_arg_list);
	_vala_code_node_unref0 (sym);
	return result;
}


static ValaDataType* vala_parser_parse_inline_array_type (ValaParser* self, ValaDataType* type, GError** error) {
	ValaDataType* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	gboolean _tmp1_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	if (type != NULL) {
		_tmp1_ = vala_parser_accept (self, VALA_TOKEN_TYPE_OPEN_BRACKET);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		gint array_length;
		ValaSourceReference* _tmp5_;
		ValaArrayType* _tmp6_;
		ValaArrayType* array_type;
		array_length = -1;
		if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACKET) {
			ValaExpression* _tmp4_;
			ValaIntegerLiteral* length_literal;
			if (vala_parser_current (self) != VALA_TOKEN_TYPE_INTEGER_LITERAL) {
				char* _tmp2_;
				GError* _tmp3_;
				_inner_error_ = (_tmp3_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp2_ = vala_parser_get_error (self, "expected `]' or integer literal")), _g_free0 (_tmp2_), _tmp3_);
				{
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return NULL;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
			_tmp4_ = vala_parser_parse_literal (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			length_literal = VALA_INTEGER_LITERAL (_tmp4_);
			array_length = atoi (vala_integer_literal_get_value (length_literal));
			_vala_code_node_unref0 (length_literal);
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		array_type = (_tmp6_ = vala_array_type_new (type, 1, _tmp5_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp5_), _tmp6_);
		vala_array_type_set_inline_allocated (array_type, TRUE);
		if (array_length > 0) {
			vala_array_type_set_fixed_length (array_type, TRUE);
			vala_array_type_set_length (array_type, array_length);
		}
		vala_data_type_set_value_owned ((ValaDataType*) array_type, vala_data_type_get_value_owned (type));
		result = (ValaDataType*) array_type;
		return result;
	}
	result = _vala_code_node_ref0 (type);
	return result;
}


static ValaList* vala_parser_parse_argument_list (ValaParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	list = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				ValaExpression* _tmp1_;
				ValaExpression* _tmp2_;
				if (!_tmp0_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				_tmp1_ = vala_parser_parse_argument (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (list);
						return NULL;
					} else {
						_vala_collection_object_unref0 (list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) list, _tmp2_ = _tmp1_);
				_vala_code_node_unref0 (_tmp2_);
			}
		}
	}
	result = (ValaList*) list;
	return result;
}


static ValaExpression* vala_parser_parse_argument (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_REF)) {
		ValaExpression* inner;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		inner = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = (_tmp2_ = (ValaExpression*) vala_unary_expression_new (VALA_UNARY_OPERATOR_REF, inner, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
		_vala_code_node_unref0 (inner);
		return result;
		_vala_code_node_unref0 (inner);
	} else {
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_OUT)) {
			ValaExpression* inner;
			ValaSourceReference* _tmp3_;
			ValaExpression* _tmp4_;
			inner = vala_parser_parse_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (_tmp4_ = (ValaExpression*) vala_unary_expression_new (VALA_UNARY_OPERATOR_OUT, inner, _tmp3_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
			_vala_code_node_unref0 (inner);
			return result;
			_vala_code_node_unref0 (inner);
		} else {
			ValaExpression* expr;
			ValaExpression* _tmp5_;
			ValaMemberAccess* ma;
			gboolean _tmp6_ = FALSE;
			gboolean _tmp7_ = FALSE;
			expr = vala_parser_parse_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			ma = _vala_code_node_ref0 ((_tmp5_ = expr, VALA_IS_MEMBER_ACCESS (_tmp5_) ? ((ValaMemberAccess*) _tmp5_) : NULL));
			if (ma != NULL) {
				_tmp7_ = vala_member_access_get_inner (ma) == NULL;
			} else {
				_tmp7_ = FALSE;
			}
			if (_tmp7_) {
				_tmp6_ = vala_parser_accept (self, VALA_TOKEN_TYPE_COLON);
			} else {
				_tmp6_ = FALSE;
			}
			if (_tmp6_) {
				ValaExpression* _tmp8_;
				ValaExpression* _tmp9_;
				ValaSourceReference* _tmp10_;
				ValaExpression* _tmp11_;
				_tmp8_ = vala_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (ma);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (ma);
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp9_ = _tmp8_, _vala_code_node_unref0 (expr), _tmp9_);
				result = (_tmp11_ = (ValaExpression*) vala_named_argument_new (vala_member_access_get_member_name (ma), expr, _tmp10_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp10_), _tmp11_);
				_vala_code_node_unref0 (ma);
				_vala_code_node_unref0 (expr);
				return result;
			} else {
				result = expr;
				_vala_code_node_unref0 (ma);
				return result;
			}
			_vala_code_node_unref0 (ma);
			_vala_code_node_unref0 (expr);
		}
	}
}


static ValaExpression* vala_parser_parse_primary_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	gboolean found;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	expr = NULL;
	switch (vala_parser_current (self)) {
		case VALA_TOKEN_TYPE_TRUE:
		case VALA_TOKEN_TYPE_FALSE:
		case VALA_TOKEN_TYPE_INTEGER_LITERAL:
		case VALA_TOKEN_TYPE_REAL_LITERAL:
		case VALA_TOKEN_TYPE_CHARACTER_LITERAL:
		case VALA_TOKEN_TYPE_STRING_LITERAL:
		case VALA_TOKEN_TYPE_REGEX_LITERAL:
		case VALA_TOKEN_TYPE_TEMPLATE_STRING_LITERAL:
		case VALA_TOKEN_TYPE_VERBATIM_STRING_LITERAL:
		case VALA_TOKEN_TYPE_NULL:
		{
			ValaExpression* _tmp1_;
			ValaExpression* _tmp2_;
			_tmp1_ = vala_parser_parse_literal (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (expr), _tmp2_);
			break;
		}
		case VALA_TOKEN_TYPE_OPEN_BRACE:
		{
			if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
				ValaExpression* _tmp3_;
				ValaExpression* _tmp4_;
				_tmp3_ = vala_parser_parse_set_literal (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp4_ = _tmp3_, _vala_code_node_unref0 (expr), _tmp4_);
			} else {
				ValaInitializerList* _tmp5_;
				ValaExpression* _tmp6_;
				_tmp5_ = vala_parser_parse_initializer (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp6_ = (ValaExpression*) _tmp5_, _vala_code_node_unref0 (expr), _tmp6_);
			}
			break;
		}
		case VALA_TOKEN_TYPE_OPEN_BRACKET:
		{
			if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
				ValaListLiteral* _tmp7_;
				ValaExpression* _tmp8_;
				_tmp7_ = vala_parser_parse_list_literal (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp8_ = (ValaExpression*) _tmp7_, _vala_code_node_unref0 (expr), _tmp8_);
			} else {
				ValaExpression* _tmp9_;
				ValaExpression* _tmp10_;
				_tmp9_ = vala_parser_parse_simple_name (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp10_ = _tmp9_, _vala_code_node_unref0 (expr), _tmp10_);
			}
			break;
		}
		case VALA_TOKEN_TYPE_OPEN_PARENS:
		{
			ValaExpression* _tmp11_;
			ValaExpression* _tmp12_;
			_tmp11_ = vala_parser_parse_tuple (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp12_ = _tmp11_, _vala_code_node_unref0 (expr), _tmp12_);
			break;
		}
		case VALA_TOKEN_TYPE_OPEN_TEMPLATE:
		{
			ValaExpression* _tmp13_;
			ValaExpression* _tmp14_;
			_tmp13_ = vala_parser_parse_template (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp14_ = _tmp13_, _vala_code_node_unref0 (expr), _tmp14_);
			break;
		}
		case VALA_TOKEN_TYPE_OPEN_REGEX_LITERAL:
		{
			ValaExpression* _tmp15_;
			ValaExpression* _tmp16_;
			_tmp15_ = vala_parser_parse_regex_literal (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp16_ = _tmp15_, _vala_code_node_unref0 (expr), _tmp16_);
			break;
		}
		case VALA_TOKEN_TYPE_THIS:
		{
			ValaExpression* _tmp17_;
			ValaExpression* _tmp18_;
			_tmp17_ = vala_parser_parse_this_access (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp18_ = _tmp17_, _vala_code_node_unref0 (expr), _tmp18_);
			break;
		}
		case VALA_TOKEN_TYPE_BASE:
		{
			ValaExpression* _tmp19_;
			ValaExpression* _tmp20_;
			_tmp19_ = vala_parser_parse_base_access (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp20_ = _tmp19_, _vala_code_node_unref0 (expr), _tmp20_);
			break;
		}
		case VALA_TOKEN_TYPE_NEW:
		{
			ValaExpression* _tmp21_;
			ValaExpression* _tmp22_;
			_tmp21_ = vala_parser_parse_object_or_array_creation_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp22_ = _tmp21_, _vala_code_node_unref0 (expr), _tmp22_);
			break;
		}
		case VALA_TOKEN_TYPE_YIELD:
		{
			ValaExpression* _tmp23_;
			ValaExpression* _tmp24_;
			_tmp23_ = vala_parser_parse_yield_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp24_ = _tmp23_, _vala_code_node_unref0 (expr), _tmp24_);
			break;
		}
		case VALA_TOKEN_TYPE_SIZEOF:
		{
			ValaExpression* _tmp25_;
			ValaExpression* _tmp26_;
			_tmp25_ = vala_parser_parse_sizeof_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp26_ = _tmp25_, _vala_code_node_unref0 (expr), _tmp26_);
			break;
		}
		case VALA_TOKEN_TYPE_TYPEOF:
		{
			ValaExpression* _tmp27_;
			ValaExpression* _tmp28_;
			_tmp27_ = vala_parser_parse_typeof_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp28_ = _tmp27_, _vala_code_node_unref0 (expr), _tmp28_);
			break;
		}
		default:
		{
			ValaExpression* _tmp29_;
			ValaExpression* _tmp30_;
			_tmp29_ = vala_parser_parse_simple_name (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp30_ = _tmp29_, _vala_code_node_unref0 (expr), _tmp30_);
			break;
		}
	}
	found = TRUE;
	while (TRUE) {
		if (!found) {
			break;
		}
		switch (vala_parser_current (self)) {
			case VALA_TOKEN_TYPE_DOT:
			{
				ValaExpression* _tmp31_;
				ValaExpression* _tmp32_;
				_tmp31_ = vala_parser_parse_member_access (self, &begin, expr, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp32_ = _tmp31_, _vala_code_node_unref0 (expr), _tmp32_);
				break;
			}
			case VALA_TOKEN_TYPE_OP_PTR:
			{
				if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
					found = FALSE;
				} else {
					ValaExpression* _tmp33_;
					ValaExpression* _tmp34_;
					_tmp33_ = vala_parser_parse_pointer_member_access (self, &begin, expr, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (expr);
							return NULL;
						} else {
							_vala_code_node_unref0 (expr);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					expr = (_tmp34_ = _tmp33_, _vala_code_node_unref0 (expr), _tmp34_);
				}
				break;
			}
			case VALA_TOKEN_TYPE_OPEN_PARENS:
			{
				ValaExpression* _tmp35_;
				ValaExpression* _tmp36_;
				_tmp35_ = vala_parser_parse_method_call (self, &begin, expr, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp36_ = _tmp35_, _vala_code_node_unref0 (expr), _tmp36_);
				break;
			}
			case VALA_TOKEN_TYPE_OPEN_BRACKET:
			{
				ValaExpression* _tmp37_;
				ValaExpression* _tmp38_;
				_tmp37_ = vala_parser_parse_element_access (self, &begin, expr, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp38_ = _tmp37_, _vala_code_node_unref0 (expr), _tmp38_);
				break;
			}
			case VALA_TOKEN_TYPE_OPEN_BRACE:
			{
				ValaExpression* _tmp39_;
				ValaMemberAccess* ma;
				gboolean _tmp40_ = FALSE;
				ma = _vala_code_node_ref0 ((_tmp39_ = expr, VALA_IS_MEMBER_ACCESS (_tmp39_) ? ((ValaMemberAccess*) _tmp39_) : NULL));
				if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
					_tmp40_ = ma != NULL;
				} else {
					_tmp40_ = FALSE;
				}
				if (_tmp40_) {
					ValaExpression* _tmp41_;
					ValaExpression* _tmp42_;
					_tmp41_ = vala_parser_parse_object_literal (self, &begin, ma, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (ma);
							_vala_code_node_unref0 (expr);
							return NULL;
						} else {
							_vala_code_node_unref0 (ma);
							_vala_code_node_unref0 (expr);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					expr = (_tmp42_ = _tmp41_, _vala_code_node_unref0 (expr), _tmp42_);
				} else {
					found = FALSE;
				}
				_vala_code_node_unref0 (ma);
				break;
			}
			case VALA_TOKEN_TYPE_OP_INC:
			{
				ValaExpression* _tmp43_;
				ValaExpression* _tmp44_;
				_tmp43_ = vala_parser_parse_post_increment_expression (self, &begin, expr, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp44_ = _tmp43_, _vala_code_node_unref0 (expr), _tmp44_);
				break;
			}
			case VALA_TOKEN_TYPE_OP_DEC:
			{
				ValaExpression* _tmp45_;
				ValaExpression* _tmp46_;
				_tmp45_ = vala_parser_parse_post_decrement_expression (self, &begin, expr, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				expr = (_tmp46_ = _tmp45_, _vala_code_node_unref0 (expr), _tmp46_);
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = expr;
	return result;
}


static ValaExpression* vala_parser_parse_simple_name (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	char* id;
	gboolean qualified;
	gboolean _tmp1_ = FALSE;
	ValaList* type_arg_list;
	ValaSourceReference* _tmp4_;
	ValaMemberAccess* _tmp5_;
	ValaMemberAccess* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	id = vala_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	qualified = FALSE;
	if (_vala_strcmp0 (id, "global") == 0) {
		_tmp1_ = vala_parser_accept (self, VALA_TOKEN_TYPE_DOUBLE_COLON);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		char* _tmp2_;
		char* _tmp3_;
		_tmp2_ = vala_parser_parse_identifier (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				return NULL;
			} else {
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		id = (_tmp3_ = _tmp2_, _g_free0 (id), _tmp3_);
		qualified = TRUE;
	}
	type_arg_list = vala_parser_parse_type_argument_list (self, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = (_tmp5_ = vala_member_access_new (NULL, id, _tmp4_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp4_), _tmp5_);
	vala_member_access_set_qualified (expr, qualified);
	if (type_arg_list != NULL) {
		{
			ValaIterator* _type_arg_it;
			_type_arg_it = vala_iterable_iterator ((ValaIterable*) type_arg_list);
			while (TRUE) {
				ValaDataType* type_arg;
				if (!vala_iterator_next (_type_arg_it)) {
					break;
				}
				type_arg = (ValaDataType*) vala_iterator_get (_type_arg_it);
				vala_member_access_add_type_argument (expr, type_arg);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_collection_object_unref0 (_type_arg_it);
		}
	}
	result = (ValaExpression*) expr;
	_vala_collection_object_unref0 (type_arg_list);
	_g_free0 (id);
	return result;
}


static ValaExpression* vala_parser_parse_tuple (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaArrayList* expr_list;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr_list = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				ValaExpression* _tmp2_;
				ValaExpression* _tmp3_;
				if (!_tmp1_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp1_ = FALSE;
				_tmp2_ = vala_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (expr_list);
						return NULL;
					} else {
						_vala_collection_object_unref0 (expr_list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) expr_list, _tmp3_ = _tmp2_);
				_vala_code_node_unref0 (_tmp3_);
			}
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (expr_list);
			return NULL;
		} else {
			_vala_collection_object_unref0 (expr_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_collection_get_size ((ValaCollection*) expr_list) != 1) {
		ValaSourceReference* _tmp4_;
		ValaTuple* _tmp5_;
		ValaTuple* tuple;
		tuple = (_tmp5_ = vala_tuple_new (_tmp4_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp4_), _tmp5_);
		{
			ValaIterator* _expr_it;
			_expr_it = vala_iterable_iterator ((ValaIterable*) expr_list);
			while (TRUE) {
				ValaExpression* expr;
				if (!vala_iterator_next (_expr_it)) {
					break;
				}
				expr = (ValaExpression*) vala_iterator_get (_expr_it);
				vala_tuple_add_expression (tuple, expr);
				_vala_code_node_unref0 (expr);
			}
			_vala_collection_object_unref0 (_expr_it);
		}
		result = (ValaExpression*) tuple;
		_vala_collection_object_unref0 (expr_list);
		return result;
	}
	result = (ValaExpression*) vala_list_get ((ValaList*) expr_list, 0);
	_vala_collection_object_unref0 (expr_list);
	return result;
}


static ValaExpression* vala_parser_parse_template (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaTemplate* template;
	ValaSourceReference* _tmp3_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	template = vala_template_new (NULL);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_TEMPLATE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (template);
			return NULL;
		} else {
			_vala_code_node_unref0 (template);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* _tmp1_;
		ValaExpression* _tmp2_;
		if (!(vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_TEMPLATE)) {
			break;
		}
		_tmp1_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (template);
				return NULL;
			} else {
				_vala_code_node_unref0 (template);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_template_add_expression (template, _tmp2_ = _tmp1_);
		_vala_code_node_unref0 (_tmp2_);
		vala_parser_expect (self, VALA_TOKEN_TYPE_COMMA, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (template);
				return NULL;
			} else {
				_vala_code_node_unref0 (template);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_TEMPLATE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (template);
			return NULL;
		} else {
			_vala_code_node_unref0 (template);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_code_node_set_source_reference ((ValaCodeNode*) template, _tmp3_ = vala_parser_get_src (self, &begin));
	_vala_source_reference_unref0 (_tmp3_);
	result = (ValaExpression*) template;
	return result;
}


static ValaExpression* vala_parser_parse_regex_literal (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_REGEX_LITERAL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = vala_parser_parse_literal (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = expr;
	return result;
}


static ValaExpression* vala_parser_parse_member_access (ValaParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	char* id;
	ValaList* type_arg_list;
	ValaSourceReference* _tmp0_;
	ValaMemberAccess* _tmp1_;
	ValaMemberAccess* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_parser_expect (self, VALA_TOKEN_TYPE_DOT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	id = vala_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_arg_list = vala_parser_parse_type_argument_list (self, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = (_tmp1_ = vala_member_access_new (inner, id, _tmp0_ = vala_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp0_), _tmp1_);
	if (type_arg_list != NULL) {
		{
			ValaIterator* _type_arg_it;
			_type_arg_it = vala_iterable_iterator ((ValaIterable*) type_arg_list);
			while (TRUE) {
				ValaDataType* type_arg;
				if (!vala_iterator_next (_type_arg_it)) {
					break;
				}
				type_arg = (ValaDataType*) vala_iterator_get (_type_arg_it);
				vala_member_access_add_type_argument (expr, type_arg);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_collection_object_unref0 (_type_arg_it);
		}
	}
	result = (ValaExpression*) expr;
	_vala_collection_object_unref0 (type_arg_list);
	_g_free0 (id);
	return result;
}


static ValaExpression* vala_parser_parse_pointer_member_access (ValaParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	char* id;
	ValaList* type_arg_list;
	ValaSourceReference* _tmp0_;
	ValaMemberAccess* _tmp1_;
	ValaMemberAccess* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OP_PTR, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	id = vala_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_arg_list = vala_parser_parse_type_argument_list (self, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = (_tmp1_ = vala_member_access_new_pointer (inner, id, _tmp0_ = vala_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp0_), _tmp1_);
	if (type_arg_list != NULL) {
		{
			ValaIterator* _type_arg_it;
			_type_arg_it = vala_iterable_iterator ((ValaIterable*) type_arg_list);
			while (TRUE) {
				ValaDataType* type_arg;
				if (!vala_iterator_next (_type_arg_it)) {
					break;
				}
				type_arg = (ValaDataType*) vala_iterator_get (_type_arg_it);
				vala_member_access_add_type_argument (expr, type_arg);
				_vala_code_node_unref0 (type_arg);
			}
			_vala_collection_object_unref0 (_type_arg_it);
		}
	}
	result = (ValaExpression*) expr;
	_vala_collection_object_unref0 (type_arg_list);
	_g_free0 (id);
	return result;
}


static ValaExpression* vala_parser_parse_method_call (ValaParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	ValaList* arg_list;
	ValaList* init_list;
	gboolean _tmp0_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	arg_list = vala_parser_parse_argument_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (arg_list);
			return NULL;
		} else {
			_vala_collection_object_unref0 (arg_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	init_list = vala_parser_parse_object_initializer (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (arg_list);
			return NULL;
		} else {
			_vala_collection_object_unref0 (arg_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_collection_get_size ((ValaCollection*) init_list) > 0) {
		_tmp0_ = VALA_IS_MEMBER_ACCESS (inner);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		ValaMemberAccess* member;
		ValaSourceReference* _tmp1_;
		ValaObjectCreationExpression* _tmp2_;
		ValaObjectCreationExpression* expr;
		member = _vala_code_node_ref0 (VALA_MEMBER_ACCESS (inner));
		vala_member_access_set_creation_member (member, TRUE);
		expr = (_tmp2_ = vala_object_creation_expression_new (member, _tmp1_ = vala_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
		vala_object_creation_expression_set_struct_creation (expr, TRUE);
		{
			ValaIterator* _arg_it;
			_arg_it = vala_iterable_iterator ((ValaIterable*) arg_list);
			while (TRUE) {
				ValaExpression* arg;
				if (!vala_iterator_next (_arg_it)) {
					break;
				}
				arg = (ValaExpression*) vala_iterator_get (_arg_it);
				vala_object_creation_expression_add_argument (expr, arg);
				_vala_code_node_unref0 (arg);
			}
			_vala_collection_object_unref0 (_arg_it);
		}
		{
			ValaIterator* _initializer_it;
			_initializer_it = vala_iterable_iterator ((ValaIterable*) init_list);
			while (TRUE) {
				ValaMemberInitializer* initializer;
				if (!vala_iterator_next (_initializer_it)) {
					break;
				}
				initializer = (ValaMemberInitializer*) vala_iterator_get (_initializer_it);
				vala_object_creation_expression_add_member_initializer (expr, initializer);
				_vala_code_node_unref0 (initializer);
			}
			_vala_collection_object_unref0 (_initializer_it);
		}
		result = (ValaExpression*) expr;
		_vala_code_node_unref0 (member);
		_vala_collection_object_unref0 (init_list);
		_vala_collection_object_unref0 (arg_list);
		return result;
	} else {
		ValaSourceReference* _tmp3_;
		ValaMethodCall* _tmp4_;
		ValaMethodCall* expr;
		expr = (_tmp4_ = vala_method_call_new (inner, _tmp3_ = vala_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
		{
			ValaIterator* _arg_it;
			_arg_it = vala_iterable_iterator ((ValaIterable*) arg_list);
			while (TRUE) {
				ValaExpression* arg;
				if (!vala_iterator_next (_arg_it)) {
					break;
				}
				arg = (ValaExpression*) vala_iterator_get (_arg_it);
				vala_method_call_add_argument (expr, arg);
				_vala_code_node_unref0 (arg);
			}
			_vala_collection_object_unref0 (_arg_it);
		}
		result = (ValaExpression*) expr;
		_vala_collection_object_unref0 (init_list);
		_vala_collection_object_unref0 (arg_list);
		return result;
	}
	_vala_collection_object_unref0 (init_list);
	_vala_collection_object_unref0 (arg_list);
}


static ValaExpression* vala_parser_parse_element_access (ValaParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	ValaList* index_list;
	ValaExpression* stop;
	gboolean _tmp0_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACKET, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	index_list = vala_parser_parse_expression_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	stop = NULL;
	if (vala_collection_get_size ((ValaCollection*) index_list) == 1) {
		_tmp0_ = vala_parser_accept (self, VALA_TOKEN_TYPE_COLON);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		ValaExpression* _tmp1_;
		ValaExpression* _tmp2_;
		_tmp1_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (stop);
				_vala_collection_object_unref0 (index_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (stop);
				_vala_collection_object_unref0 (index_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		stop = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (stop), _tmp2_);
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (stop);
			_vala_collection_object_unref0 (index_list);
			return NULL;
		} else {
			_vala_code_node_unref0 (stop);
			_vala_collection_object_unref0 (index_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (stop == NULL) {
		ValaSourceReference* _tmp3_;
		ValaElementAccess* _tmp4_;
		ValaElementAccess* expr;
		expr = (_tmp4_ = vala_element_access_new (inner, _tmp3_ = vala_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
		{
			ValaIterator* _index_it;
			_index_it = vala_iterable_iterator ((ValaIterable*) index_list);
			while (TRUE) {
				ValaExpression* index;
				if (!vala_iterator_next (_index_it)) {
					break;
				}
				index = (ValaExpression*) vala_iterator_get (_index_it);
				vala_element_access_append_index (expr, index);
				_vala_code_node_unref0 (index);
			}
			_vala_collection_object_unref0 (_index_it);
		}
		result = (ValaExpression*) expr;
		_vala_code_node_unref0 (stop);
		_vala_collection_object_unref0 (index_list);
		return result;
	} else {
		ValaExpression* _tmp5_;
		ValaSourceReference* _tmp6_;
		ValaExpression* _tmp7_;
		result = (_tmp7_ = (ValaExpression*) vala_slice_expression_new (inner, _tmp5_ = (ValaExpression*) vala_list_get (index_list, 0), stop, _tmp6_ = vala_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp6_), _vala_code_node_unref0 (_tmp5_), _tmp7_);
		_vala_code_node_unref0 (stop);
		_vala_collection_object_unref0 (index_list);
		return result;
	}
	_vala_code_node_unref0 (stop);
	_vala_collection_object_unref0 (index_list);
}


static ValaList* vala_parser_parse_expression_list (ValaParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	list = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	{
		gboolean _tmp0_;
		_tmp0_ = TRUE;
		while (TRUE) {
			ValaExpression* _tmp1_;
			ValaExpression* _tmp2_;
			if (!_tmp0_) {
				if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
					break;
				}
			}
			_tmp0_ = FALSE;
			_tmp1_ = vala_parser_parse_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (list);
					return NULL;
				} else {
					_vala_collection_object_unref0 (list);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			vala_collection_add ((ValaCollection*) list, _tmp2_ = _tmp1_);
			_vala_code_node_unref0 (_tmp2_);
		}
	}
	result = (ValaList*) list;
	return result;
}


static ValaExpression* vala_parser_parse_this_access (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaExpression* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_THIS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaExpression*) vala_member_access_new (NULL, "this", _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	return result;
}


static ValaExpression* vala_parser_parse_base_access (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaExpression* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_BASE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaExpression*) vala_base_access_new (_tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	return result;
}


static ValaExpression* vala_parser_parse_post_increment_expression (ValaParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceReference* _tmp0_;
	ValaExpression* _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OP_INC, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp1_ = (ValaExpression*) vala_postfix_expression_new (inner, TRUE, _tmp0_ = vala_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp0_), _tmp1_);
	return result;
}


static ValaExpression* vala_parser_parse_post_decrement_expression (ValaParser* self, ValaSourceLocation* begin, ValaExpression* inner, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceReference* _tmp0_;
	ValaExpression* _tmp1_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (inner != NULL, NULL);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OP_DEC, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp1_ = (ValaExpression*) vala_postfix_expression_new (inner, FALSE, _tmp0_ = vala_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp0_), _tmp1_);
	return result;
}


static ValaExpression* vala_parser_parse_object_or_array_creation_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaMemberAccess* member;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_NEW, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	member = vala_parser_parse_member_name (self, NULL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_OPEN_PARENS)) {
		ValaExpression* expr;
		expr = vala_parser_parse_object_creation_expression (self, &begin, member, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (member);
				return NULL;
			} else {
				_vala_code_node_unref0 (member);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = expr;
		_vala_code_node_unref0 (member);
		return result;
	} else {
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_OPEN_BRACKET)) {
			ValaExpression* expr;
			expr = vala_parser_parse_array_creation_expression (self, &begin, member, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (member);
					return NULL;
				} else {
					_vala_code_node_unref0 (member);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = expr;
			_vala_code_node_unref0 (member);
			return result;
		} else {
			char* _tmp1_;
			GError* _tmp2_;
			_inner_error_ = (_tmp2_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp1_ = vala_parser_get_error (self, "expected ( or [")), _g_free0 (_tmp1_), _tmp2_);
			{
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (member);
					return NULL;
				} else {
					_vala_code_node_unref0 (member);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	}
	_vala_code_node_unref0 (member);
}


static ValaExpression* vala_parser_parse_object_creation_expression (ValaParser* self, ValaSourceLocation* begin, ValaMemberAccess* member, GError** error) {
	ValaExpression* result = NULL;
	ValaList* arg_list;
	ValaList* init_list;
	ValaSourceReference* _tmp0_;
	ValaObjectCreationExpression* _tmp1_;
	ValaObjectCreationExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (member != NULL, NULL);
	vala_member_access_set_creation_member (member, TRUE);
	arg_list = vala_parser_parse_argument_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (arg_list);
			return NULL;
		} else {
			_vala_collection_object_unref0 (arg_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	init_list = vala_parser_parse_object_initializer (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (arg_list);
			return NULL;
		} else {
			_vala_collection_object_unref0 (arg_list);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = (_tmp1_ = vala_object_creation_expression_new (member, _tmp0_ = vala_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp0_), _tmp1_);
	{
		ValaIterator* _arg_it;
		_arg_it = vala_iterable_iterator ((ValaIterable*) arg_list);
		while (TRUE) {
			ValaExpression* arg;
			if (!vala_iterator_next (_arg_it)) {
				break;
			}
			arg = (ValaExpression*) vala_iterator_get (_arg_it);
			vala_object_creation_expression_add_argument (expr, arg);
			_vala_code_node_unref0 (arg);
		}
		_vala_collection_object_unref0 (_arg_it);
	}
	{
		ValaIterator* _initializer_it;
		_initializer_it = vala_iterable_iterator ((ValaIterable*) init_list);
		while (TRUE) {
			ValaMemberInitializer* initializer;
			if (!vala_iterator_next (_initializer_it)) {
				break;
			}
			initializer = (ValaMemberInitializer*) vala_iterator_get (_initializer_it);
			vala_object_creation_expression_add_member_initializer (expr, initializer);
			_vala_code_node_unref0 (initializer);
		}
		_vala_collection_object_unref0 (_initializer_it);
	}
	result = (ValaExpression*) expr;
	_vala_collection_object_unref0 (init_list);
	_vala_collection_object_unref0 (arg_list);
	return result;
}


static ValaExpression* vala_parser_parse_object_literal (ValaParser* self, ValaSourceLocation* begin, ValaMemberAccess* member, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceReference* _tmp0_;
	ValaObjectCreationExpression* _tmp1_;
	ValaObjectCreationExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (member != NULL, NULL);
	vala_member_access_set_creation_member (member, TRUE);
	expr = (_tmp1_ = vala_object_creation_expression_new (member, _tmp0_ = vala_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp0_), _tmp1_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	{
		gboolean _tmp2_;
		_tmp2_ = TRUE;
		while (TRUE) {
			ValaSourceLocation _tmp3_ = {0};
			ValaSourceLocation member_begin;
			char* id;
			ValaExpression* member_expr;
			ValaSourceReference* _tmp4_;
			ValaMemberInitializer* _tmp5_;
			if (!_tmp2_) {
				if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
					break;
				}
			}
			_tmp2_ = FALSE;
			member_begin = (vala_parser_get_location (self, &_tmp3_), _tmp3_);
			id = vala_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			vala_parser_expect (self, VALA_TOKEN_TYPE_COLON, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			member_expr = vala_parser_parse_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			vala_object_creation_expression_add_member_initializer (expr, _tmp5_ = vala_member_initializer_new (id, member_expr, _tmp4_ = vala_parser_get_src (self, &member_begin)));
			_vala_code_node_unref0 (_tmp5_);
			_vala_source_reference_unref0 (_tmp4_);
			_vala_code_node_unref0 (member_expr);
			_g_free0 (id);
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (ValaExpression*) expr;
	return result;
}


static ValaExpression* vala_parser_parse_array_creation_expression (ValaParser* self, ValaSourceLocation* begin, ValaMemberAccess* member, GError** error) {
	ValaExpression* result = NULL;
	gboolean size_specified;
	ValaList* size_specifier_list;
	gboolean first;
	ValaDataType* element_type;
	ValaInitializerList* initializer;
	gboolean _tmp10_ = FALSE;
	ValaSourceReference* _tmp13_;
	ValaArrayCreationExpression* _tmp14_;
	ValaArrayCreationExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (member != NULL, NULL);
	size_specified = FALSE;
	size_specifier_list = NULL;
	first = TRUE;
	element_type = (ValaDataType*) vala_unresolved_type_new_from_expression ((ValaExpression*) member);
	{
		gboolean _tmp0_;
		_tmp0_ = TRUE;
		while (TRUE) {
			ValaList* _tmp4_;
			if (!_tmp0_) {
				if (!vala_parser_accept (self, VALA_TOKEN_TYPE_OPEN_BRACKET)) {
					break;
				}
			}
			_tmp0_ = FALSE;
			if (!first) {
				ValaDataType* _tmp3_;
				if (size_specified) {
					char* _tmp1_;
					GError* _tmp2_;
					_inner_error_ = (_tmp2_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp1_ = vala_parser_get_error (self, "size of inner arrays must not be specified in array creation expressio" \
"n")), _g_free0 (_tmp1_), _tmp2_);
					{
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (element_type);
							_vala_collection_object_unref0 (size_specifier_list);
							return NULL;
						} else {
							_vala_code_node_unref0 (element_type);
							_vala_collection_object_unref0 (size_specifier_list);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				element_type = (_tmp3_ = (ValaDataType*) vala_array_type_new (element_type, vala_collection_get_size ((ValaCollection*) size_specifier_list), vala_code_node_get_source_reference ((ValaCodeNode*) element_type)), _vala_code_node_unref0 (element_type), _tmp3_);
			} else {
				first = FALSE;
			}
			size_specifier_list = (_tmp4_ = (ValaList*) vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal), _vala_collection_object_unref0 (size_specifier_list), _tmp4_);
			{
				gboolean _tmp5_;
				_tmp5_ = TRUE;
				while (TRUE) {
					ValaExpression* size;
					gboolean _tmp7_ = FALSE;
					if (!_tmp5_) {
						gboolean _tmp6_ = FALSE;
						if (vala_code_context_get_profile (self->priv->context) != VALA_PROFILE_DOVA) {
							_tmp6_ = vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA);
						} else {
							_tmp6_ = FALSE;
						}
						if (!_tmp6_) {
							break;
						}
					}
					_tmp5_ = FALSE;
					size = NULL;
					if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACKET) {
						_tmp7_ = vala_parser_current (self) != VALA_TOKEN_TYPE_COMMA;
					} else {
						_tmp7_ = FALSE;
					}
					if (_tmp7_) {
						ValaExpression* _tmp8_;
						ValaExpression* _tmp9_;
						_tmp8_ = vala_parser_parse_expression (self, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_code_node_unref0 (size);
								_vala_code_node_unref0 (element_type);
								_vala_collection_object_unref0 (size_specifier_list);
								return NULL;
							} else {
								_vala_code_node_unref0 (size);
								_vala_code_node_unref0 (element_type);
								_vala_collection_object_unref0 (size_specifier_list);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						size = (_tmp9_ = _tmp8_, _vala_code_node_unref0 (size), _tmp9_);
						size_specified = TRUE;
					}
					vala_collection_add ((ValaCollection*) size_specifier_list, size);
					_vala_code_node_unref0 (size);
				}
			}
			vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (element_type);
					_vala_collection_object_unref0 (size_specifier_list);
					return NULL;
				} else {
					_vala_code_node_unref0 (element_type);
					_vala_collection_object_unref0 (size_specifier_list);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	}
	initializer = NULL;
	if (vala_code_context_get_profile (self->priv->context) != VALA_PROFILE_DOVA) {
		_tmp10_ = vala_parser_current (self) == VALA_TOKEN_TYPE_OPEN_BRACE;
	} else {
		_tmp10_ = FALSE;
	}
	if (_tmp10_) {
		ValaInitializerList* _tmp11_;
		ValaInitializerList* _tmp12_;
		_tmp11_ = vala_parser_parse_initializer (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (element_type);
				_vala_collection_object_unref0 (size_specifier_list);
				return NULL;
			} else {
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (element_type);
				_vala_collection_object_unref0 (size_specifier_list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		initializer = (_tmp12_ = _tmp11_, _vala_code_node_unref0 (initializer), _tmp12_);
	}
	expr = (_tmp14_ = vala_array_creation_expression_new (element_type, vala_collection_get_size ((ValaCollection*) size_specifier_list), initializer, _tmp13_ = vala_parser_get_src (self, begin)), _vala_source_reference_unref0 (_tmp13_), _tmp14_);
	if (size_specified) {
		{
			ValaIterator* _size_it;
			_size_it = vala_iterable_iterator ((ValaIterable*) size_specifier_list);
			while (TRUE) {
				ValaExpression* size;
				if (!vala_iterator_next (_size_it)) {
					break;
				}
				size = (ValaExpression*) vala_iterator_get (_size_it);
				vala_array_creation_expression_append_size (expr, size);
				_vala_code_node_unref0 (size);
			}
			_vala_collection_object_unref0 (_size_it);
		}
	}
	result = (ValaExpression*) expr;
	_vala_code_node_unref0 (initializer);
	_vala_code_node_unref0 (element_type);
	_vala_collection_object_unref0 (size_specifier_list);
	return result;
}


static ValaList* vala_parser_parse_object_initializer (ValaParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list;
	gboolean _tmp0_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	list = vala_array_list_new (VALA_TYPE_MEMBER_INITIALIZER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_code_context_get_profile (self->priv->context) != VALA_PROFILE_DOVA) {
		_tmp0_ = vala_parser_accept (self, VALA_TOKEN_TYPE_OPEN_BRACE);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				ValaMemberInitializer* _tmp2_;
				ValaMemberInitializer* _tmp3_;
				if (!_tmp1_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp1_ = FALSE;
				_tmp2_ = vala_parser_parse_member_initializer (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (list);
						return NULL;
					} else {
						_vala_collection_object_unref0 (list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) list, _tmp3_ = _tmp2_);
				_vala_code_node_unref0 (_tmp3_);
			}
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (list);
				return NULL;
			} else {
				_vala_collection_object_unref0 (list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	result = (ValaList*) list;
	return result;
}


static ValaMemberInitializer* vala_parser_parse_member_initializer (ValaParser* self, GError** error) {
	ValaMemberInitializer* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	char* id;
	ValaExpression* expr;
	ValaSourceReference* _tmp1_;
	ValaMemberInitializer* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	id = vala_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_ASSIGN, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = vala_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = vala_member_initializer_new (id, expr, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (expr);
	_g_free0 (id);
	return result;
	_vala_code_node_unref0 (expr);
	_g_free0 (id);
}


static ValaExpression* vala_parser_parse_yield_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* base_expr;
	ValaMemberAccess* member;
	ValaExpression* _tmp3_;
	ValaMethodCall* call;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_YIELD, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	base_expr = NULL;
	if (vala_parser_current (self) == VALA_TOKEN_TYPE_BASE) {
		ValaExpression* _tmp1_;
		ValaExpression* _tmp2_;
		_tmp1_ = vala_parser_parse_base_access (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (base_expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (base_expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		base_expr = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (base_expr), _tmp2_);
		vala_parser_expect (self, VALA_TOKEN_TYPE_DOT, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (base_expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (base_expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	member = vala_parser_parse_member_name (self, base_expr, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (base_expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (base_expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp3_ = vala_parser_parse_method_call (self, &begin, (ValaExpression*) member, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (member);
			_vala_code_node_unref0 (base_expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (member);
			_vala_code_node_unref0 (base_expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	call = VALA_METHOD_CALL (_tmp3_);
	vala_method_call_set_is_yield_expression (call, TRUE);
	result = (ValaExpression*) call;
	_vala_code_node_unref0 (member);
	_vala_code_node_unref0 (base_expr);
	return result;
}


static ValaExpression* vala_parser_parse_sizeof_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaDataType* type;
	ValaSourceReference* _tmp1_;
	ValaExpression* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_SIZEOF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaExpression*) vala_sizeof_expression_new (type, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (type);
	return result;
	_vala_code_node_unref0 (type);
}


static ValaExpression* vala_parser_parse_typeof_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaDataType* type;
	ValaSourceReference* _tmp1_;
	ValaExpression* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_TYPEOF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaExpression*) vala_typeof_expression_new (type, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (type);
	return result;
	_vala_code_node_unref0 (type);
}


static ValaUnaryOperator vala_parser_get_unary_operator (ValaParser* self, ValaTokenType token_type) {
	ValaUnaryOperator result = 0;
	g_return_val_if_fail (self != NULL, 0);
	switch (token_type) {
		case VALA_TOKEN_TYPE_PLUS:
		{
			result = VALA_UNARY_OPERATOR_PLUS;
			return result;
		}
		case VALA_TOKEN_TYPE_MINUS:
		{
			result = VALA_UNARY_OPERATOR_MINUS;
			return result;
		}
		case VALA_TOKEN_TYPE_OP_NEG:
		{
			result = VALA_UNARY_OPERATOR_LOGICAL_NEGATION;
			return result;
		}
		case VALA_TOKEN_TYPE_TILDE:
		{
			result = VALA_UNARY_OPERATOR_BITWISE_COMPLEMENT;
			return result;
		}
		case VALA_TOKEN_TYPE_OP_INC:
		{
			result = VALA_UNARY_OPERATOR_INCREMENT;
			return result;
		}
		case VALA_TOKEN_TYPE_OP_DEC:
		{
			result = VALA_UNARY_OPERATOR_DECREMENT;
			return result;
		}
		default:
		{
			result = VALA_UNARY_OPERATOR_NONE;
			return result;
		}
	}
}


static ValaExpression* vala_parser_parse_unary_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaUnaryOperator operator;
	ValaExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	operator = vala_parser_get_unary_operator (self, vala_parser_current (self));
	if (operator != VALA_UNARY_OPERATOR_NONE) {
		ValaExpression* op;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		vala_parser_next (self);
		op = vala_parser_parse_unary_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = (_tmp2_ = (ValaExpression*) vala_unary_expression_new (operator, op, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
		_vala_code_node_unref0 (op);
		return result;
		_vala_code_node_unref0 (op);
	}
	switch (vala_parser_current (self)) {
		case VALA_TOKEN_TYPE_HASH:
		{
			ValaExpression* op;
			ValaSourceReference* _tmp4_;
			ValaExpression* _tmp5_;
			if (!vala_code_context_get_deprecated (self->priv->context)) {
				ValaSourceReference* _tmp3_;
				vala_report_warning (_tmp3_ = vala_parser_get_last_src (self), "deprecated syntax, use `(owned)` cast");
				_vala_source_reference_unref0 (_tmp3_);
			}
			vala_parser_next (self);
			op = vala_parser_parse_unary_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (_tmp5_ = (ValaExpression*) vala_reference_transfer_expression_new (op, _tmp4_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp4_), _tmp5_);
			_vala_code_node_unref0 (op);
			return result;
			_vala_code_node_unref0 (op);
		}
		case VALA_TOKEN_TYPE_OPEN_PARENS:
		{
			vala_parser_next (self);
			switch (vala_parser_current (self)) {
				case VALA_TOKEN_TYPE_OWNED:
				{
					vala_parser_next (self);
					if (vala_parser_accept (self, VALA_TOKEN_TYPE_CLOSE_PARENS)) {
						ValaExpression* op;
						ValaSourceReference* _tmp6_;
						ValaExpression* _tmp7_;
						op = vala_parser_parse_unary_expression (self, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								return NULL;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						result = (_tmp7_ = (ValaExpression*) vala_reference_transfer_expression_new (op, _tmp6_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp6_), _tmp7_);
						_vala_code_node_unref0 (op);
						return result;
						_vala_code_node_unref0 (op);
					}
					break;
				}
				case VALA_TOKEN_TYPE_VOID:
				case VALA_TOKEN_TYPE_DYNAMIC:
				case VALA_TOKEN_TYPE_IDENTIFIER:
				{
					ValaDataType* type;
					type = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							return NULL;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					if (vala_parser_accept (self, VALA_TOKEN_TYPE_CLOSE_PARENS)) {
						switch (vala_parser_current (self)) {
							case VALA_TOKEN_TYPE_OP_NEG:
							case VALA_TOKEN_TYPE_TILDE:
							case VALA_TOKEN_TYPE_OPEN_PARENS:
							case VALA_TOKEN_TYPE_TRUE:
							case VALA_TOKEN_TYPE_FALSE:
							case VALA_TOKEN_TYPE_INTEGER_LITERAL:
							case VALA_TOKEN_TYPE_REAL_LITERAL:
							case VALA_TOKEN_TYPE_CHARACTER_LITERAL:
							case VALA_TOKEN_TYPE_STRING_LITERAL:
							case VALA_TOKEN_TYPE_TEMPLATE_STRING_LITERAL:
							case VALA_TOKEN_TYPE_VERBATIM_STRING_LITERAL:
							case VALA_TOKEN_TYPE_REGEX_LITERAL:
							case VALA_TOKEN_TYPE_NULL:
							case VALA_TOKEN_TYPE_THIS:
							case VALA_TOKEN_TYPE_BASE:
							case VALA_TOKEN_TYPE_NEW:
							case VALA_TOKEN_TYPE_SIZEOF:
							case VALA_TOKEN_TYPE_TYPEOF:
							case VALA_TOKEN_TYPE_IDENTIFIER:
							case VALA_TOKEN_TYPE_PARAMS:
							{
								ValaExpression* inner;
								ValaSourceReference* _tmp8_;
								ValaExpression* _tmp9_;
								inner = vala_parser_parse_unary_expression (self, &_inner_error_);
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == VALA_PARSE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_vala_code_node_unref0 (type);
										return NULL;
									} else {
										_vala_code_node_unref0 (type);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return NULL;
									}
								}
								result = (_tmp9_ = (ValaExpression*) vala_cast_expression_new (inner, type, _tmp8_ = vala_parser_get_src (self, &begin), FALSE), _vala_source_reference_unref0 (_tmp8_), _tmp9_);
								_vala_code_node_unref0 (inner);
								_vala_code_node_unref0 (type);
								return result;
								_vala_code_node_unref0 (inner);
							}
							default:
							{
								break;
							}
						}
					}
					_vala_code_node_unref0 (type);
					break;
				}
				case VALA_TOKEN_TYPE_OP_NEG:
				{
					vala_parser_next (self);
					if (vala_parser_accept (self, VALA_TOKEN_TYPE_CLOSE_PARENS)) {
						ValaExpression* inner;
						ValaSourceReference* _tmp10_;
						ValaExpression* _tmp11_;
						inner = vala_parser_parse_unary_expression (self, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								return NULL;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						result = (_tmp11_ = (ValaExpression*) vala_cast_expression_new_non_null (inner, _tmp10_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp10_), _tmp11_);
						_vala_code_node_unref0 (inner);
						return result;
						_vala_code_node_unref0 (inner);
					}
					break;
				}
				default:
				{
					break;
				}
			}
			vala_parser_rollback (self, &begin);
			break;
		}
		case VALA_TOKEN_TYPE_STAR:
		{
			ValaExpression* op;
			ValaSourceReference* _tmp12_;
			ValaExpression* _tmp13_;
			vala_parser_next (self);
			op = vala_parser_parse_unary_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (_tmp13_ = (ValaExpression*) vala_pointer_indirection_new (op, _tmp12_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp12_), _tmp13_);
			_vala_code_node_unref0 (op);
			return result;
			_vala_code_node_unref0 (op);
		}
		case VALA_TOKEN_TYPE_BITWISE_AND:
		{
			ValaExpression* op;
			ValaSourceReference* _tmp14_;
			ValaExpression* _tmp15_;
			vala_parser_next (self);
			op = vala_parser_parse_unary_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (_tmp15_ = (ValaExpression*) vala_addressof_expression_new (op, _tmp14_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp14_), _tmp15_);
			_vala_code_node_unref0 (op);
			return result;
			_vala_code_node_unref0 (op);
		}
		default:
		{
			break;
		}
	}
	expr = vala_parser_parse_primary_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = expr;
	return result;
}


static ValaBinaryOperator vala_parser_get_binary_operator (ValaParser* self, ValaTokenType token_type) {
	ValaBinaryOperator result = 0;
	g_return_val_if_fail (self != NULL, 0);
	switch (token_type) {
		case VALA_TOKEN_TYPE_STAR:
		{
			result = VALA_BINARY_OPERATOR_MUL;
			return result;
		}
		case VALA_TOKEN_TYPE_DIV:
		{
			result = VALA_BINARY_OPERATOR_DIV;
			return result;
		}
		case VALA_TOKEN_TYPE_PERCENT:
		{
			result = VALA_BINARY_OPERATOR_MOD;
			return result;
		}
		case VALA_TOKEN_TYPE_PLUS:
		{
			result = VALA_BINARY_OPERATOR_PLUS;
			return result;
		}
		case VALA_TOKEN_TYPE_MINUS:
		{
			result = VALA_BINARY_OPERATOR_MINUS;
			return result;
		}
		case VALA_TOKEN_TYPE_OP_LT:
		{
			result = VALA_BINARY_OPERATOR_LESS_THAN;
			return result;
		}
		case VALA_TOKEN_TYPE_OP_GT:
		{
			result = VALA_BINARY_OPERATOR_GREATER_THAN;
			return result;
		}
		case VALA_TOKEN_TYPE_OP_LE:
		{
			result = VALA_BINARY_OPERATOR_LESS_THAN_OR_EQUAL;
			return result;
		}
		case VALA_TOKEN_TYPE_OP_GE:
		{
			result = VALA_BINARY_OPERATOR_GREATER_THAN_OR_EQUAL;
			return result;
		}
		case VALA_TOKEN_TYPE_OP_EQ:
		{
			result = VALA_BINARY_OPERATOR_EQUALITY;
			return result;
		}
		case VALA_TOKEN_TYPE_OP_NE:
		{
			result = VALA_BINARY_OPERATOR_INEQUALITY;
			return result;
		}
		default:
		{
			result = VALA_BINARY_OPERATOR_NONE;
			return result;
		}
	}
}


static ValaExpression* vala_parser_parse_multiplicative_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	gboolean found;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_parser_parse_unary_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		ValaBinaryOperator operator;
		if (!found) {
			break;
		}
		operator = vala_parser_get_binary_operator (self, vala_parser_current (self));
		switch (operator) {
			case VALA_BINARY_OPERATOR_MUL:
			case VALA_BINARY_OPERATOR_DIV:
			case VALA_BINARY_OPERATOR_MOD:
			{
				ValaExpression* right;
				ValaSourceReference* _tmp1_;
				ValaExpression* _tmp2_;
				vala_parser_next (self);
				right = vala_parser_parse_unary_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (operator, left, right, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
				_vala_source_reference_unref0 (_tmp1_);
				_vala_code_node_unref0 (right);
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_parser_parse_additive_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	gboolean found;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_parser_parse_multiplicative_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		ValaBinaryOperator operator;
		if (!found) {
			break;
		}
		operator = vala_parser_get_binary_operator (self, vala_parser_current (self));
		switch (operator) {
			case VALA_BINARY_OPERATOR_PLUS:
			case VALA_BINARY_OPERATOR_MINUS:
			{
				ValaExpression* right;
				ValaSourceReference* _tmp1_;
				ValaExpression* _tmp2_;
				vala_parser_next (self);
				right = vala_parser_parse_multiplicative_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (operator, left, right, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
				_vala_source_reference_unref0 (_tmp1_);
				_vala_code_node_unref0 (right);
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_parser_parse_shift_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	gboolean found;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_parser_parse_additive_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		if (!found) {
			break;
		}
		switch (vala_parser_current (self)) {
			case VALA_TOKEN_TYPE_OP_SHIFT_LEFT:
			{
				ValaExpression* right;
				ValaSourceReference* _tmp1_;
				ValaExpression* _tmp2_;
				vala_parser_next (self);
				right = vala_parser_parse_additive_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_SHIFT_LEFT, left, right, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
				_vala_source_reference_unref0 (_tmp1_);
				_vala_code_node_unref0 (right);
				break;
			}
			case VALA_TOKEN_TYPE_OP_GT:
			{
				gchar* first_gt_pos;
				gboolean _tmp3_ = FALSE;
				first_gt_pos = self->priv->tokens[self->priv->index].begin.pos;
				vala_parser_next (self);
				if (vala_parser_current (self) == VALA_TOKEN_TYPE_OP_GT) {
					_tmp3_ = self->priv->tokens[self->priv->index].begin.pos == (first_gt_pos + 1);
				} else {
					_tmp3_ = FALSE;
				}
				if (_tmp3_) {
					ValaExpression* right;
					ValaSourceReference* _tmp4_;
					ValaExpression* _tmp5_;
					vala_parser_next (self);
					right = vala_parser_parse_additive_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (left);
							return NULL;
						} else {
							_vala_code_node_unref0 (left);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					left = (_tmp5_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_SHIFT_RIGHT, left, right, _tmp4_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp5_);
					_vala_source_reference_unref0 (_tmp4_);
					_vala_code_node_unref0 (right);
				} else {
					vala_parser_prev (self);
					found = FALSE;
				}
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_parser_parse_relational_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	gboolean first;
	gboolean found;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_parser_parse_shift_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	first = TRUE;
	found = TRUE;
	while (TRUE) {
		ValaBinaryOperator operator;
		if (!found) {
			break;
		}
		operator = vala_parser_get_binary_operator (self, vala_parser_current (self));
		switch (operator) {
			case VALA_BINARY_OPERATOR_LESS_THAN:
			case VALA_BINARY_OPERATOR_LESS_THAN_OR_EQUAL:
			case VALA_BINARY_OPERATOR_GREATER_THAN_OR_EQUAL:
			{
				ValaExpression* right;
				ValaSourceReference* _tmp1_;
				ValaExpression* _tmp2_;
				vala_parser_next (self);
				right = vala_parser_parse_shift_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (operator, left, right, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
				_vala_source_reference_unref0 (_tmp1_);
				if (!first) {
					ValaBinaryExpression* be;
					be = _vala_code_node_ref0 (VALA_BINARY_EXPRESSION (left));
					be->chained = TRUE;
					if (!vala_code_context_get_experimental (self->priv->context)) {
						vala_report_warning (vala_code_node_get_source_reference ((ValaCodeNode*) left), "chained relational expressions are experimental");
					}
					_vala_code_node_unref0 (be);
				}
				first = FALSE;
				_vala_code_node_unref0 (right);
				break;
			}
			case VALA_BINARY_OPERATOR_GREATER_THAN:
			{
				gboolean _tmp3_ = FALSE;
				vala_parser_next (self);
				if (vala_parser_current (self) != VALA_TOKEN_TYPE_OP_GT) {
					_tmp3_ = vala_parser_current (self) != VALA_TOKEN_TYPE_OP_GE;
				} else {
					_tmp3_ = FALSE;
				}
				if (_tmp3_) {
					ValaExpression* right;
					ValaSourceReference* _tmp4_;
					ValaExpression* _tmp5_;
					right = vala_parser_parse_shift_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (left);
							return NULL;
						} else {
							_vala_code_node_unref0 (left);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					left = (_tmp5_ = (ValaExpression*) vala_binary_expression_new (operator, left, right, _tmp4_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp5_);
					_vala_source_reference_unref0 (_tmp4_);
					if (!first) {
						ValaBinaryExpression* be;
						be = _vala_code_node_ref0 (VALA_BINARY_EXPRESSION (left));
						be->chained = TRUE;
						if (!vala_code_context_get_experimental (self->priv->context)) {
							vala_report_warning (vala_code_node_get_source_reference ((ValaCodeNode*) left), "chained relational expressions are experimental");
						}
						_vala_code_node_unref0 (be);
					}
					first = FALSE;
					_vala_code_node_unref0 (right);
				} else {
					vala_parser_prev (self);
					found = FALSE;
				}
				break;
			}
			default:
			{
				switch (vala_parser_current (self)) {
					case VALA_TOKEN_TYPE_IS:
					{
						ValaDataType* type;
						ValaSourceReference* _tmp6_;
						ValaExpression* _tmp7_;
						vala_parser_next (self);
						type = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_code_node_unref0 (left);
								return NULL;
							} else {
								_vala_code_node_unref0 (left);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						left = (_tmp7_ = (ValaExpression*) vala_typecheck_new (left, type, _tmp6_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp7_);
						_vala_source_reference_unref0 (_tmp6_);
						_vala_code_node_unref0 (type);
						break;
					}
					case VALA_TOKEN_TYPE_AS:
					{
						ValaDataType* type;
						ValaSourceReference* _tmp8_;
						ValaExpression* _tmp9_;
						vala_parser_next (self);
						type = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_code_node_unref0 (left);
								return NULL;
							} else {
								_vala_code_node_unref0 (left);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						left = (_tmp9_ = (ValaExpression*) vala_cast_expression_new (left, type, _tmp8_ = vala_parser_get_src (self, &begin), TRUE), _vala_code_node_unref0 (left), _tmp9_);
						_vala_source_reference_unref0 (_tmp8_);
						_vala_code_node_unref0 (type);
						break;
					}
					default:
					{
						found = FALSE;
						break;
					}
				}
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_parser_parse_equality_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	gboolean found;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_parser_parse_relational_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	found = TRUE;
	while (TRUE) {
		ValaBinaryOperator operator;
		if (!found) {
			break;
		}
		operator = vala_parser_get_binary_operator (self, vala_parser_current (self));
		switch (operator) {
			case VALA_BINARY_OPERATOR_EQUALITY:
			case VALA_BINARY_OPERATOR_INEQUALITY:
			{
				ValaExpression* right;
				ValaSourceReference* _tmp1_;
				ValaExpression* _tmp2_;
				vala_parser_next (self);
				right = vala_parser_parse_relational_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (left);
						return NULL;
					} else {
						_vala_code_node_unref0 (left);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (operator, left, right, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
				_vala_source_reference_unref0 (_tmp1_);
				_vala_code_node_unref0 (right);
				break;
			}
			default:
			{
				found = FALSE;
				break;
			}
		}
	}
	result = left;
	return result;
}


static ValaExpression* vala_parser_parse_and_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_parser_parse_equality_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_BITWISE_AND)) {
			break;
		}
		right = vala_parser_parse_equality_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_BITWISE_AND, left, right, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_parser_parse_exclusive_or_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_parser_parse_and_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_CARRET)) {
			break;
		}
		right = vala_parser_parse_and_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_BITWISE_XOR, left, right, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_parser_parse_inclusive_or_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_parser_parse_exclusive_or_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_BITWISE_OR)) {
			break;
		}
		right = vala_parser_parse_exclusive_or_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_BITWISE_OR, left, right, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_parser_parse_in_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_parser_parse_inclusive_or_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_IN)) {
			break;
		}
		right = vala_parser_parse_inclusive_or_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_IN, left, right, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_parser_parse_conditional_and_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_parser_parse_in_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_OP_AND)) {
			break;
		}
		right = vala_parser_parse_in_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_AND, left, right, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_parser_parse_conditional_or_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_parser_parse_conditional_and_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_OP_OR)) {
			break;
		}
		right = vala_parser_parse_conditional_and_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		left = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_OR, left, right, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (left), _tmp2_);
		_vala_source_reference_unref0 (_tmp1_);
		_vala_code_node_unref0 (right);
	}
	result = left;
	return result;
}


static ValaExpression* vala_parser_parse_coalescing_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* left;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	left = vala_parser_parse_conditional_or_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_OP_COALESCING)) {
		ValaExpression* right;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		right = vala_parser_parse_coalescing_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (left);
				return NULL;
			} else {
				_vala_code_node_unref0 (left);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = (_tmp2_ = (ValaExpression*) vala_binary_expression_new (VALA_BINARY_OPERATOR_COALESCE, left, right, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
		_vala_code_node_unref0 (right);
		_vala_code_node_unref0 (left);
		return result;
		_vala_code_node_unref0 (right);
	} else {
		result = left;
		return result;
	}
	_vala_code_node_unref0 (left);
}


static ValaExpression* vala_parser_parse_conditional_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* condition;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	condition = vala_parser_parse_coalescing_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_INTERR)) {
		ValaExpression* true_expr;
		ValaExpression* false_expr;
		ValaSourceReference* _tmp1_;
		ValaExpression* _tmp2_;
		true_expr = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_COLON, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (true_expr);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (true_expr);
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		false_expr = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (true_expr);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (true_expr);
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = (_tmp2_ = (ValaExpression*) vala_conditional_expression_new (condition, true_expr, false_expr, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
		_vala_code_node_unref0 (false_expr);
		_vala_code_node_unref0 (true_expr);
		_vala_code_node_unref0 (condition);
		return result;
		_vala_code_node_unref0 (false_expr);
		_vala_code_node_unref0 (true_expr);
	} else {
		result = condition;
		return result;
	}
	_vala_code_node_unref0 (condition);
}


static ValaExpression* vala_parser_parse_lambda_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaList* params;
	ValaLambdaExpression* lambda;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	params = (ValaList*) vala_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, g_free, g_direct_equal);
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_OPEN_PARENS)) {
		if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_PARENS) {
			{
				gboolean _tmp1_;
				_tmp1_ = TRUE;
				while (TRUE) {
					char* _tmp2_;
					char* _tmp3_;
					if (!_tmp1_) {
						if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp1_ = FALSE;
					_tmp2_ = vala_parser_parse_identifier (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_collection_object_unref0 (params);
							return NULL;
						} else {
							_vala_collection_object_unref0 (params);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_collection_add ((ValaCollection*) params, _tmp3_ = _tmp2_);
					_g_free0 (_tmp3_);
				}
			}
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (params);
				return NULL;
			} else {
				_vala_collection_object_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		char* _tmp4_;
		char* _tmp5_;
		_tmp4_ = vala_parser_parse_identifier (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (params);
				return NULL;
			} else {
				_vala_collection_object_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_collection_add ((ValaCollection*) params, _tmp5_ = _tmp4_);
		_g_free0 (_tmp5_);
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_LAMBDA, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (params);
			return NULL;
		} else {
			_vala_collection_object_unref0 (params);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	lambda = NULL;
	if (vala_parser_current (self) == VALA_TOKEN_TYPE_OPEN_BRACE) {
		ValaBlock* block;
		ValaSourceReference* _tmp6_;
		ValaLambdaExpression* _tmp7_;
		block = vala_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (lambda);
				_vala_collection_object_unref0 (params);
				return NULL;
			} else {
				_vala_code_node_unref0 (lambda);
				_vala_collection_object_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		lambda = (_tmp7_ = vala_lambda_expression_new_with_statement_body (block, _tmp6_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (lambda), _tmp7_);
		_vala_source_reference_unref0 (_tmp6_);
		_vala_code_node_unref0 (block);
	} else {
		ValaExpression* expr;
		ValaSourceReference* _tmp8_;
		ValaLambdaExpression* _tmp9_;
		expr = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (lambda);
				_vala_collection_object_unref0 (params);
				return NULL;
			} else {
				_vala_code_node_unref0 (lambda);
				_vala_collection_object_unref0 (params);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		lambda = (_tmp9_ = vala_lambda_expression_new (expr, _tmp8_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (lambda), _tmp9_);
		_vala_source_reference_unref0 (_tmp8_);
		_vala_code_node_unref0 (expr);
	}
	{
		ValaIterator* _param_it;
		_param_it = vala_iterable_iterator ((ValaIterable*) params);
		while (TRUE) {
			char* param;
			if (!vala_iterator_next (_param_it)) {
				break;
			}
			param = (char*) vala_iterator_get (_param_it);
			vala_lambda_expression_add_parameter (lambda, param);
			_g_free0 (param);
		}
		_vala_collection_object_unref0 (_param_it);
	}
	result = (ValaExpression*) lambda;
	_vala_collection_object_unref0 (params);
	return result;
}


static ValaAssignmentOperator vala_parser_get_assignment_operator (ValaParser* self, ValaTokenType token_type) {
	ValaAssignmentOperator result = 0;
	g_return_val_if_fail (self != NULL, 0);
	switch (token_type) {
		case VALA_TOKEN_TYPE_ASSIGN:
		{
			result = VALA_ASSIGNMENT_OPERATOR_SIMPLE;
			return result;
		}
		case VALA_TOKEN_TYPE_ASSIGN_ADD:
		{
			result = VALA_ASSIGNMENT_OPERATOR_ADD;
			return result;
		}
		case VALA_TOKEN_TYPE_ASSIGN_SUB:
		{
			result = VALA_ASSIGNMENT_OPERATOR_SUB;
			return result;
		}
		case VALA_TOKEN_TYPE_ASSIGN_BITWISE_OR:
		{
			result = VALA_ASSIGNMENT_OPERATOR_BITWISE_OR;
			return result;
		}
		case VALA_TOKEN_TYPE_ASSIGN_BITWISE_AND:
		{
			result = VALA_ASSIGNMENT_OPERATOR_BITWISE_AND;
			return result;
		}
		case VALA_TOKEN_TYPE_ASSIGN_BITWISE_XOR:
		{
			result = VALA_ASSIGNMENT_OPERATOR_BITWISE_XOR;
			return result;
		}
		case VALA_TOKEN_TYPE_ASSIGN_DIV:
		{
			result = VALA_ASSIGNMENT_OPERATOR_DIV;
			return result;
		}
		case VALA_TOKEN_TYPE_ASSIGN_MUL:
		{
			result = VALA_ASSIGNMENT_OPERATOR_MUL;
			return result;
		}
		case VALA_TOKEN_TYPE_ASSIGN_PERCENT:
		{
			result = VALA_ASSIGNMENT_OPERATOR_PERCENT;
			return result;
		}
		case VALA_TOKEN_TYPE_ASSIGN_SHIFT_LEFT:
		{
			result = VALA_ASSIGNMENT_OPERATOR_SHIFT_LEFT;
			return result;
		}
		default:
		{
			result = VALA_ASSIGNMENT_OPERATOR_NONE;
			return result;
		}
	}
}


static ValaExpression* vala_parser_parse_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	expr = vala_parser_parse_conditional_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_parser_current (self) == VALA_TOKEN_TYPE_LAMBDA) {
		ValaExpression* lambda;
		vala_parser_rollback (self, &begin);
		lambda = vala_parser_parse_lambda_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = lambda;
		_vala_code_node_unref0 (expr);
		return result;
	}
	while (TRUE) {
		ValaAssignmentOperator operator;
		operator = vala_parser_get_assignment_operator (self, vala_parser_current (self));
		if (operator != VALA_ASSIGNMENT_OPERATOR_NONE) {
			ValaExpression* rhs;
			ValaSourceReference* _tmp1_;
			ValaExpression* _tmp2_;
			vala_parser_next (self);
			rhs = vala_parser_parse_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			expr = (_tmp2_ = (ValaExpression*) vala_assignment_new (expr, rhs, operator, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (expr), _tmp2_);
			_vala_source_reference_unref0 (_tmp1_);
			_vala_code_node_unref0 (rhs);
		} else {
			if (vala_parser_current (self) == VALA_TOKEN_TYPE_OP_GT) {
				gchar* first_gt_pos;
				gboolean _tmp3_ = FALSE;
				first_gt_pos = self->priv->tokens[self->priv->index].begin.pos;
				vala_parser_next (self);
				if (vala_parser_current (self) == VALA_TOKEN_TYPE_OP_GE) {
					_tmp3_ = self->priv->tokens[self->priv->index].begin.pos == (first_gt_pos + 1);
				} else {
					_tmp3_ = FALSE;
				}
				if (_tmp3_) {
					ValaExpression* rhs;
					ValaSourceReference* _tmp4_;
					ValaExpression* _tmp5_;
					vala_parser_next (self);
					rhs = vala_parser_parse_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (expr);
							return NULL;
						} else {
							_vala_code_node_unref0 (expr);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					expr = (_tmp5_ = (ValaExpression*) vala_assignment_new (expr, rhs, VALA_ASSIGNMENT_OPERATOR_SHIFT_RIGHT, _tmp4_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (expr), _tmp5_);
					_vala_source_reference_unref0 (_tmp4_);
					_vala_code_node_unref0 (rhs);
				} else {
					vala_parser_prev (self);
					break;
				}
			} else {
				break;
			}
		}
	}
	result = expr;
	return result;
}


static void vala_parser_parse_statements (ValaParser* self, ValaBlock* block, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (block != NULL);
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		gboolean _tmp1_ = FALSE;
		gboolean _tmp2_ = FALSE;
		if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACE) {
			_tmp2_ = vala_parser_current (self) != VALA_TOKEN_TYPE_CASE;
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			_tmp1_ = vala_parser_current (self) != VALA_TOKEN_TYPE_DEFAULT;
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			_tmp0_ = vala_parser_current (self) != VALA_TOKEN_TYPE_EOF;
		} else {
			_tmp0_ = FALSE;
		}
		if (!_tmp0_) {
			break;
		}
		{
			ValaStatement* stmt;
			gboolean is_decl;
			ValaComment* _tmp3_;
			stmt = NULL;
			is_decl = FALSE;
			self->priv->comment = (_tmp3_ = vala_scanner_pop_comment (self->priv->scanner), _vala_comment_unref0 (self->priv->comment), _tmp3_);
			switch (vala_parser_current (self)) {
				case VALA_TOKEN_TYPE_OPEN_BRACE:
				{
					ValaBlock* _tmp4_;
					ValaStatement* _tmp5_;
					_tmp4_ = vala_parser_parse_block (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp5_ = (ValaStatement*) _tmp4_, _vala_code_node_unref0 (stmt), _tmp5_);
					break;
				}
				case VALA_TOKEN_TYPE_SEMICOLON:
				{
					ValaStatement* _tmp6_;
					ValaStatement* _tmp7_;
					_tmp6_ = vala_parser_parse_empty_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp7_ = _tmp6_, _vala_code_node_unref0 (stmt), _tmp7_);
					break;
				}
				case VALA_TOKEN_TYPE_IF:
				{
					ValaStatement* _tmp8_;
					ValaStatement* _tmp9_;
					_tmp8_ = vala_parser_parse_if_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp9_ = _tmp8_, _vala_code_node_unref0 (stmt), _tmp9_);
					break;
				}
				case VALA_TOKEN_TYPE_SWITCH:
				{
					ValaStatement* _tmp10_;
					ValaStatement* _tmp11_;
					_tmp10_ = vala_parser_parse_switch_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp11_ = _tmp10_, _vala_code_node_unref0 (stmt), _tmp11_);
					break;
				}
				case VALA_TOKEN_TYPE_WHILE:
				{
					ValaStatement* _tmp12_;
					ValaStatement* _tmp13_;
					_tmp12_ = vala_parser_parse_while_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp13_ = _tmp12_, _vala_code_node_unref0 (stmt), _tmp13_);
					break;
				}
				case VALA_TOKEN_TYPE_DO:
				{
					ValaStatement* _tmp14_;
					ValaStatement* _tmp15_;
					_tmp14_ = vala_parser_parse_do_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp15_ = _tmp14_, _vala_code_node_unref0 (stmt), _tmp15_);
					break;
				}
				case VALA_TOKEN_TYPE_FOR:
				{
					ValaStatement* _tmp16_;
					ValaStatement* _tmp17_;
					_tmp16_ = vala_parser_parse_for_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp17_ = _tmp16_, _vala_code_node_unref0 (stmt), _tmp17_);
					break;
				}
				case VALA_TOKEN_TYPE_FOREACH:
				{
					ValaStatement* _tmp18_;
					ValaStatement* _tmp19_;
					_tmp18_ = vala_parser_parse_foreach_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp19_ = _tmp18_, _vala_code_node_unref0 (stmt), _tmp19_);
					break;
				}
				case VALA_TOKEN_TYPE_BREAK:
				{
					ValaStatement* _tmp20_;
					ValaStatement* _tmp21_;
					_tmp20_ = vala_parser_parse_break_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp21_ = _tmp20_, _vala_code_node_unref0 (stmt), _tmp21_);
					break;
				}
				case VALA_TOKEN_TYPE_CONTINUE:
				{
					ValaStatement* _tmp22_;
					ValaStatement* _tmp23_;
					_tmp22_ = vala_parser_parse_continue_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp23_ = _tmp22_, _vala_code_node_unref0 (stmt), _tmp23_);
					break;
				}
				case VALA_TOKEN_TYPE_RETURN:
				{
					ValaStatement* _tmp24_;
					ValaStatement* _tmp25_;
					_tmp24_ = vala_parser_parse_return_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp25_ = _tmp24_, _vala_code_node_unref0 (stmt), _tmp25_);
					break;
				}
				case VALA_TOKEN_TYPE_YIELD:
				{
					ValaStatement* _tmp26_;
					ValaStatement* _tmp27_;
					_tmp26_ = vala_parser_parse_yield_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp27_ = _tmp26_, _vala_code_node_unref0 (stmt), _tmp27_);
					break;
				}
				case VALA_TOKEN_TYPE_THROW:
				{
					ValaStatement* _tmp28_;
					ValaStatement* _tmp29_;
					_tmp28_ = vala_parser_parse_throw_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp29_ = _tmp28_, _vala_code_node_unref0 (stmt), _tmp29_);
					break;
				}
				case VALA_TOKEN_TYPE_TRY:
				{
					ValaStatement* _tmp30_;
					ValaStatement* _tmp31_;
					_tmp30_ = vala_parser_parse_try_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp31_ = _tmp30_, _vala_code_node_unref0 (stmt), _tmp31_);
					break;
				}
				case VALA_TOKEN_TYPE_LOCK:
				{
					ValaStatement* _tmp32_;
					ValaStatement* _tmp33_;
					_tmp32_ = vala_parser_parse_lock_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp33_ = _tmp32_, _vala_code_node_unref0 (stmt), _tmp33_);
					break;
				}
				case VALA_TOKEN_TYPE_DELETE:
				{
					ValaStatement* _tmp34_;
					ValaStatement* _tmp35_;
					_tmp34_ = vala_parser_parse_delete_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp35_ = _tmp34_, _vala_code_node_unref0 (stmt), _tmp35_);
					break;
				}
				case VALA_TOKEN_TYPE_VAR:
				{
					is_decl = TRUE;
					vala_parser_parse_local_variable_declarations (self, block, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					break;
				}
				case VALA_TOKEN_TYPE_OP_INC:
				case VALA_TOKEN_TYPE_OP_DEC:
				case VALA_TOKEN_TYPE_BASE:
				case VALA_TOKEN_TYPE_THIS:
				case VALA_TOKEN_TYPE_OPEN_PARENS:
				case VALA_TOKEN_TYPE_STAR:
				case VALA_TOKEN_TYPE_NEW:
				{
					ValaStatement* _tmp36_;
					ValaStatement* _tmp37_;
					_tmp36_ = vala_parser_parse_expression_statement (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					stmt = (_tmp37_ = _tmp36_, _vala_code_node_unref0 (stmt), _tmp37_);
					break;
				}
				default:
				{
					gboolean is_expr;
					is_expr = vala_parser_is_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						_vala_code_node_unref0 (stmt);
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch6_vala_parse_error;
						}
						_vala_code_node_unref0 (stmt);
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
					if (is_expr) {
						ValaStatement* _tmp38_;
						ValaStatement* _tmp39_;
						_tmp38_ = vala_parser_parse_expression_statement (self, &_inner_error_);
						if (_inner_error_ != NULL) {
							_vala_code_node_unref0 (stmt);
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch6_vala_parse_error;
							}
							_vala_code_node_unref0 (stmt);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
						stmt = (_tmp39_ = _tmp38_, _vala_code_node_unref0 (stmt), _tmp39_);
					} else {
						is_decl = TRUE;
						vala_parser_parse_local_variable_declarations (self, block, &_inner_error_);
						if (_inner_error_ != NULL) {
							_vala_code_node_unref0 (stmt);
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch6_vala_parse_error;
							}
							_vala_code_node_unref0 (stmt);
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					}
					break;
				}
			}
			if (!is_decl) {
				gboolean _tmp40_ = FALSE;
				if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
					_tmp40_ = VALA_IS_RETURN_STATEMENT (stmt);
				} else {
					_tmp40_ = FALSE;
				}
				if (_tmp40_) {
					ValaReturnStatement* ret_stmt;
					ret_stmt = _vala_code_node_ref0 (VALA_RETURN_STATEMENT (stmt));
					if (vala_return_statement_get_return_expression (ret_stmt) != NULL) {
						ValaMemberAccess* _tmp41_;
						ValaAssignment* _tmp42_;
						ValaAssignment* assignment;
						ValaExpressionStatement* _tmp43_;
						assignment = (_tmp42_ = vala_assignment_new ((ValaExpression*) (_tmp41_ = vala_member_access_new_simple ("result", vala_code_node_get_source_reference ((ValaCodeNode*) stmt))), vala_return_statement_get_return_expression (ret_stmt), VALA_ASSIGNMENT_OPERATOR_SIMPLE, vala_code_node_get_source_reference ((ValaCodeNode*) stmt)), _vala_code_node_unref0 (_tmp41_), _tmp42_);
						vala_return_statement_set_return_expression (ret_stmt, NULL);
						vala_block_add_statement (block, (ValaStatement*) (_tmp43_ = vala_expression_statement_new ((ValaExpression*) assignment, vala_code_node_get_source_reference ((ValaCodeNode*) stmt))));
						_vala_code_node_unref0 (_tmp43_);
						_vala_code_node_unref0 (assignment);
					}
					_vala_code_node_unref0 (ret_stmt);
				}
				vala_block_add_statement (block, stmt);
			}
			_vala_code_node_unref0 (stmt);
		}
		goto __finally6;
		__catch6_vala_parse_error:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				if (vala_parser_recover (self) != VALA_PARSER_RECOVERY_STATE_STATEMENT_BEGIN) {
					_g_error_free0 (e);
					break;
				}
				_g_error_free0 (e);
			}
		}
		__finally6:
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
}


static gboolean vala_parser_is_expression (ValaParser* self, GError** error) {
	gboolean result = FALSE;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, FALSE);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_skip_type (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return FALSE;
		}
	}
	switch (vala_parser_current (self)) {
		case VALA_TOKEN_TYPE_OPEN_PARENS:
		case VALA_TOKEN_TYPE_OP_INC:
		case VALA_TOKEN_TYPE_OP_DEC:
		case VALA_TOKEN_TYPE_ASSIGN:
		case VALA_TOKEN_TYPE_ASSIGN_ADD:
		case VALA_TOKEN_TYPE_ASSIGN_BITWISE_AND:
		case VALA_TOKEN_TYPE_ASSIGN_BITWISE_OR:
		case VALA_TOKEN_TYPE_ASSIGN_BITWISE_XOR:
		case VALA_TOKEN_TYPE_ASSIGN_DIV:
		case VALA_TOKEN_TYPE_ASSIGN_MUL:
		case VALA_TOKEN_TYPE_ASSIGN_PERCENT:
		case VALA_TOKEN_TYPE_ASSIGN_SHIFT_LEFT:
		case VALA_TOKEN_TYPE_ASSIGN_SUB:
		case VALA_TOKEN_TYPE_OP_GT:
		case VALA_TOKEN_TYPE_DOT:
		case VALA_TOKEN_TYPE_OP_PTR:
		{
			vala_parser_rollback (self, &begin);
			result = TRUE;
			return result;
		}
		default:
		{
			vala_parser_rollback (self, &begin);
			result = FALSE;
			return result;
		}
	}
}


static ValaBlock* vala_parser_parse_embedded_statement (ValaParser* self, GError** error) {
	ValaBlock* result = NULL;
	ValaComment* _tmp0_;
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceLocation _tmp2_;
	ValaSourceReference* _tmp3_;
	ValaBlock* _tmp4_;
	ValaBlock* block;
	ValaStatement* stmt;
	gboolean _tmp5_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (vala_parser_current (self) == VALA_TOKEN_TYPE_OPEN_BRACE) {
		ValaBlock* block;
		block = vala_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = block;
		return result;
	}
	self->priv->comment = (_tmp0_ = vala_scanner_pop_comment (self->priv->scanner), _vala_comment_unref0 (self->priv->comment), _tmp0_);
	block = (_tmp4_ = vala_block_new (_tmp3_ = vala_parser_get_src (self, (_tmp2_ = (vala_parser_get_location (self, &_tmp1_), _tmp1_), &_tmp2_))), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	stmt = vala_parser_parse_embedded_statement_without_block (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
		_tmp5_ = VALA_IS_RETURN_STATEMENT (stmt);
	} else {
		_tmp5_ = FALSE;
	}
	if (_tmp5_) {
		ValaReturnStatement* ret_stmt;
		ret_stmt = _vala_code_node_ref0 (VALA_RETURN_STATEMENT (stmt));
		if (vala_return_statement_get_return_expression (ret_stmt) != NULL) {
			ValaMemberAccess* _tmp6_;
			ValaAssignment* _tmp7_;
			ValaAssignment* assignment;
			ValaExpressionStatement* _tmp8_;
			assignment = (_tmp7_ = vala_assignment_new ((ValaExpression*) (_tmp6_ = vala_member_access_new_simple ("result", NULL)), vala_return_statement_get_return_expression (ret_stmt), VALA_ASSIGNMENT_OPERATOR_SIMPLE, NULL), _vala_code_node_unref0 (_tmp6_), _tmp7_);
			vala_return_statement_set_return_expression (ret_stmt, NULL);
			vala_block_add_statement (block, (ValaStatement*) (_tmp8_ = vala_expression_statement_new ((ValaExpression*) assignment, NULL)));
			_vala_code_node_unref0 (_tmp8_);
			_vala_code_node_unref0 (assignment);
		}
		_vala_code_node_unref0 (ret_stmt);
	}
	vala_block_add_statement (block, stmt);
	result = block;
	_vala_code_node_unref0 (stmt);
	return result;
}


static ValaStatement* vala_parser_parse_embedded_statement_without_block (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	switch (vala_parser_current (self)) {
		case VALA_TOKEN_TYPE_SEMICOLON:
		{
			ValaStatement* _tmp0_;
			_tmp0_ = vala_parser_parse_empty_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp0_;
			return result;
		}
		case VALA_TOKEN_TYPE_IF:
		{
			ValaStatement* _tmp1_;
			_tmp1_ = vala_parser_parse_if_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp1_;
			return result;
		}
		case VALA_TOKEN_TYPE_SWITCH:
		{
			ValaStatement* _tmp2_;
			_tmp2_ = vala_parser_parse_switch_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp2_;
			return result;
		}
		case VALA_TOKEN_TYPE_WHILE:
		{
			ValaStatement* _tmp3_;
			_tmp3_ = vala_parser_parse_while_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp3_;
			return result;
		}
		case VALA_TOKEN_TYPE_DO:
		{
			ValaStatement* _tmp4_;
			_tmp4_ = vala_parser_parse_do_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp4_;
			return result;
		}
		case VALA_TOKEN_TYPE_FOR:
		{
			ValaStatement* _tmp5_;
			_tmp5_ = vala_parser_parse_for_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp5_;
			return result;
		}
		case VALA_TOKEN_TYPE_FOREACH:
		{
			ValaStatement* _tmp6_;
			_tmp6_ = vala_parser_parse_foreach_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp6_;
			return result;
		}
		case VALA_TOKEN_TYPE_BREAK:
		{
			ValaStatement* _tmp7_;
			_tmp7_ = vala_parser_parse_break_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp7_;
			return result;
		}
		case VALA_TOKEN_TYPE_CONTINUE:
		{
			ValaStatement* _tmp8_;
			_tmp8_ = vala_parser_parse_continue_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp8_;
			return result;
		}
		case VALA_TOKEN_TYPE_RETURN:
		{
			ValaStatement* _tmp9_;
			_tmp9_ = vala_parser_parse_return_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp9_;
			return result;
		}
		case VALA_TOKEN_TYPE_YIELD:
		{
			ValaStatement* _tmp10_;
			_tmp10_ = vala_parser_parse_yield_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp10_;
			return result;
		}
		case VALA_TOKEN_TYPE_THROW:
		{
			ValaStatement* _tmp11_;
			_tmp11_ = vala_parser_parse_throw_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp11_;
			return result;
		}
		case VALA_TOKEN_TYPE_TRY:
		{
			ValaStatement* _tmp12_;
			_tmp12_ = vala_parser_parse_try_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp12_;
			return result;
		}
		case VALA_TOKEN_TYPE_LOCK:
		{
			ValaStatement* _tmp13_;
			_tmp13_ = vala_parser_parse_lock_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp13_;
			return result;
		}
		case VALA_TOKEN_TYPE_DELETE:
		{
			ValaStatement* _tmp14_;
			_tmp14_ = vala_parser_parse_delete_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp14_;
			return result;
		}
		default:
		{
			ValaStatement* _tmp15_;
			_tmp15_ = vala_parser_parse_expression_statement (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = _tmp15_;
			return result;
		}
	}
}


static ValaBlock* vala_parser_parse_block (ValaParser* self, GError** error) {
	ValaBlock* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaBlock* _tmp2_;
	ValaBlock* block;
	ValaSourceReference* _tmp4_;
	ValaSourceReference* _tmp5_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	block = (_tmp2_ = vala_block_new (_tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	vala_parser_parse_statements (self, block, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (!vala_parser_accept (self, VALA_TOKEN_TYPE_CLOSE_BRACE)) {
		if (vala_report_get_errors (vala_code_context_get_report (self->priv->context)) == 0) {
			ValaSourceReference* _tmp3_;
			vala_report_error (_tmp3_ = vala_parser_get_current_src (self), "expected `}'");
			_vala_source_reference_unref0 (_tmp3_);
		}
	}
	vala_source_reference_set_last_line (vala_code_node_get_source_reference ((ValaCodeNode*) block), vala_source_reference_get_last_line (_tmp4_ = vala_parser_get_current_src (self)));
	_vala_source_reference_unref0 (_tmp4_);
	vala_source_reference_set_last_column (vala_code_node_get_source_reference ((ValaCodeNode*) block), vala_source_reference_get_last_column (_tmp5_ = vala_parser_get_current_src (self)));
	_vala_source_reference_unref0 (_tmp5_);
	result = block;
	return result;
}


static ValaStatement* vala_parser_parse_empty_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_empty_statement_new (_tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	return result;
}


static void _vala_array_add13 (char*** array, int* length, int* size, char* value) {
	if ((*length) == (*size)) {
		*size = (*size) ? (2 * (*size)) : 4;
		*array = g_renew (char*, *array, (*size) + 1);
	}
	(*array)[(*length)++] = value;
	(*array)[*length] = NULL;
}


static void vala_parser_parse_local_variable_declarations (ValaParser* self, ValaBlock* block, GError** error) {
	ValaDataType* variable_type;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (block != NULL);
	variable_type = NULL;
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_VAR)) {
		ValaDataType* _tmp0_;
		variable_type = (_tmp0_ = NULL, _vala_code_node_unref0 (variable_type), _tmp0_);
	} else {
		ValaDataType* _tmp1_;
		ValaDataType* _tmp2_;
		_tmp1_ = vala_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (variable_type);
				return;
			} else {
				_vala_code_node_unref0 (variable_type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		variable_type = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (variable_type), _tmp2_);
	}
	{
		gboolean _tmp3_;
		_tmp3_ = TRUE;
		while (TRUE) {
			gboolean _tmp4_ = FALSE;
			ValaDataType* type_copy;
			ValaLocalVariable* local;
			ValaDeclarationStatement* _tmp19_;
			if (!_tmp3_) {
				if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
					break;
				}
			}
			_tmp3_ = FALSE;
			if (variable_type == NULL) {
				_tmp4_ = vala_parser_accept (self, VALA_TOKEN_TYPE_OPEN_PARENS);
			} else {
				_tmp4_ = FALSE;
			}
			if (_tmp4_) {
				ValaSourceLocation _tmp5_ = {0};
				ValaSourceLocation begin;
				gint identifiers_length1;
				gint _identifiers_size_;
				char** _tmp7_;
				char** _tmp6_ = NULL;
				char** identifiers;
				ValaExpression* tuple;
				char* _tmp10_;
				ValaSourceReference* _tmp11_;
				ValaLocalVariable* _tmp12_;
				ValaLocalVariable* tuple_local;
				ValaDeclarationStatement* _tmp13_;
				begin = (vala_parser_get_location (self, &_tmp5_), _tmp5_);
				identifiers = (_tmp7_ = (_tmp6_ = g_new0 (char*, 0 + 1), _tmp6_), identifiers_length1 = 0, _identifiers_size_ = identifiers_length1, _tmp7_);
				{
					gboolean _tmp8_;
					_tmp8_ = TRUE;
					while (TRUE) {
						char* _tmp9_;
						if (!_tmp8_) {
							if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
								break;
							}
						}
						_tmp8_ = FALSE;
						_tmp9_ = vala_parser_parse_identifier (self, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								identifiers = (_vala_array_free (identifiers, identifiers_length1, (GDestroyNotify) g_free), NULL);
								_vala_code_node_unref0 (variable_type);
								return;
							} else {
								identifiers = (_vala_array_free (identifiers, identifiers_length1, (GDestroyNotify) g_free), NULL);
								_vala_code_node_unref0 (variable_type);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
						_vala_array_add13 (&identifiers, &identifiers_length1, &_identifiers_size_, _tmp9_);
					}
				}
				vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						identifiers = (_vala_array_free (identifiers, identifiers_length1, (GDestroyNotify) g_free), NULL);
						_vala_code_node_unref0 (variable_type);
						return;
					} else {
						identifiers = (_vala_array_free (identifiers, identifiers_length1, (GDestroyNotify) g_free), NULL);
						_vala_code_node_unref0 (variable_type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				vala_parser_expect (self, VALA_TOKEN_TYPE_ASSIGN, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						identifiers = (_vala_array_free (identifiers, identifiers_length1, (GDestroyNotify) g_free), NULL);
						_vala_code_node_unref0 (variable_type);
						return;
					} else {
						identifiers = (_vala_array_free (identifiers, identifiers_length1, (GDestroyNotify) g_free), NULL);
						_vala_code_node_unref0 (variable_type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				tuple = vala_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						identifiers = (_vala_array_free (identifiers, identifiers_length1, (GDestroyNotify) g_free), NULL);
						_vala_code_node_unref0 (variable_type);
						return;
					} else {
						identifiers = (_vala_array_free (identifiers, identifiers_length1, (GDestroyNotify) g_free), NULL);
						_vala_code_node_unref0 (variable_type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				tuple_local = (_tmp12_ = vala_local_variable_new (NULL, _tmp10_ = vala_code_node_get_temp_name (), tuple, _tmp11_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp11_), _g_free0 (_tmp10_), _tmp12_);
				vala_block_add_statement (block, (ValaStatement*) (_tmp13_ = vala_declaration_statement_new ((ValaSymbol*) tuple_local, vala_code_node_get_source_reference ((ValaCodeNode*) tuple_local))));
				_vala_code_node_unref0 (_tmp13_);
				{
					gint i;
					i = 0;
					{
						gboolean _tmp14_;
						_tmp14_ = TRUE;
						while (TRUE) {
							ValaMemberAccess* temp_access;
							ValaElementAccess* ea;
							char* _tmp15_;
							ValaIntegerLiteral* _tmp16_;
							ValaLocalVariable* local;
							ValaDeclarationStatement* _tmp17_;
							if (!_tmp14_) {
								i++;
							}
							_tmp14_ = FALSE;
							if (!(i < identifiers_length1)) {
								break;
							}
							temp_access = vala_member_access_new_simple (vala_symbol_get_name ((ValaSymbol*) tuple_local), vala_code_node_get_source_reference ((ValaCodeNode*) tuple_local));
							ea = vala_element_access_new ((ValaExpression*) temp_access, vala_code_node_get_source_reference ((ValaCodeNode*) tuple_local));
							vala_element_access_append_index (ea, (ValaExpression*) (_tmp16_ = vala_integer_literal_new (_tmp15_ = g_strdup_printf ("%i", i), NULL)));
							_vala_code_node_unref0 (_tmp16_);
							_g_free0 (_tmp15_);
							local = vala_local_variable_new (NULL, identifiers[i], (ValaExpression*) ea, vala_code_node_get_source_reference ((ValaCodeNode*) tuple_local));
							vala_block_add_statement (block, (ValaStatement*) (_tmp17_ = vala_declaration_statement_new ((ValaSymbol*) local, vala_code_node_get_source_reference ((ValaCodeNode*) local))));
							_vala_code_node_unref0 (_tmp17_);
							_vala_code_node_unref0 (local);
							_vala_code_node_unref0 (ea);
							_vala_code_node_unref0 (temp_access);
						}
					}
				}
				_vala_code_node_unref0 (tuple_local);
				_vala_code_node_unref0 (tuple);
				identifiers = (_vala_array_free (identifiers, identifiers_length1, (GDestroyNotify) g_free), NULL);
				continue;
			}
			type_copy = NULL;
			if (variable_type != NULL) {
				ValaDataType* _tmp18_;
				type_copy = (_tmp18_ = vala_data_type_copy (variable_type), _vala_code_node_unref0 (type_copy), _tmp18_);
			}
			local = vala_parser_parse_local_variable (self, type_copy, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (type_copy);
					_vala_code_node_unref0 (variable_type);
					return;
				} else {
					_vala_code_node_unref0 (type_copy);
					_vala_code_node_unref0 (variable_type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			vala_block_add_statement (block, (ValaStatement*) (_tmp19_ = vala_declaration_statement_new ((ValaSymbol*) local, vala_code_node_get_source_reference ((ValaCodeNode*) local))));
			_vala_code_node_unref0 (_tmp19_);
			_vala_code_node_unref0 (local);
			_vala_code_node_unref0 (type_copy);
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (variable_type);
			return;
		} else {
			_vala_code_node_unref0 (variable_type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	_vala_code_node_unref0 (variable_type);
}


static ValaLocalVariable* vala_parser_parse_local_variable (ValaParser* self, ValaDataType* variable_type, GError** error) {
	ValaLocalVariable* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	char* id;
	ValaDataType* type;
	ValaExpression* initializer;
	ValaSourceReference* _tmp3_;
	ValaLocalVariable* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	id = vala_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = vala_parser_parse_inline_array_type (self, variable_type, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			return NULL;
		} else {
			_g_free0 (id);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	initializer = NULL;
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_ASSIGN)) {
		ValaExpression* _tmp1_;
		ValaExpression* _tmp2_;
		_tmp1_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				return NULL;
			} else {
				_vala_code_node_unref0 (initializer);
				_vala_code_node_unref0 (type);
				_g_free0 (id);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		initializer = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (initializer), _tmp2_);
	}
	result = (_tmp4_ = vala_local_variable_new (type, id, initializer, _tmp3_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	_vala_code_node_unref0 (initializer);
	_vala_code_node_unref0 (type);
	_g_free0 (id);
	return result;
	_vala_code_node_unref0 (initializer);
	_vala_code_node_unref0 (type);
	_g_free0 (id);
}


static ValaStatement* vala_parser_parse_expression_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	expr = vala_parser_parse_statement_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_expression_statement_new (expr, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (expr);
	return result;
	_vala_code_node_unref0 (expr);
}


static ValaExpression* vala_parser_parse_statement_expression (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaExpression* expr;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	expr = vala_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = expr;
	return result;
}


static ValaStatement* vala_parser_parse_if_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* condition;
	ValaSourceReference* src;
	ValaBlock* true_stmt;
	ValaBlock* false_stmt;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_IF, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	condition = vala_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	src = vala_parser_get_src (self, &begin);
	true_stmt = vala_parser_parse_embedded_statement (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_source_reference_unref0 (src);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_source_reference_unref0 (src);
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	false_stmt = NULL;
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_ELSE)) {
		ValaBlock* _tmp1_;
		ValaBlock* _tmp2_;
		_tmp1_ = vala_parser_parse_embedded_statement (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (false_stmt);
				_vala_code_node_unref0 (true_stmt);
				_vala_source_reference_unref0 (src);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (false_stmt);
				_vala_code_node_unref0 (true_stmt);
				_vala_source_reference_unref0 (src);
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		false_stmt = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (false_stmt), _tmp2_);
	}
	result = (ValaStatement*) vala_if_statement_new (condition, true_stmt, false_stmt, src);
	_vala_code_node_unref0 (false_stmt);
	_vala_code_node_unref0 (true_stmt);
	_vala_source_reference_unref0 (src);
	_vala_code_node_unref0 (condition);
	return result;
}


static ValaStatement* vala_parser_parse_switch_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* condition;
	ValaSourceReference* _tmp1_;
	ValaSwitchStatement* _tmp2_;
	ValaSwitchStatement* stmt;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_SWITCH, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	condition = vala_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	stmt = (_tmp2_ = vala_switch_statement_new (condition, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (stmt);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (stmt);
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		ValaSourceReference* _tmp3_;
		ValaSwitchSection* _tmp4_;
		ValaSwitchSection* section;
		if (!(vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACE)) {
			break;
		}
		section = (_tmp4_ = vala_switch_section_new (_tmp3_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
		{
			gboolean _tmp5_;
			_tmp5_ = TRUE;
			while (TRUE) {
				if (!_tmp5_) {
					gboolean _tmp6_ = FALSE;
					if (vala_parser_current (self) == VALA_TOKEN_TYPE_CASE) {
						_tmp6_ = TRUE;
					} else {
						_tmp6_ = vala_parser_current (self) == VALA_TOKEN_TYPE_DEFAULT;
					}
					if (!_tmp6_) {
						break;
					}
				}
				_tmp5_ = FALSE;
				if (vala_parser_accept (self, VALA_TOKEN_TYPE_CASE)) {
					ValaExpression* _tmp7_;
					ValaExpression* _tmp8_;
					ValaSourceReference* _tmp9_;
					ValaSwitchLabel* _tmp10_;
					_tmp7_ = vala_parser_parse_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (section);
							_vala_code_node_unref0 (stmt);
							_vala_code_node_unref0 (condition);
							return NULL;
						} else {
							_vala_code_node_unref0 (section);
							_vala_code_node_unref0 (stmt);
							_vala_code_node_unref0 (condition);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_switch_section_add_label (section, _tmp10_ = vala_switch_label_new (_tmp8_ = _tmp7_, _tmp9_ = vala_parser_get_src (self, &begin)));
					_vala_code_node_unref0 (_tmp10_);
					_vala_source_reference_unref0 (_tmp9_);
					_vala_code_node_unref0 (_tmp8_);
				} else {
					ValaSourceReference* _tmp11_;
					ValaSwitchLabel* _tmp12_;
					vala_parser_expect (self, VALA_TOKEN_TYPE_DEFAULT, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (section);
							_vala_code_node_unref0 (stmt);
							_vala_code_node_unref0 (condition);
							return NULL;
						} else {
							_vala_code_node_unref0 (section);
							_vala_code_node_unref0 (stmt);
							_vala_code_node_unref0 (condition);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_switch_section_add_label (section, _tmp12_ = vala_switch_label_new_with_default (_tmp11_ = vala_parser_get_src (self, &begin)));
					_vala_code_node_unref0 (_tmp12_);
					_vala_source_reference_unref0 (_tmp11_);
				}
				vala_parser_expect (self, VALA_TOKEN_TYPE_COLON, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (section);
						_vala_code_node_unref0 (stmt);
						_vala_code_node_unref0 (condition);
						return NULL;
					} else {
						_vala_code_node_unref0 (section);
						_vala_code_node_unref0 (stmt);
						_vala_code_node_unref0 (condition);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
		}
		vala_parser_parse_statements (self, (ValaBlock*) section, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (section);
				_vala_code_node_unref0 (stmt);
				_vala_code_node_unref0 (condition);
				return NULL;
			} else {
				_vala_code_node_unref0 (section);
				_vala_code_node_unref0 (stmt);
				_vala_code_node_unref0 (condition);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_switch_statement_add_section (stmt, section);
		_vala_code_node_unref0 (section);
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (stmt);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (stmt);
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (ValaStatement*) stmt;
	_vala_code_node_unref0 (condition);
	return result;
}


static ValaStatement* vala_parser_parse_while_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* condition;
	ValaBlock* body;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_WHILE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	condition = vala_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	body = vala_parser_parse_embedded_statement (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_while_statement_new (condition, body, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (body);
	_vala_code_node_unref0 (condition);
	return result;
	_vala_code_node_unref0 (body);
	_vala_code_node_unref0 (condition);
}


static ValaStatement* vala_parser_parse_do_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaBlock* body;
	ValaExpression* condition;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_DO, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	body = vala_parser_parse_embedded_statement (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_WHILE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (body);
			return NULL;
		} else {
			_vala_code_node_unref0 (body);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (body);
			return NULL;
		} else {
			_vala_code_node_unref0 (body);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	condition = vala_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (body);
			return NULL;
		} else {
			_vala_code_node_unref0 (body);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (body);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (body);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (body);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			_vala_code_node_unref0 (body);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_do_statement_new (body, condition, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (condition);
	_vala_code_node_unref0 (body);
	return result;
	_vala_code_node_unref0 (condition);
	_vala_code_node_unref0 (body);
}


static ValaStatement* vala_parser_parse_for_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaBlock* block;
	ValaArrayList* initializer_list;
	ValaExpression* condition;
	ValaArrayList* iterator_list;
	ValaSourceReference* src;
	ValaBlock* body;
	ValaForStatement* stmt;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	block = NULL;
	vala_parser_expect (self, VALA_TOKEN_TYPE_FOR, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	initializer_list = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (!vala_parser_accept (self, VALA_TOKEN_TYPE_SEMICOLON)) {
		gboolean is_expr = FALSE;
		switch (vala_parser_current (self)) {
			case VALA_TOKEN_TYPE_VAR:
			{
				is_expr = FALSE;
				break;
			}
			case VALA_TOKEN_TYPE_OP_INC:
			case VALA_TOKEN_TYPE_OP_DEC:
			{
				is_expr = TRUE;
				break;
			}
			default:
			{
				gboolean _tmp1_;
				_tmp1_ = vala_parser_is_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (initializer_list);
						_vala_code_node_unref0 (block);
						return NULL;
					} else {
						_vala_collection_object_unref0 (initializer_list);
						_vala_code_node_unref0 (block);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				is_expr = _tmp1_;
				break;
			}
		}
		if (is_expr) {
			{
				gboolean _tmp2_;
				_tmp2_ = TRUE;
				while (TRUE) {
					ValaExpression* _tmp3_;
					ValaExpression* _tmp4_;
					if (!_tmp2_) {
						if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp2_ = FALSE;
					_tmp3_ = vala_parser_parse_statement_expression (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_collection_object_unref0 (initializer_list);
							_vala_code_node_unref0 (block);
							return NULL;
						} else {
							_vala_collection_object_unref0 (initializer_list);
							_vala_code_node_unref0 (block);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_collection_add ((ValaCollection*) initializer_list, _tmp4_ = _tmp3_);
					_vala_code_node_unref0 (_tmp4_);
				}
			}
			vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (initializer_list);
					_vala_code_node_unref0 (block);
					return NULL;
				} else {
					_vala_collection_object_unref0 (initializer_list);
					_vala_code_node_unref0 (block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		} else {
			ValaSourceReference* _tmp5_;
			ValaBlock* _tmp6_;
			block = (_tmp6_ = vala_block_new (_tmp5_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (block), _tmp6_);
			_vala_source_reference_unref0 (_tmp5_);
			vala_parser_parse_local_variable_declarations (self, block, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (initializer_list);
					_vala_code_node_unref0 (block);
					return NULL;
				} else {
					_vala_collection_object_unref0 (initializer_list);
					_vala_code_node_unref0 (block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	}
	condition = NULL;
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_SEMICOLON) {
		ValaExpression* _tmp7_;
		ValaExpression* _tmp8_;
		_tmp7_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (condition);
				_vala_collection_object_unref0 (initializer_list);
				_vala_code_node_unref0 (block);
				return NULL;
			} else {
				_vala_code_node_unref0 (condition);
				_vala_collection_object_unref0 (initializer_list);
				_vala_code_node_unref0 (block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		condition = (_tmp8_ = _tmp7_, _vala_code_node_unref0 (condition), _tmp8_);
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (condition);
			_vala_collection_object_unref0 (initializer_list);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_code_node_unref0 (condition);
			_vala_collection_object_unref0 (initializer_list);
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	iterator_list = vala_array_list_new (VALA_TYPE_EXPRESSION, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp9_;
			_tmp9_ = TRUE;
			while (TRUE) {
				ValaExpression* _tmp10_;
				ValaExpression* _tmp11_;
				if (!_tmp9_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp9_ = FALSE;
				_tmp10_ = vala_parser_parse_statement_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (iterator_list);
						_vala_code_node_unref0 (condition);
						_vala_collection_object_unref0 (initializer_list);
						_vala_code_node_unref0 (block);
						return NULL;
					} else {
						_vala_collection_object_unref0 (iterator_list);
						_vala_code_node_unref0 (condition);
						_vala_collection_object_unref0 (initializer_list);
						_vala_code_node_unref0 (block);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) iterator_list, _tmp11_ = _tmp10_);
				_vala_code_node_unref0 (_tmp11_);
			}
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (iterator_list);
			_vala_code_node_unref0 (condition);
			_vala_collection_object_unref0 (initializer_list);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_collection_object_unref0 (iterator_list);
			_vala_code_node_unref0 (condition);
			_vala_collection_object_unref0 (initializer_list);
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	src = vala_parser_get_src (self, &begin);
	body = vala_parser_parse_embedded_statement (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_source_reference_unref0 (src);
			_vala_collection_object_unref0 (iterator_list);
			_vala_code_node_unref0 (condition);
			_vala_collection_object_unref0 (initializer_list);
			_vala_code_node_unref0 (block);
			return NULL;
		} else {
			_vala_source_reference_unref0 (src);
			_vala_collection_object_unref0 (iterator_list);
			_vala_code_node_unref0 (condition);
			_vala_collection_object_unref0 (initializer_list);
			_vala_code_node_unref0 (block);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	stmt = vala_for_statement_new (condition, body, src);
	{
		ValaIterator* _init_it;
		_init_it = vala_iterable_iterator ((ValaIterable*) initializer_list);
		while (TRUE) {
			ValaExpression* init;
			if (!vala_iterator_next (_init_it)) {
				break;
			}
			init = (ValaExpression*) vala_iterator_get (_init_it);
			vala_for_statement_add_initializer (stmt, init);
			_vala_code_node_unref0 (init);
		}
		_vala_collection_object_unref0 (_init_it);
	}
	{
		ValaIterator* _iter_it;
		_iter_it = vala_iterable_iterator ((ValaIterable*) iterator_list);
		while (TRUE) {
			ValaExpression* iter;
			if (!vala_iterator_next (_iter_it)) {
				break;
			}
			iter = (ValaExpression*) vala_iterator_get (_iter_it);
			vala_for_statement_add_iterator (stmt, iter);
			_vala_code_node_unref0 (iter);
		}
		_vala_collection_object_unref0 (_iter_it);
	}
	if (block != NULL) {
		vala_block_add_statement (block, (ValaStatement*) stmt);
		result = (ValaStatement*) block;
		_vala_code_node_unref0 (stmt);
		_vala_code_node_unref0 (body);
		_vala_source_reference_unref0 (src);
		_vala_collection_object_unref0 (iterator_list);
		_vala_code_node_unref0 (condition);
		_vala_collection_object_unref0 (initializer_list);
		return result;
	} else {
		result = (ValaStatement*) stmt;
		_vala_code_node_unref0 (body);
		_vala_source_reference_unref0 (src);
		_vala_collection_object_unref0 (iterator_list);
		_vala_code_node_unref0 (condition);
		_vala_collection_object_unref0 (initializer_list);
		_vala_code_node_unref0 (block);
		return result;
	}
	_vala_code_node_unref0 (stmt);
	_vala_code_node_unref0 (body);
	_vala_source_reference_unref0 (src);
	_vala_collection_object_unref0 (iterator_list);
	_vala_code_node_unref0 (condition);
	_vala_collection_object_unref0 (initializer_list);
	_vala_code_node_unref0 (block);
}


static ValaStatement* vala_parser_parse_foreach_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaDataType* type;
	char* id;
	ValaExpression* collection;
	ValaSourceReference* src;
	ValaBlock* body;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_FOREACH, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = NULL;
	if (!vala_parser_accept (self, VALA_TOKEN_TYPE_VAR)) {
		ValaDataType* _tmp1_;
		ValaDataType* _tmp2_;
		_tmp1_ = vala_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		type = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (type), _tmp2_);
	}
	id = vala_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_IN, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	collection = vala_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (collection);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (collection);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	src = vala_parser_get_src (self, &begin);
	body = vala_parser_parse_embedded_statement (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_source_reference_unref0 (src);
			_vala_code_node_unref0 (collection);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_source_reference_unref0 (src);
			_vala_code_node_unref0 (collection);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (ValaStatement*) vala_foreach_statement_new (type, id, collection, body, src);
	_vala_code_node_unref0 (body);
	_vala_source_reference_unref0 (src);
	_vala_code_node_unref0 (collection);
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaStatement* vala_parser_parse_break_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_BREAK, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_break_statement_new (_tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	return result;
}


static ValaStatement* vala_parser_parse_continue_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_CONTINUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_continue_statement_new (_tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	return result;
}


static ValaStatement* vala_parser_parse_return_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	ValaSourceReference* _tmp3_;
	ValaStatement* _tmp4_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_RETURN, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = NULL;
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_SEMICOLON) {
		ValaExpression* _tmp1_;
		ValaExpression* _tmp2_;
		_tmp1_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		expr = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (expr), _tmp2_);
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp4_ = (ValaStatement*) vala_return_statement_new (expr, _tmp3_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	_vala_code_node_unref0 (expr);
	return result;
	_vala_code_node_unref0 (expr);
}


static ValaStatement* vala_parser_parse_yield_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	gboolean _tmp1_ = FALSE;
	ValaExpression* expr;
	ValaSourceReference* _tmp5_;
	ValaStatement* _tmp6_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_YIELD, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_SEMICOLON) {
		_tmp1_ = vala_parser_current (self) != VALA_TOKEN_TYPE_RETURN;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		ValaStatement* _tmp2_;
		vala_parser_prev (self);
		_tmp2_ = vala_parser_parse_expression_statement (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		result = _tmp2_;
		return result;
	}
	expr = NULL;
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_RETURN)) {
		ValaExpression* _tmp3_;
		ValaExpression* _tmp4_;
		_tmp3_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (expr);
				return NULL;
			} else {
				_vala_code_node_unref0 (expr);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		expr = (_tmp4_ = _tmp3_, _vala_code_node_unref0 (expr), _tmp4_);
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp6_ = (ValaStatement*) vala_yield_statement_new (expr, _tmp5_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp5_), _tmp6_);
	_vala_code_node_unref0 (expr);
	return result;
	_vala_code_node_unref0 (expr);
}


static ValaStatement* vala_parser_parse_throw_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_THROW, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = vala_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_throw_statement_new (expr, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (expr);
	return result;
	_vala_code_node_unref0 (expr);
}


static ValaStatement* vala_parser_parse_try_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaBlock* try_block;
	ValaBlock* finally_clause;
	ValaArrayList* catch_clauses;
	ValaSourceReference* _tmp5_;
	ValaTryStatement* _tmp6_;
	ValaTryStatement* stmt;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_TRY, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	try_block = vala_parser_parse_block (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	finally_clause = NULL;
	catch_clauses = vala_array_list_new (VALA_TYPE_CATCH_CLAUSE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_parser_current (self) == VALA_TOKEN_TYPE_CATCH) {
		vala_parser_parse_catch_clauses (self, (ValaList*) catch_clauses, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (catch_clauses);
				_vala_code_node_unref0 (finally_clause);
				_vala_code_node_unref0 (try_block);
				return NULL;
			} else {
				_vala_collection_object_unref0 (catch_clauses);
				_vala_code_node_unref0 (finally_clause);
				_vala_code_node_unref0 (try_block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		if (vala_parser_current (self) == VALA_TOKEN_TYPE_FINALLY) {
			ValaBlock* _tmp1_;
			ValaBlock* _tmp2_;
			_tmp1_ = vala_parser_parse_finally_clause (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (catch_clauses);
					_vala_code_node_unref0 (finally_clause);
					_vala_code_node_unref0 (try_block);
					return NULL;
				} else {
					_vala_collection_object_unref0 (catch_clauses);
					_vala_code_node_unref0 (finally_clause);
					_vala_code_node_unref0 (try_block);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			finally_clause = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (finally_clause), _tmp2_);
		}
	} else {
		ValaBlock* _tmp3_;
		ValaBlock* _tmp4_;
		_tmp3_ = vala_parser_parse_finally_clause (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (catch_clauses);
				_vala_code_node_unref0 (finally_clause);
				_vala_code_node_unref0 (try_block);
				return NULL;
			} else {
				_vala_collection_object_unref0 (catch_clauses);
				_vala_code_node_unref0 (finally_clause);
				_vala_code_node_unref0 (try_block);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		finally_clause = (_tmp4_ = _tmp3_, _vala_code_node_unref0 (finally_clause), _tmp4_);
	}
	stmt = (_tmp6_ = vala_try_statement_new (try_block, finally_clause, _tmp5_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp5_), _tmp6_);
	{
		ValaIterator* _clause_it;
		_clause_it = vala_iterable_iterator ((ValaIterable*) catch_clauses);
		while (TRUE) {
			ValaCatchClause* clause;
			if (!vala_iterator_next (_clause_it)) {
				break;
			}
			clause = (ValaCatchClause*) vala_iterator_get (_clause_it);
			vala_try_statement_add_catch_clause (stmt, clause);
			_vala_code_node_unref0 (clause);
		}
		_vala_collection_object_unref0 (_clause_it);
	}
	result = (ValaStatement*) stmt;
	_vala_collection_object_unref0 (catch_clauses);
	_vala_code_node_unref0 (finally_clause);
	_vala_code_node_unref0 (try_block);
	return result;
}


static void vala_parser_parse_catch_clauses (ValaParser* self, ValaList* catch_clauses, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (catch_clauses != NULL);
	while (TRUE) {
		ValaSourceLocation _tmp0_ = {0};
		ValaSourceLocation begin;
		ValaDataType* type;
		char* id;
		ValaBlock* block;
		ValaSourceReference* _tmp5_;
		ValaCatchClause* _tmp6_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_CATCH)) {
			break;
		}
		begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
		type = NULL;
		id = NULL;
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_OPEN_PARENS)) {
			ValaDataType* _tmp1_;
			ValaDataType* _tmp2_;
			char* _tmp3_;
			char* _tmp4_;
			_tmp1_ = vala_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			type = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (type), _tmp2_);
			_tmp3_ = vala_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
			id = (_tmp4_ = _tmp3_, _g_free0 (id), _tmp4_);
			vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			}
		}
		block = vala_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return;
			} else {
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
		vala_collection_add ((ValaCollection*) catch_clauses, _tmp6_ = vala_catch_clause_new (type, id, block, _tmp5_ = vala_parser_get_src (self, &begin)));
		_vala_code_node_unref0 (_tmp6_);
		_vala_source_reference_unref0 (_tmp5_);
		_vala_code_node_unref0 (block);
		_g_free0 (id);
		_vala_code_node_unref0 (type);
	}
}


static ValaBlock* vala_parser_parse_finally_clause (ValaParser* self, GError** error) {
	ValaBlock* result = NULL;
	ValaBlock* block;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	vala_parser_expect (self, VALA_TOKEN_TYPE_FINALLY, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	block = vala_parser_parse_block (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = block;
	return result;
}


static ValaStatement* vala_parser_parse_lock_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	ValaBlock* stmt;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_LOCK, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = vala_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	stmt = vala_parser_parse_embedded_statement (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_lock_statement_new (expr, stmt, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (stmt);
	_vala_code_node_unref0 (expr);
	return result;
	_vala_code_node_unref0 (stmt);
	_vala_code_node_unref0 (expr);
}


static ValaStatement* vala_parser_parse_delete_statement (ValaParser* self, GError** error) {
	ValaStatement* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaExpression* expr;
	ValaSourceReference* _tmp1_;
	ValaStatement* _tmp2_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_DELETE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	expr = vala_parser_parse_expression (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (expr);
			return NULL;
		} else {
			_vala_code_node_unref0 (expr);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (_tmp2_ = (ValaStatement*) vala_delete_statement_new (expr, _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	_vala_code_node_unref0 (expr);
	return result;
	_vala_code_node_unref0 (expr);
}


static ValaList* vala_parser_parse_attributes (ValaParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* attrs;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_OPEN_BRACKET) {
		result = NULL;
		return result;
	}
	attrs = vala_array_list_new (VALA_TYPE_ATTRIBUTE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	while (TRUE) {
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_OPEN_BRACKET)) {
			break;
		}
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				ValaSourceLocation _tmp1_ = {0};
				ValaSourceLocation begin;
				char* id;
				ValaSourceReference* _tmp2_;
				ValaAttribute* _tmp3_;
				ValaAttribute* attr;
				if (!_tmp0_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				begin = (vala_parser_get_location (self, &_tmp1_), _tmp1_);
				id = vala_parser_parse_identifier (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (attrs);
						return NULL;
					} else {
						_vala_collection_object_unref0 (attrs);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				attr = (_tmp3_ = vala_attribute_new (id, _tmp2_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp2_), _tmp3_);
				if (vala_parser_accept (self, VALA_TOKEN_TYPE_OPEN_PARENS)) {
					if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_PARENS) {
						{
							gboolean _tmp4_;
							_tmp4_ = TRUE;
							while (TRUE) {
								char* _tmp5_;
								char* _tmp6_;
								ValaExpression* expr;
								if (!_tmp4_) {
									if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
										break;
									}
								}
								_tmp4_ = FALSE;
								_tmp5_ = vala_parser_parse_identifier (self, &_inner_error_);
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == VALA_PARSE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_collection_object_unref0 (attrs);
										return NULL;
									} else {
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_collection_object_unref0 (attrs);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return NULL;
									}
								}
								id = (_tmp6_ = _tmp5_, _g_free0 (id), _tmp6_);
								vala_parser_expect (self, VALA_TOKEN_TYPE_ASSIGN, &_inner_error_);
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == VALA_PARSE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_collection_object_unref0 (attrs);
										return NULL;
									} else {
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_collection_object_unref0 (attrs);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return NULL;
									}
								}
								expr = vala_parser_parse_expression (self, &_inner_error_);
								if (_inner_error_ != NULL) {
									if (_inner_error_->domain == VALA_PARSE_ERROR) {
										g_propagate_error (error, _inner_error_);
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_collection_object_unref0 (attrs);
										return NULL;
									} else {
										_vala_code_node_unref0 (attr);
										_g_free0 (id);
										_vala_collection_object_unref0 (attrs);
										g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
										g_clear_error (&_inner_error_);
										return NULL;
									}
								}
								vala_attribute_add_argument (attr, id, expr);
								_vala_code_node_unref0 (expr);
							}
						}
					}
					vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (attr);
							_g_free0 (id);
							_vala_collection_object_unref0 (attrs);
							return NULL;
						} else {
							_vala_code_node_unref0 (attr);
							_g_free0 (id);
							_vala_collection_object_unref0 (attrs);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				vala_collection_add ((ValaCollection*) attrs, attr);
				_vala_code_node_unref0 (attr);
				_g_free0 (id);
			}
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (attrs);
				return NULL;
			} else {
				_vala_collection_object_unref0 (attrs);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	result = (ValaList*) attrs;
	return result;
}


static void vala_parser_set_attributes (ValaParser* self, ValaCodeNode* node, ValaList* attributes) {
	g_return_if_fail (self != NULL);
	g_return_if_fail (node != NULL);
	if (attributes != NULL) {
		{
			ValaIterator* _attr_it;
			_attr_it = vala_iterable_iterator ((ValaIterable*) VALA_LIST (attributes));
			while (TRUE) {
				ValaAttribute* attr;
				if (!vala_iterator_next (_attr_it)) {
					break;
				}
				attr = (ValaAttribute*) vala_iterator_get (_attr_it);
				node->attributes = g_list_append (node->attributes, _vala_code_node_ref0 (attr));
				_vala_code_node_unref0 (attr);
			}
			_vala_collection_object_unref0 (_attr_it);
		}
	}
}


static ValaMethod* vala_parser_parse_main_block (ValaParser* self, GError** error) {
	ValaMethod* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaVoidType* _tmp1_;
	ValaSourceReference* _tmp2_;
	ValaMethod* _tmp3_;
	ValaMethod* method;
	ValaSourceReference* _tmp4_;
	ValaBlock* _tmp5_;
	ValaSourceReference* _tmp7_;
	ValaSourceReference* _tmp8_;
	gboolean _tmp9_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	method = (_tmp3_ = vala_method_new ("main", (ValaDataType*) (_tmp1_ = vala_void_type_new (NULL)), _tmp2_ = vala_parser_get_src (self, &begin), NULL), _vala_source_reference_unref0 (_tmp2_), _vala_code_node_unref0 (_tmp1_), _tmp3_);
	vala_method_set_body (method, _tmp5_ = vala_block_new (_tmp4_ = vala_parser_get_src (self, &begin)));
	_vala_code_node_unref0 (_tmp5_);
	_vala_source_reference_unref0 (_tmp4_);
	vala_parser_parse_statements (self, vala_method_get_body (method), &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (method);
			return NULL;
		} else {
			_vala_code_node_unref0 (method);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_EOF) {
		ValaSourceReference* _tmp6_;
		vala_report_error (_tmp6_ = vala_parser_get_current_src (self), "expected end of file");
		_vala_source_reference_unref0 (_tmp6_);
	}
	vala_source_reference_set_last_line (vala_code_node_get_source_reference ((ValaCodeNode*) vala_method_get_body (method)), vala_source_reference_get_last_line (_tmp7_ = vala_parser_get_current_src (self)));
	_vala_source_reference_unref0 (_tmp7_);
	vala_source_reference_set_last_column (vala_code_node_get_source_reference ((ValaCodeNode*) vala_method_get_body (method)), vala_source_reference_get_last_column (_tmp8_ = vala_parser_get_current_src (self)));
	_vala_source_reference_unref0 (_tmp8_);
	if (!vala_code_context_get_experimental (self->priv->context)) {
		_tmp9_ = vala_code_context_get_profile (self->priv->context) != VALA_PROFILE_DOVA;
	} else {
		_tmp9_ = FALSE;
	}
	if (_tmp9_) {
		vala_report_warning (vala_code_node_get_source_reference ((ValaCodeNode*) method), "main blocks are experimental");
	}
	result = method;
	return result;
}


static ValaSymbol* vala_parser_parse_declaration (ValaParser* self, gboolean root, GError** error) {
	ValaSymbol* result = NULL;
	ValaComment* _tmp0_;
	ValaList* attrs;
	ValaSourceLocation _tmp1_ = {0};
	ValaSourceLocation begin;
	ValaTokenType last_keyword;
	char* _tmp23_;
	GError* _tmp24_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	self->priv->comment = (_tmp0_ = vala_scanner_pop_comment (self->priv->scanner), _vala_comment_unref0 (self->priv->comment), _tmp0_);
	attrs = vala_parser_parse_attributes (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	begin = (vala_parser_get_location (self, &_tmp1_), _tmp1_);
	last_keyword = vala_parser_current (self);
	while (TRUE) {
		if (!vala_parser_is_declaration_keyword (self, vala_parser_current (self))) {
			break;
		}
		last_keyword = vala_parser_current (self);
		vala_parser_next (self);
	}
	switch (vala_parser_current (self)) {
		case VALA_TOKEN_TYPE_CONSTRUCT:
		{
			if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_GOBJECT) {
				ValaConstructor* _tmp2_;
				vala_parser_rollback (self, &begin);
				_tmp2_ = vala_parser_parse_constructor_declaration (self, attrs, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (attrs);
						return NULL;
					} else {
						_vala_collection_object_unref0 (attrs);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				result = (ValaSymbol*) _tmp2_;
				_vala_collection_object_unref0 (attrs);
				return result;
			}
			break;
		}
		case VALA_TOKEN_TYPE_TILDE:
		{
			ValaDestructor* _tmp3_;
			vala_parser_rollback (self, &begin);
			_tmp3_ = vala_parser_parse_destructor_declaration (self, attrs, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp3_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		case VALA_TOKEN_TYPE_OPEN_BRACE:
		case VALA_TOKEN_TYPE_SEMICOLON:
		case VALA_TOKEN_TYPE_IF:
		case VALA_TOKEN_TYPE_SWITCH:
		case VALA_TOKEN_TYPE_WHILE:
		case VALA_TOKEN_TYPE_DO:
		case VALA_TOKEN_TYPE_FOR:
		case VALA_TOKEN_TYPE_FOREACH:
		case VALA_TOKEN_TYPE_BREAK:
		case VALA_TOKEN_TYPE_CONTINUE:
		case VALA_TOKEN_TYPE_RETURN:
		case VALA_TOKEN_TYPE_YIELD:
		case VALA_TOKEN_TYPE_THROW:
		case VALA_TOKEN_TYPE_TRY:
		case VALA_TOKEN_TYPE_LOCK:
		case VALA_TOKEN_TYPE_DELETE:
		case VALA_TOKEN_TYPE_VAR:
		case VALA_TOKEN_TYPE_OP_INC:
		case VALA_TOKEN_TYPE_OP_DEC:
		case VALA_TOKEN_TYPE_BASE:
		case VALA_TOKEN_TYPE_THIS:
		case VALA_TOKEN_TYPE_OPEN_PARENS:
		case VALA_TOKEN_TYPE_STAR:
		case VALA_TOKEN_TYPE_NEW:
		{
			ValaMethod* _tmp8_;
			if (attrs != NULL) {
				char* _tmp4_;
				GError* _tmp5_;
				_inner_error_ = (_tmp5_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp4_ = vala_parser_get_error (self, "expected statement")), _g_free0 (_tmp4_), _tmp5_);
				{
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (attrs);
						return NULL;
					} else {
						_vala_collection_object_unref0 (attrs);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
			if (!root) {
				char* _tmp6_;
				GError* _tmp7_;
				_inner_error_ = (_tmp7_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp6_ = vala_parser_get_error (self, "statements outside blocks allowed only in root namespace")), _g_free0 (_tmp6_), _tmp7_);
				{
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (attrs);
						return NULL;
					} else {
						_vala_collection_object_unref0 (attrs);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
			vala_parser_rollback (self, &begin);
			_tmp8_ = vala_parser_parse_main_block (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			result = (ValaSymbol*) _tmp8_;
			_vala_collection_object_unref0 (attrs);
			return result;
		}
		default:
		{
			if (root) {
				gboolean is_expr;
				is_expr = vala_parser_is_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (attrs);
						return NULL;
					} else {
						_vala_collection_object_unref0 (attrs);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				if (is_expr) {
					ValaMethod* _tmp9_;
					vala_parser_rollback (self, &begin);
					_tmp9_ = vala_parser_parse_main_block (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_collection_object_unref0 (attrs);
							return NULL;
						} else {
							_vala_collection_object_unref0 (attrs);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					result = (ValaSymbol*) _tmp9_;
					_vala_collection_object_unref0 (attrs);
					return result;
				}
			}
			vala_parser_skip_type (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			switch (vala_parser_current (self)) {
				case VALA_TOKEN_TYPE_OPEN_BRACE:
				case VALA_TOKEN_TYPE_SEMICOLON:
				case VALA_TOKEN_TYPE_COLON:
				{
					vala_parser_rollback (self, &begin);
					switch (last_keyword) {
						case VALA_TOKEN_TYPE_CLASS:
						{
							ValaSymbol* _tmp10_;
							_tmp10_ = vala_parser_parse_class_declaration (self, attrs, &_inner_error_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									g_propagate_error (error, _inner_error_);
									_vala_collection_object_unref0 (attrs);
									return NULL;
								} else {
									_vala_collection_object_unref0 (attrs);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return NULL;
								}
							}
							result = _tmp10_;
							_vala_collection_object_unref0 (attrs);
							return result;
						}
						case VALA_TOKEN_TYPE_ENUM:
						{
							ValaSymbol* _tmp11_;
							_tmp11_ = vala_parser_parse_enum_declaration (self, attrs, &_inner_error_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									g_propagate_error (error, _inner_error_);
									_vala_collection_object_unref0 (attrs);
									return NULL;
								} else {
									_vala_collection_object_unref0 (attrs);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return NULL;
								}
							}
							result = _tmp11_;
							_vala_collection_object_unref0 (attrs);
							return result;
						}
						case VALA_TOKEN_TYPE_ERRORDOMAIN:
						{
							ValaSymbol* _tmp12_;
							_tmp12_ = vala_parser_parse_errordomain_declaration (self, attrs, &_inner_error_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									g_propagate_error (error, _inner_error_);
									_vala_collection_object_unref0 (attrs);
									return NULL;
								} else {
									_vala_collection_object_unref0 (attrs);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return NULL;
								}
							}
							result = _tmp12_;
							_vala_collection_object_unref0 (attrs);
							return result;
						}
						case VALA_TOKEN_TYPE_INTERFACE:
						{
							ValaSymbol* _tmp13_;
							_tmp13_ = vala_parser_parse_interface_declaration (self, attrs, &_inner_error_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									g_propagate_error (error, _inner_error_);
									_vala_collection_object_unref0 (attrs);
									return NULL;
								} else {
									_vala_collection_object_unref0 (attrs);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return NULL;
								}
							}
							result = _tmp13_;
							_vala_collection_object_unref0 (attrs);
							return result;
						}
						case VALA_TOKEN_TYPE_NAMESPACE:
						{
							ValaNamespace* _tmp14_;
							_tmp14_ = vala_parser_parse_namespace_declaration (self, attrs, &_inner_error_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									g_propagate_error (error, _inner_error_);
									_vala_collection_object_unref0 (attrs);
									return NULL;
								} else {
									_vala_collection_object_unref0 (attrs);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return NULL;
								}
							}
							result = (ValaSymbol*) _tmp14_;
							_vala_collection_object_unref0 (attrs);
							return result;
						}
						case VALA_TOKEN_TYPE_STRUCT:
						{
							ValaSymbol* _tmp15_;
							_tmp15_ = vala_parser_parse_struct_declaration (self, attrs, &_inner_error_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									g_propagate_error (error, _inner_error_);
									_vala_collection_object_unref0 (attrs);
									return NULL;
								} else {
									_vala_collection_object_unref0 (attrs);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return NULL;
								}
							}
							result = _tmp15_;
							_vala_collection_object_unref0 (attrs);
							return result;
						}
						default:
						{
							break;
						}
					}
					break;
				}
				case VALA_TOKEN_TYPE_OPEN_PARENS:
				{
					ValaCreationMethod* _tmp16_;
					vala_parser_rollback (self, &begin);
					_tmp16_ = vala_parser_parse_creation_method_declaration (self, attrs, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_collection_object_unref0 (attrs);
							return NULL;
						} else {
							_vala_collection_object_unref0 (attrs);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					result = (ValaSymbol*) _tmp16_;
					_vala_collection_object_unref0 (attrs);
					return result;
				}
				default:
				{
					vala_parser_skip_type (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_collection_object_unref0 (attrs);
							return NULL;
						} else {
							_vala_collection_object_unref0 (attrs);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					switch (vala_parser_current (self)) {
						case VALA_TOKEN_TYPE_OPEN_PARENS:
						{
							vala_parser_rollback (self, &begin);
							switch (last_keyword) {
								case VALA_TOKEN_TYPE_DELEGATE:
								{
									ValaSymbol* _tmp17_;
									_tmp17_ = vala_parser_parse_delegate_declaration (self, attrs, &_inner_error_);
									if (_inner_error_ != NULL) {
										if (_inner_error_->domain == VALA_PARSE_ERROR) {
											g_propagate_error (error, _inner_error_);
											_vala_collection_object_unref0 (attrs);
											return NULL;
										} else {
											_vala_collection_object_unref0 (attrs);
											g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
											g_clear_error (&_inner_error_);
											return NULL;
										}
									}
									result = _tmp17_;
									_vala_collection_object_unref0 (attrs);
									return result;
								}
								case VALA_TOKEN_TYPE_SIGNAL:
								{
									ValaSignal* _tmp18_;
									_tmp18_ = vala_parser_parse_signal_declaration (self, attrs, &_inner_error_);
									if (_inner_error_ != NULL) {
										if (_inner_error_->domain == VALA_PARSE_ERROR) {
											g_propagate_error (error, _inner_error_);
											_vala_collection_object_unref0 (attrs);
											return NULL;
										} else {
											_vala_collection_object_unref0 (attrs);
											g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
											g_clear_error (&_inner_error_);
											return NULL;
										}
									}
									result = (ValaSymbol*) _tmp18_;
									_vala_collection_object_unref0 (attrs);
									return result;
								}
								default:
								{
									ValaMethod* _tmp19_;
									_tmp19_ = vala_parser_parse_method_declaration (self, attrs, &_inner_error_);
									if (_inner_error_ != NULL) {
										if (_inner_error_->domain == VALA_PARSE_ERROR) {
											g_propagate_error (error, _inner_error_);
											_vala_collection_object_unref0 (attrs);
											return NULL;
										} else {
											_vala_collection_object_unref0 (attrs);
											g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
											g_clear_error (&_inner_error_);
											return NULL;
										}
									}
									result = (ValaSymbol*) _tmp19_;
									_vala_collection_object_unref0 (attrs);
									return result;
								}
							}
						}
						case VALA_TOKEN_TYPE_ASSIGN:
						case VALA_TOKEN_TYPE_SEMICOLON:
						{
							vala_parser_rollback (self, &begin);
							switch (last_keyword) {
								case VALA_TOKEN_TYPE_CONST:
								{
									ValaConstant* _tmp20_;
									_tmp20_ = vala_parser_parse_constant_declaration (self, attrs, &_inner_error_);
									if (_inner_error_ != NULL) {
										if (_inner_error_->domain == VALA_PARSE_ERROR) {
											g_propagate_error (error, _inner_error_);
											_vala_collection_object_unref0 (attrs);
											return NULL;
										} else {
											_vala_collection_object_unref0 (attrs);
											g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
											g_clear_error (&_inner_error_);
											return NULL;
										}
									}
									result = (ValaSymbol*) _tmp20_;
									_vala_collection_object_unref0 (attrs);
									return result;
								}
								default:
								{
									ValaField* _tmp21_;
									_tmp21_ = vala_parser_parse_field_declaration (self, attrs, &_inner_error_);
									if (_inner_error_ != NULL) {
										if (_inner_error_->domain == VALA_PARSE_ERROR) {
											g_propagate_error (error, _inner_error_);
											_vala_collection_object_unref0 (attrs);
											return NULL;
										} else {
											_vala_collection_object_unref0 (attrs);
											g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
											g_clear_error (&_inner_error_);
											return NULL;
										}
									}
									result = (ValaSymbol*) _tmp21_;
									_vala_collection_object_unref0 (attrs);
									return result;
								}
							}
						}
						case VALA_TOKEN_TYPE_OPEN_BRACE:
						case VALA_TOKEN_TYPE_THROWS:
						{
							ValaProperty* _tmp22_;
							vala_parser_rollback (self, &begin);
							_tmp22_ = vala_parser_parse_property_declaration (self, attrs, &_inner_error_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									g_propagate_error (error, _inner_error_);
									_vala_collection_object_unref0 (attrs);
									return NULL;
								} else {
									_vala_collection_object_unref0 (attrs);
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
									g_clear_error (&_inner_error_);
									return NULL;
								}
							}
							result = (ValaSymbol*) _tmp22_;
							_vala_collection_object_unref0 (attrs);
							return result;
						}
						default:
						{
							break;
						}
					}
					break;
				}
			}
			break;
		}
	}
	vala_parser_rollback (self, &begin);
	_inner_error_ = (_tmp24_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp23_ = vala_parser_get_error (self, "expected declaration")), _g_free0 (_tmp23_), _tmp24_);
	{
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (attrs);
			return NULL;
		} else {
			_vala_collection_object_unref0 (attrs);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_vala_collection_object_unref0 (attrs);
}


static void vala_parser_parse_declarations (ValaParser* self, ValaSymbol* parent, gboolean root, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (parent != NULL);
	if (!root) {
		vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACE) {
			_tmp0_ = vala_parser_current (self) != VALA_TOKEN_TYPE_EOF;
		} else {
			_tmp0_ = FALSE;
		}
		if (!_tmp0_) {
			break;
		}
		{
			if (VALA_IS_NAMESPACE (parent)) {
				vala_parser_parse_namespace_member (self, VALA_NAMESPACE (parent), parent == VALA_SYMBOL (vala_code_context_get_root (self->priv->context)), &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						goto __catch7_vala_parse_error;
					}
					g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return;
				}
			} else {
				if (VALA_IS_CLASS (parent)) {
					vala_parser_parse_class_member (self, VALA_CLASS (parent), &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							goto __catch7_vala_parse_error;
						}
						g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				} else {
					if (VALA_IS_STRUCT (parent)) {
						vala_parser_parse_struct_member (self, VALA_STRUCT (parent), &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								goto __catch7_vala_parse_error;
							}
							g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return;
						}
					} else {
						if (VALA_IS_INTERFACE (parent)) {
							vala_parser_parse_interface_member (self, VALA_INTERFACE (parent), &_inner_error_);
							if (_inner_error_ != NULL) {
								if (_inner_error_->domain == VALA_PARSE_ERROR) {
									goto __catch7_vala_parse_error;
								}
								g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return;
							}
						}
					}
				}
			}
		}
		goto __finally7;
		__catch7_vala_parse_error:
		{
			GError * e;
			e = _inner_error_;
			_inner_error_ = NULL;
			{
				gint r = 0;
				while (TRUE) {
					r = (gint) vala_parser_recover (self);
					if (r == VALA_PARSER_RECOVERY_STATE_STATEMENT_BEGIN) {
						vala_parser_next (self);
					} else {
						break;
					}
				}
				if (r == VALA_PARSER_RECOVERY_STATE_EOF) {
					_g_error_free0 (e);
					return;
				}
				_g_error_free0 (e);
			}
		}
		__finally7:
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
	if (!root) {
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_CLOSE_BRACE)) {
			if (vala_report_get_errors (vala_code_context_get_report (self->priv->context)) == 0) {
				ValaSourceReference* _tmp1_;
				vala_report_error (_tmp1_ = vala_parser_get_current_src (self), "expected `}'");
				_vala_source_reference_unref0 (_tmp1_);
			}
		}
	}
}


static ValaParserRecoveryState vala_parser_recover (ValaParser* self) {
	ValaParserRecoveryState result = 0;
	g_return_val_if_fail (self != NULL, 0);
	while (TRUE) {
		if (!(vala_parser_current (self) != VALA_TOKEN_TYPE_EOF)) {
			break;
		}
		switch (vala_parser_current (self)) {
			case VALA_TOKEN_TYPE_ABSTRACT:
			case VALA_TOKEN_TYPE_CLASS:
			case VALA_TOKEN_TYPE_CONST:
			case VALA_TOKEN_TYPE_CONSTRUCT:
			case VALA_TOKEN_TYPE_DELEGATE:
			case VALA_TOKEN_TYPE_ENUM:
			case VALA_TOKEN_TYPE_ERRORDOMAIN:
			case VALA_TOKEN_TYPE_EXTERN:
			case VALA_TOKEN_TYPE_INLINE:
			case VALA_TOKEN_TYPE_INTERFACE:
			case VALA_TOKEN_TYPE_INTERNAL:
			case VALA_TOKEN_TYPE_NAMESPACE:
			case VALA_TOKEN_TYPE_NEW:
			case VALA_TOKEN_TYPE_OVERRIDE:
			case VALA_TOKEN_TYPE_PRIVATE:
			case VALA_TOKEN_TYPE_PROTECTED:
			case VALA_TOKEN_TYPE_PUBLIC:
			case VALA_TOKEN_TYPE_SEALED:
			case VALA_TOKEN_TYPE_SIGNAL:
			case VALA_TOKEN_TYPE_STATIC:
			case VALA_TOKEN_TYPE_STRUCT:
			case VALA_TOKEN_TYPE_VIRTUAL:
			case VALA_TOKEN_TYPE_VOLATILE:
			{
				result = VALA_PARSER_RECOVERY_STATE_DECLARATION_BEGIN;
				return result;
			}
			case VALA_TOKEN_TYPE_BREAK:
			case VALA_TOKEN_TYPE_CONTINUE:
			case VALA_TOKEN_TYPE_DELETE:
			case VALA_TOKEN_TYPE_DO:
			case VALA_TOKEN_TYPE_FOR:
			case VALA_TOKEN_TYPE_FOREACH:
			case VALA_TOKEN_TYPE_IF:
			case VALA_TOKEN_TYPE_LOCK:
			case VALA_TOKEN_TYPE_RETURN:
			case VALA_TOKEN_TYPE_SWITCH:
			case VALA_TOKEN_TYPE_THROW:
			case VALA_TOKEN_TYPE_TRY:
			case VALA_TOKEN_TYPE_VAR:
			case VALA_TOKEN_TYPE_WHILE:
			case VALA_TOKEN_TYPE_YIELD:
			{
				result = VALA_PARSER_RECOVERY_STATE_STATEMENT_BEGIN;
				return result;
			}
			default:
			{
				vala_parser_next (self);
				break;
			}
		}
	}
	result = VALA_PARSER_RECOVERY_STATE_EOF;
	return result;
}


static gpointer _vala_collection_object_ref0 (gpointer self) {
	return self ? vala_collection_object_ref (self) : NULL;
}


static ValaNamespace* vala_parser_parse_namespace_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaNamespace* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaUnresolvedSymbol* sym;
	ValaSourceReference* _tmp1_;
	ValaNamespace* _tmp2_;
	ValaNamespace* ns;
	ValaList* old_using_directives;
	ValaNamespace* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_NAMESPACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	sym = vala_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	ns = (_tmp2_ = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), _tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	if (self->priv->comment != NULL) {
		ValaComment* _tmp3_;
		vala_namespace_add_comment (ns, self->priv->comment);
		self->priv->comment = (_tmp3_ = NULL, _vala_comment_unref0 (self->priv->comment), _tmp3_);
	}
	vala_parser_set_attributes (self, (ValaCodeNode*) ns, attrs);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	old_using_directives = _vala_collection_object_ref0 (vala_source_file_get_current_using_directives (vala_scanner_get_source_file (self->priv->scanner)));
	vala_parser_parse_using_directives (self, ns, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (old_using_directives);
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_collection_object_unref0 (old_using_directives);
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_parse_declarations (self, (ValaSymbol*) ns, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_collection_object_unref0 (old_using_directives);
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_collection_object_unref0 (old_using_directives);
			_vala_code_node_unref0 (ns);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_source_file_set_current_using_directives (vala_scanner_get_source_file (self->priv->scanner), old_using_directives);
	if (!vala_parser_accept (self, VALA_TOKEN_TYPE_CLOSE_BRACE)) {
		if (vala_report_get_errors (vala_code_context_get_report (self->priv->context)) == 0) {
			ValaSourceReference* _tmp4_;
			vala_report_error (_tmp4_ = vala_parser_get_current_src (self), "expected `}'");
			_vala_source_reference_unref0 (_tmp4_);
		}
	}
	_result_ = _vala_code_node_ref0 (ns);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp5_;
		ValaNamespace* _tmp6_;
		ValaNamespace* _tmp7_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp5_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp5_);
		ns = (_tmp6_ = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) _result_)), _vala_code_node_unref0 (ns), _tmp6_);
		vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		_result_ = (_tmp7_ = _vala_code_node_ref0 (ns), _vala_code_node_unref0 (_result_), _tmp7_);
	}
	result = _result_;
	_vala_collection_object_unref0 (old_using_directives);
	_vala_code_node_unref0 (ns);
	_vala_code_node_unref0 (sym);
	return result;
}


static void vala_parser_parse_namespace_member (ValaParser* self, ValaNamespace* ns, gboolean root, GError** error) {
	ValaSymbol* sym;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (ns != NULL);
	sym = vala_parser_parse_declaration (self, root, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (VALA_IS_NAMESPACE (sym)) {
		vala_namespace_add_namespace (ns, VALA_NAMESPACE (sym));
	} else {
		if (VALA_IS_CLASS (sym)) {
			vala_namespace_add_class (ns, VALA_CLASS (sym));
		} else {
			if (VALA_IS_INTERFACE (sym)) {
				vala_namespace_add_interface (ns, VALA_INTERFACE (sym));
			} else {
				if (VALA_IS_STRUCT (sym)) {
					vala_namespace_add_struct (ns, VALA_STRUCT (sym));
				} else {
					if (VALA_IS_ENUM (sym)) {
						vala_namespace_add_enum (ns, VALA_ENUM (sym));
					} else {
						if (VALA_IS_ERROR_DOMAIN (sym)) {
							vala_namespace_add_error_domain (ns, VALA_ERROR_DOMAIN (sym));
						} else {
							if (VALA_IS_DELEGATE (sym)) {
								vala_namespace_add_delegate (ns, VALA_DELEGATE (sym));
							} else {
								if (VALA_IS_METHOD (sym)) {
									ValaMethod* method;
									method = _vala_code_node_ref0 (VALA_METHOD (sym));
									if (vala_method_get_binding (method) == MEMBER_BINDING_INSTANCE) {
										vala_method_set_binding (method, MEMBER_BINDING_STATIC);
									}
									vala_namespace_add_method (ns, method);
									_vala_code_node_unref0 (method);
								} else {
									if (VALA_IS_FIELD (sym)) {
										ValaField* field;
										field = _vala_code_node_ref0 (VALA_FIELD (sym));
										if (vala_field_get_binding (field) == MEMBER_BINDING_INSTANCE) {
											vala_field_set_binding (field, MEMBER_BINDING_STATIC);
										}
										vala_namespace_add_field (ns, field);
										_vala_code_node_unref0 (field);
									} else {
										if (VALA_IS_CONSTANT (sym)) {
											vala_namespace_add_constant (ns, VALA_CONSTANT (sym));
										} else {
											vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) sym), "unexpected declaration in namespace");
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	vala_source_file_add_node (vala_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) sym);
	_vala_code_node_unref0 (sym);
}


static void vala_parser_parse_using_directives (ValaParser* self, ValaNamespace* ns, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (ns != NULL);
	while (TRUE) {
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_USING)) {
			break;
		}
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				ValaSourceLocation _tmp1_ = {0};
				ValaSourceLocation begin;
				ValaUnresolvedSymbol* sym;
				ValaSourceReference* _tmp2_;
				ValaUsingDirective* _tmp3_;
				ValaUsingDirective* ns_ref;
				if (!_tmp0_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				begin = (vala_parser_get_location (self, &_tmp1_), _tmp1_);
				sym = vala_parser_parse_symbol_name (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
				ns_ref = (_tmp3_ = vala_using_directive_new ((ValaSymbol*) sym, _tmp2_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp2_), _tmp3_);
				vala_source_file_add_using_directive (vala_scanner_get_source_file (self->priv->scanner), ns_ref);
				vala_namespace_add_using_directive (ns, ns_ref);
				_vala_code_node_unref0 (ns_ref);
				_vala_code_node_unref0 (sym);
			}
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
}


static ValaSymbol* vala_parser_parse_class_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSymbolAccessibility access;
	ValaParserModifierFlags flags;
	ValaUnresolvedSymbol* sym;
	ValaList* type_param_list;
	ValaArrayList* base_types;
	ValaSourceReference* _tmp4_;
	ValaClass* _tmp5_;
	ValaClass* cl;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	ValaSymbol* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	flags = vala_parser_parse_type_declaration_modifiers (self);
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLASS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	sym = vala_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_param_list = vala_parser_parse_type_parameter_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	base_types = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_COLON)) {
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				ValaDataType* _tmp2_;
				ValaDataType* _tmp3_;
				if (!_tmp1_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp1_ = FALSE;
				_tmp2_ = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (base_types);
						_vala_collection_object_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						return NULL;
					} else {
						_vala_collection_object_unref0 (base_types);
						_vala_collection_object_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) base_types, _tmp3_ = _tmp2_);
				_vala_code_node_unref0 (_tmp3_);
			}
		}
	}
	cl = (_tmp5_ = vala_class_new (vala_symbol_get_name ((ValaSymbol*) sym), _tmp4_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp4_), _tmp5_);
	vala_symbol_set_access ((ValaSymbol*) cl, access);
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_PARSER_MODIFIER_FLAGS_ABSTRACT) {
		vala_class_set_is_abstract (cl, TRUE);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp6_ = TRUE;
	} else {
		_tmp6_ = vala_source_file_get_external_package (vala_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp6_) {
		vala_symbol_set_external ((ValaSymbol*) cl, TRUE);
	}
	vala_parser_set_attributes (self, (ValaCodeNode*) cl, attrs);
	{
		ValaIterator* _type_param_it;
		_type_param_it = vala_iterable_iterator ((ValaIterable*) type_param_list);
		while (TRUE) {
			ValaTypeParameter* type_param;
			if (!vala_iterator_next (_type_param_it)) {
				break;
			}
			type_param = (ValaTypeParameter*) vala_iterator_get (_type_param_it);
			vala_object_type_symbol_add_type_parameter ((ValaObjectTypeSymbol*) cl, type_param);
			_vala_code_node_unref0 (type_param);
		}
		_vala_collection_object_unref0 (_type_param_it);
	}
	{
		ValaIterator* _base_type_it;
		_base_type_it = vala_iterable_iterator ((ValaIterable*) base_types);
		while (TRUE) {
			ValaDataType* base_type;
			if (!vala_iterator_next (_base_type_it)) {
				break;
			}
			base_type = (ValaDataType*) vala_iterator_get (_base_type_it);
			vala_class_add_base_type (cl, base_type);
			_vala_code_node_unref0 (base_type);
		}
		_vala_collection_object_unref0 (_base_type_it);
	}
	vala_parser_parse_declarations (self, (ValaSymbol*) cl, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (cl);
			_vala_collection_object_unref0 (base_types);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (cl);
			_vala_collection_object_unref0 (base_types);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (!vala_source_file_get_external_package (vala_scanner_get_source_file (self->priv->scanner))) {
		_tmp7_ = vala_class_get_default_construction_method (cl) == NULL;
	} else {
		_tmp7_ = FALSE;
	}
	if (_tmp7_) {
		ValaCreationMethod* m;
		ValaBlock* _tmp8_;
		m = vala_creation_method_new (vala_symbol_get_name ((ValaSymbol*) cl), NULL, vala_code_node_get_source_reference ((ValaCodeNode*) cl), NULL);
		vala_symbol_set_access ((ValaSymbol*) m, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
		vala_method_set_body ((ValaMethod*) m, _tmp8_ = vala_block_new (vala_code_node_get_source_reference ((ValaCodeNode*) cl)));
		_vala_code_node_unref0 (_tmp8_);
		vala_class_add_method (cl, (ValaMethod*) m);
		_vala_code_node_unref0 (m);
	}
	_result_ = _vala_code_node_ref0 ((ValaSymbol*) cl);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp9_;
		ValaNamespace* ns;
		ValaSymbol* _tmp10_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp9_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp9_);
		ns = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) cl));
		if (VALA_IS_NAMESPACE (_result_)) {
			vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		} else {
			vala_namespace_add_class (ns, VALA_CLASS (_result_));
			vala_source_file_add_node (vala_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) _result_);
		}
		_result_ = (_tmp10_ = _vala_code_node_ref0 ((ValaSymbol*) ns), _vala_code_node_unref0 (_result_), _tmp10_);
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (cl);
	_vala_collection_object_unref0 (base_types);
	_vala_collection_object_unref0 (type_param_list);
	_vala_code_node_unref0 (sym);
	return result;
}


static void vala_parser_parse_class_member (ValaParser* self, ValaClass* cl, GError** error) {
	ValaSymbol* sym;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (cl != NULL);
	sym = vala_parser_parse_declaration (self, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (VALA_IS_CLASS (sym)) {
		vala_class_add_class (cl, VALA_CLASS (sym));
	} else {
		if (VALA_IS_STRUCT (sym)) {
			vala_class_add_struct (cl, VALA_STRUCT (sym));
		} else {
			if (VALA_IS_ENUM (sym)) {
				vala_class_add_enum (cl, VALA_ENUM (sym));
			} else {
				if (VALA_IS_DELEGATE (sym)) {
					vala_class_add_delegate (cl, VALA_DELEGATE (sym));
				} else {
					if (VALA_IS_METHOD (sym)) {
						vala_class_add_method (cl, VALA_METHOD (sym));
					} else {
						if (VALA_IS_SIGNAL (sym)) {
							vala_class_add_signal (cl, VALA_SIGNAL (sym));
						} else {
							if (VALA_IS_FIELD (sym)) {
								vala_class_add_field (cl, VALA_FIELD (sym));
							} else {
								if (VALA_IS_CONSTANT (sym)) {
									vala_class_add_constant (cl, VALA_CONSTANT (sym));
								} else {
									if (VALA_IS_PROPERTY (sym)) {
										vala_class_add_property (cl, VALA_PROPERTY (sym));
									} else {
										if (VALA_IS_CONSTRUCTOR (sym)) {
											ValaConstructor* c;
											c = _vala_code_node_ref0 (VALA_CONSTRUCTOR (sym));
											if (vala_constructor_get_binding (c) == MEMBER_BINDING_INSTANCE) {
												if (vala_class_get_constructor (cl) != NULL) {
													vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) c), "class already contains a constructor");
												}
												vala_class_set_constructor (cl, c);
											} else {
												if (vala_constructor_get_binding (c) == MEMBER_BINDING_CLASS) {
													if (vala_class_get_class_constructor (cl) != NULL) {
														vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) c), "class already contains a class constructor");
													}
													vala_class_set_class_constructor (cl, c);
												} else {
													if (vala_class_get_static_constructor (cl) != NULL) {
														vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) c), "class already contains a static constructor");
													}
													vala_class_set_static_constructor (cl, c);
												}
											}
											_vala_code_node_unref0 (c);
										} else {
											if (VALA_IS_DESTRUCTOR (sym)) {
												ValaDestructor* d;
												d = _vala_code_node_ref0 (VALA_DESTRUCTOR (sym));
												if (vala_destructor_get_binding (d) == MEMBER_BINDING_STATIC) {
													if (vala_class_get_static_destructor (cl) != NULL) {
														vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) d), "class already contains a static destructor");
													}
													vala_class_set_static_destructor (cl, VALA_DESTRUCTOR (d));
												} else {
													if (vala_destructor_get_binding (d) == MEMBER_BINDING_CLASS) {
														if (vala_class_get_class_destructor (cl) != NULL) {
															vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) d), "class already contains a class destructor");
														}
														vala_class_set_class_destructor (cl, VALA_DESTRUCTOR (d));
													} else {
														if (vala_class_get_destructor (cl) != NULL) {
															vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) d), "class already contains a destructor");
														}
														vala_class_set_destructor (cl, VALA_DESTRUCTOR (d));
													}
												}
												_vala_code_node_unref0 (d);
											} else {
												vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) sym), "unexpected declaration in class");
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_vala_code_node_unref0 (sym);
}


static ValaConstant* vala_parser_parse_constant_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaConstant* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSymbolAccessibility access;
	ValaParserModifierFlags flags;
	ValaDataType* type;
	char* id;
	ValaDataType* _tmp1_;
	ValaDataType* _tmp2_;
	ValaExpression* initializer;
	ValaDataType* _tmp5_;
	ValaArrayType* array_type;
	ValaSourceReference* _tmp6_;
	ValaConstant* _tmp7_;
	ValaConstant* c;
	gboolean _tmp8_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	flags = vala_parser_parse_member_declaration_modifiers (self);
	vala_parser_expect (self, VALA_TOKEN_TYPE_CONST, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = vala_parser_parse_type (self, FALSE, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	id = vala_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_parser_parse_inline_array_type (self, type, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (type), _tmp2_);
	initializer = NULL;
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_ASSIGN)) {
		ValaExpression* _tmp3_;
		ValaExpression* _tmp4_;
		_tmp3_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (initializer);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (initializer);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		initializer = (_tmp4_ = _tmp3_, _vala_code_node_unref0 (initializer), _tmp4_);
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (initializer);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (initializer);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	array_type = _vala_code_node_ref0 ((_tmp5_ = type, VALA_IS_ARRAY_TYPE (_tmp5_) ? ((ValaArrayType*) _tmp5_) : NULL));
	if (array_type != NULL) {
		vala_data_type_set_value_owned (vala_array_type_get_element_type (array_type), FALSE);
	}
	c = (_tmp7_ = vala_constant_new (id, type, initializer, _tmp6_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp6_), _tmp7_);
	vala_symbol_set_access ((ValaSymbol*) c, access);
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp8_ = TRUE;
	} else {
		_tmp8_ = vala_source_file_get_external_package (vala_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp8_) {
		vala_symbol_set_external ((ValaSymbol*) c, TRUE);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_NEW) == VALA_PARSER_MODIFIER_FLAGS_NEW) {
		vala_symbol_set_hides ((ValaSymbol*) c, TRUE);
	}
	vala_parser_set_attributes (self, (ValaCodeNode*) c, attrs);
	result = c;
	_vala_code_node_unref0 (array_type);
	_vala_code_node_unref0 (initializer);
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaField* vala_parser_parse_field_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaField* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSymbolAccessibility access;
	ValaParserModifierFlags flags;
	ValaDataType* type;
	char* id;
	ValaDataType* _tmp1_;
	ValaDataType* _tmp2_;
	ValaSourceReference* _tmp3_;
	ValaField* _tmp4_;
	ValaField* f;
	gboolean _tmp5_ = FALSE;
	gboolean _tmp6_ = FALSE;
	gboolean _tmp7_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	flags = vala_parser_parse_member_declaration_modifiers (self);
	if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
		vala_parser_accept (self, VALA_TOKEN_TYPE_VOLATILE);
	}
	type = vala_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	id = vala_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_parser_parse_inline_array_type (self, type, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (type), _tmp2_);
	f = (_tmp4_ = vala_field_new (id, type, NULL, _tmp3_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	vala_symbol_set_access ((ValaSymbol*) f, access);
	vala_parser_set_attributes (self, (ValaCodeNode*) f, attrs);
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_STATIC) == VALA_PARSER_MODIFIER_FLAGS_STATIC) {
		vala_field_set_binding (f, MEMBER_BINDING_STATIC);
	} else {
		if ((flags & VALA_PARSER_MODIFIER_FLAGS_CLASS) == VALA_PARSER_MODIFIER_FLAGS_CLASS) {
			vala_field_set_binding (f, MEMBER_BINDING_CLASS);
		}
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_PARSER_MODIFIER_FLAGS_ABSTRACT) {
		_tmp6_ = TRUE;
	} else {
		_tmp6_ = (flags & VALA_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_PARSER_MODIFIER_FLAGS_VIRTUAL;
	}
	if (_tmp6_) {
		_tmp5_ = TRUE;
	} else {
		_tmp5_ = (flags & VALA_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_PARSER_MODIFIER_FLAGS_OVERRIDE;
	}
	if (_tmp5_) {
		vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) f), "abstract, virtual, and override modifiers are not applicable to fields");
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp7_ = TRUE;
	} else {
		_tmp7_ = vala_source_file_get_external_package (vala_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp7_) {
		vala_symbol_set_external ((ValaSymbol*) f, TRUE);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_NEW) == VALA_PARSER_MODIFIER_FLAGS_NEW) {
		vala_symbol_set_hides ((ValaSymbol*) f, TRUE);
	}
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_ASSIGN)) {
		ValaExpression* _tmp8_;
		ValaExpression* _tmp9_;
		_tmp8_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (f);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (f);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_variable_set_initializer ((ValaVariable*) f, _tmp9_ = _tmp8_);
		_vala_code_node_unref0 (_tmp9_);
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (f);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (f);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = f;
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaInitializerList* vala_parser_parse_initializer (ValaParser* self, GError** error) {
	ValaInitializerList* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaInitializerList* _tmp2_;
	ValaInitializerList* initializer;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	initializer = (_tmp2_ = vala_initializer_list_new (_tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACE) {
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				ValaExpression* init;
				if (!_tmp3_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp3_ = FALSE;
				init = vala_parser_parse_argument (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (initializer);
						return NULL;
					} else {
						_vala_code_node_unref0 (initializer);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_initializer_list_append (initializer, init);
				_vala_code_node_unref0 (init);
			}
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (initializer);
			return NULL;
		} else {
			_vala_code_node_unref0 (initializer);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = initializer;
	return result;
}


static ValaListLiteral* vala_parser_parse_list_literal (ValaParser* self, GError** error) {
	ValaListLiteral* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaListLiteral* _tmp2_;
	ValaListLiteral* initializer;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACKET, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	initializer = (_tmp2_ = vala_list_literal_new (_tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACKET) {
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				ValaExpression* init;
				if (!_tmp3_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp3_ = FALSE;
				init = vala_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (initializer);
						return NULL;
					} else {
						_vala_code_node_unref0 (initializer);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_list_literal_add_expression (initializer, init);
				_vala_code_node_unref0 (init);
			}
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACKET, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (initializer);
			return NULL;
		} else {
			_vala_code_node_unref0 (initializer);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = initializer;
	return result;
}


static ValaExpression* vala_parser_parse_set_literal (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaSetLiteral* _tmp2_;
	ValaSetLiteral* set;
	gboolean first;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	set = (_tmp2_ = vala_set_literal_new (_tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	first = TRUE;
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACE) {
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				ValaExpression* expr;
				gboolean _tmp4_ = FALSE;
				if (!_tmp3_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp3_ = FALSE;
				expr = vala_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (set);
						return NULL;
					} else {
						_vala_code_node_unref0 (set);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				if (first) {
					_tmp4_ = vala_parser_accept (self, VALA_TOKEN_TYPE_COLON);
				} else {
					_tmp4_ = FALSE;
				}
				if (_tmp4_) {
					ValaExpression* _tmp5_;
					vala_parser_rollback (self, &begin);
					_tmp5_ = vala_parser_parse_map_literal (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (expr);
							_vala_code_node_unref0 (set);
							return NULL;
						} else {
							_vala_code_node_unref0 (expr);
							_vala_code_node_unref0 (set);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					result = _tmp5_;
					_vala_code_node_unref0 (expr);
					_vala_code_node_unref0 (set);
					return result;
				}
				first = FALSE;
				vala_set_literal_add_expression (set, expr);
				_vala_code_node_unref0 (expr);
			}
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (set);
			return NULL;
		} else {
			_vala_code_node_unref0 (set);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (ValaExpression*) set;
	return result;
}


static ValaExpression* vala_parser_parse_map_literal (ValaParser* self, GError** error) {
	ValaExpression* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSourceReference* _tmp1_;
	ValaMapLiteral* _tmp2_;
	ValaMapLiteral* map;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	map = (_tmp2_ = vala_map_literal_new (_tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACE) {
		{
			gboolean _tmp3_;
			_tmp3_ = TRUE;
			while (TRUE) {
				ValaExpression* key;
				ValaExpression* value;
				if (!_tmp3_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp3_ = FALSE;
				key = vala_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (map);
						return NULL;
					} else {
						_vala_code_node_unref0 (map);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_map_literal_add_key (map, key);
				vala_parser_expect (self, VALA_TOKEN_TYPE_COLON, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (key);
						_vala_code_node_unref0 (map);
						return NULL;
					} else {
						_vala_code_node_unref0 (key);
						_vala_code_node_unref0 (map);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				value = vala_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (key);
						_vala_code_node_unref0 (map);
						return NULL;
					} else {
						_vala_code_node_unref0 (key);
						_vala_code_node_unref0 (map);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_map_literal_add_value (map, value);
				_vala_code_node_unref0 (value);
				_vala_code_node_unref0 (key);
			}
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (map);
			return NULL;
		} else {
			_vala_code_node_unref0 (map);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	result = (ValaExpression*) map;
	return result;
}


static ValaMethod* vala_parser_parse_method_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaMethod* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSymbolAccessibility access;
	ValaParserModifierFlags flags;
	ValaDataType* type;
	char* id;
	ValaList* type_param_list;
	ValaSourceReference* _tmp1_;
	ValaMethod* _tmp2_;
	ValaMethod* method;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	flags = vala_parser_parse_member_declaration_modifiers (self);
	type = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	id = vala_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_param_list = vala_parser_parse_type_parameter_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	method = (_tmp2_ = vala_method_new (id, type, _tmp1_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	vala_symbol_set_access ((ValaSymbol*) method, access);
	vala_parser_set_attributes (self, (ValaCodeNode*) method, attrs);
	{
		ValaIterator* _type_param_it;
		_type_param_it = vala_iterable_iterator ((ValaIterable*) type_param_list);
		while (TRUE) {
			ValaTypeParameter* type_param;
			if (!vala_iterator_next (_type_param_it)) {
				break;
			}
			type_param = (ValaTypeParameter*) vala_iterator_get (_type_param_it);
			vala_method_add_type_parameter (method, type_param);
			_vala_code_node_unref0 (type_param);
		}
		_vala_collection_object_unref0 (_type_param_it);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_STATIC) == VALA_PARSER_MODIFIER_FLAGS_STATIC) {
		vala_method_set_binding (method, MEMBER_BINDING_STATIC);
	} else {
		if ((flags & VALA_PARSER_MODIFIER_FLAGS_CLASS) == VALA_PARSER_MODIFIER_FLAGS_CLASS) {
			vala_method_set_binding (method, MEMBER_BINDING_CLASS);
		}
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_ASYNC) == VALA_PARSER_MODIFIER_FLAGS_ASYNC) {
		vala_method_set_coroutine (method, TRUE);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_NEW) == VALA_PARSER_MODIFIER_FLAGS_NEW) {
		vala_symbol_set_hides ((ValaSymbol*) method, TRUE);
	}
	if (vala_method_get_binding (method) == MEMBER_BINDING_INSTANCE) {
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_ = FALSE;
		if ((flags & VALA_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_PARSER_MODIFIER_FLAGS_ABSTRACT) {
			vala_method_set_is_abstract (method, TRUE);
		}
		if ((flags & VALA_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_PARSER_MODIFIER_FLAGS_VIRTUAL) {
			vala_method_set_is_virtual (method, TRUE);
		}
		if ((flags & VALA_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_PARSER_MODIFIER_FLAGS_OVERRIDE) {
			vala_method_set_overrides (method, TRUE);
		}
		if (vala_method_get_is_abstract (method)) {
			_tmp5_ = vala_method_get_is_virtual (method);
		} else {
			_tmp5_ = FALSE;
		}
		if (_tmp5_) {
			_tmp4_ = TRUE;
		} else {
			gboolean _tmp6_ = FALSE;
			if (vala_method_get_is_abstract (method)) {
				_tmp6_ = vala_method_get_overrides (method);
			} else {
				_tmp6_ = FALSE;
			}
			_tmp4_ = _tmp6_;
		}
		if (_tmp4_) {
			_tmp3_ = TRUE;
		} else {
			gboolean _tmp7_ = FALSE;
			if (vala_method_get_is_virtual (method)) {
				_tmp7_ = vala_method_get_overrides (method);
			} else {
				_tmp7_ = FALSE;
			}
			_tmp3_ = _tmp7_;
		}
		if (_tmp3_) {
			char* _tmp8_;
			GError* _tmp9_;
			_inner_error_ = (_tmp9_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp8_ = vala_parser_get_error (self, "only one of `abstract', `virtual', or `override' may be specified")), _g_free0 (_tmp8_), _tmp9_);
			{
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (method);
					_vala_collection_object_unref0 (type_param_list);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return NULL;
				} else {
					_vala_code_node_unref0 (method);
					_vala_collection_object_unref0 (type_param_list);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	} else {
		gboolean _tmp10_ = FALSE;
		gboolean _tmp11_ = FALSE;
		if ((flags & VALA_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_PARSER_MODIFIER_FLAGS_ABSTRACT) {
			_tmp11_ = TRUE;
		} else {
			_tmp11_ = (flags & VALA_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_PARSER_MODIFIER_FLAGS_VIRTUAL;
		}
		if (_tmp11_) {
			_tmp10_ = TRUE;
		} else {
			_tmp10_ = (flags & VALA_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_PARSER_MODIFIER_FLAGS_OVERRIDE;
		}
		if (_tmp10_) {
			char* _tmp12_;
			GError* _tmp13_;
			_inner_error_ = (_tmp13_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp12_ = vala_parser_get_error (self, "the modifiers `abstract', `virtual', and `override' are not valid for " \
"static methods")), _g_free0 (_tmp12_), _tmp13_);
			{
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (method);
					_vala_collection_object_unref0 (type_param_list);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return NULL;
				} else {
					_vala_code_node_unref0 (method);
					_vala_collection_object_unref0 (type_param_list);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_INLINE) == VALA_PARSER_MODIFIER_FLAGS_INLINE) {
		vala_method_set_is_inline (method, TRUE);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_PARSER_MODIFIER_FLAGS_EXTERN) {
		vala_symbol_set_external ((ValaSymbol*) method, TRUE);
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (method);
			_vala_collection_object_unref0 (type_param_list);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (method);
			_vala_collection_object_unref0 (type_param_list);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp14_;
			_tmp14_ = TRUE;
			while (TRUE) {
				ValaFormalParameter* param;
				if (!_tmp14_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp14_ = FALSE;
				param = vala_parser_parse_parameter (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_collection_object_unref0 (type_param_list);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_method_add_parameter (method, param);
				_vala_code_node_unref0 (param);
			}
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (method);
			_vala_collection_object_unref0 (type_param_list);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (method);
			_vala_collection_object_unref0 (type_param_list);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
		ValaUnresolvedSymbol* _tmp15_;
		ValaUnresolvedSymbol* _tmp16_;
		ValaUnresolvedType* _tmp17_;
		ValaUnresolvedType* error_type;
		error_type = (_tmp17_ = vala_unresolved_type_new_from_symbol (_tmp16_ = vala_unresolved_symbol_new (_tmp15_ = vala_unresolved_symbol_new (NULL, "Dova", NULL), "Error", NULL), vala_code_node_get_source_reference ((ValaCodeNode*) method)), _vala_code_node_unref0 (_tmp16_), _vala_code_node_unref0 (_tmp15_), _tmp17_);
		vala_code_node_add_error_type ((ValaCodeNode*) method, (ValaDataType*) error_type);
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_THROWS)) {
			{
				gboolean _tmp18_;
				_tmp18_ = TRUE;
				while (TRUE) {
					ValaDataType* _tmp19_;
					if (!_tmp18_) {
						if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp18_ = FALSE;
					_tmp19_ = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
					_vala_code_node_unref0 (_tmp19_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (error_type);
							_vala_code_node_unref0 (method);
							_vala_collection_object_unref0 (type_param_list);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (error_type);
							_vala_code_node_unref0 (method);
							_vala_collection_object_unref0 (type_param_list);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
			}
			vala_report_warning (vala_code_node_get_source_reference ((ValaCodeNode*) method), "`throws' is ignored in the Dova profile");
		}
		_vala_code_node_unref0 (error_type);
	} else {
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_THROWS)) {
			{
				gboolean _tmp20_;
				_tmp20_ = TRUE;
				while (TRUE) {
					ValaDataType* _tmp21_;
					ValaDataType* _tmp22_;
					if (!_tmp20_) {
						if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp20_ = FALSE;
					_tmp21_ = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (method);
							_vala_collection_object_unref0 (type_param_list);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (method);
							_vala_collection_object_unref0 (type_param_list);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_code_node_add_error_type ((ValaCodeNode*) method, _tmp22_ = _tmp21_);
					_vala_code_node_unref0 (_tmp22_);
				}
			}
		}
	}
	while (TRUE) {
		ValaExpression* _tmp23_;
		ValaExpression* _tmp24_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_REQUIRES)) {
			break;
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp23_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_method_add_precondition (method, _tmp24_ = _tmp23_);
		_vala_code_node_unref0 (_tmp24_);
		vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	while (TRUE) {
		ValaExpression* _tmp25_;
		ValaExpression* _tmp26_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_ENSURES)) {
			break;
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp25_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_method_add_postcondition (method, _tmp26_ = _tmp25_);
		_vala_code_node_unref0 (_tmp26_);
		vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	if (!vala_parser_accept (self, VALA_TOKEN_TYPE_SEMICOLON)) {
		ValaBlock* _tmp27_;
		ValaBlock* _tmp28_;
		_tmp27_ = vala_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_collection_object_unref0 (type_param_list);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_method_set_body (method, _tmp28_ = _tmp27_);
		_vala_code_node_unref0 (_tmp28_);
	} else {
		if (vala_source_file_get_external_package (vala_scanner_get_source_file (self->priv->scanner))) {
			vala_symbol_set_external ((ValaSymbol*) method, TRUE);
		}
	}
	result = method;
	_vala_collection_object_unref0 (type_param_list);
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaProperty* vala_parser_parse_property_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaProperty* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSymbolAccessibility access;
	ValaParserModifierFlags flags;
	ValaDataType* type;
	gboolean getter_owned;
	char* id;
	ValaSourceReference* _tmp2_;
	ValaProperty* _tmp3_;
	ValaProperty* prop;
	gboolean _tmp4_ = FALSE;
	gboolean _tmp31_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	flags = vala_parser_parse_member_declaration_modifiers (self);
	type = vala_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	getter_owned = FALSE;
	if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
		getter_owned = TRUE;
	} else {
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_HASH)) {
			if (!vala_code_context_get_deprecated (self->priv->context)) {
				ValaSourceReference* _tmp1_;
				vala_report_warning (_tmp1_ = vala_parser_get_last_src (self), "deprecated syntax, use `owned` modifier before `get'");
				_vala_source_reference_unref0 (_tmp1_);
			}
			getter_owned = TRUE;
		}
	}
	id = vala_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	prop = (_tmp3_ = vala_property_new (id, type, NULL, NULL, _tmp2_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp2_), _tmp3_);
	vala_symbol_set_access ((ValaSymbol*) prop, access);
	vala_parser_set_attributes (self, (ValaCodeNode*) prop, attrs);
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_STATIC) == VALA_PARSER_MODIFIER_FLAGS_STATIC) {
		vala_property_set_binding (prop, MEMBER_BINDING_STATIC);
	} else {
		if ((flags & VALA_PARSER_MODIFIER_FLAGS_CLASS) == VALA_PARSER_MODIFIER_FLAGS_CLASS) {
			vala_property_set_binding (prop, MEMBER_BINDING_CLASS);
		}
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_PARSER_MODIFIER_FLAGS_ABSTRACT) {
		vala_property_set_is_abstract (prop, TRUE);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_PARSER_MODIFIER_FLAGS_VIRTUAL) {
		vala_property_set_is_virtual (prop, TRUE);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_PARSER_MODIFIER_FLAGS_OVERRIDE) {
		vala_property_set_overrides (prop, TRUE);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_NEW) == VALA_PARSER_MODIFIER_FLAGS_NEW) {
		vala_symbol_set_hides ((ValaSymbol*) prop, TRUE);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_ASYNC) == VALA_PARSER_MODIFIER_FLAGS_ASYNC) {
		vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) prop), "async properties are not supported yet");
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp4_ = TRUE;
	} else {
		_tmp4_ = vala_source_file_get_external_package (vala_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp4_) {
		vala_symbol_set_external ((ValaSymbol*) prop, TRUE);
	}
	if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
	} else {
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_THROWS)) {
			{
				gboolean _tmp5_;
				_tmp5_ = TRUE;
				while (TRUE) {
					ValaDataType* _tmp6_;
					ValaDataType* _tmp7_;
					if (!_tmp5_) {
						if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp5_ = FALSE;
					_tmp6_ = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (prop);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (prop);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_code_node_add_error_type ((ValaCodeNode*) prop, _tmp7_ = _tmp6_);
					_vala_code_node_unref0 (_tmp7_);
				}
			}
			vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) prop), "properties throwing errors are not supported yet");
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (prop);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (prop);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	while (TRUE) {
		if (!(vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACE)) {
			break;
		}
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_DEFAULT)) {
			ValaExpression* _tmp10_;
			ValaExpression* _tmp11_;
			if (vala_property_get_initializer (prop) != NULL) {
				char* _tmp8_;
				GError* _tmp9_;
				_inner_error_ = (_tmp9_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp8_ = vala_parser_get_error (self, "property default value already defined")), _g_free0 (_tmp8_), _tmp9_);
				{
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (prop);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (prop);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
			}
			vala_parser_expect (self, VALA_TOKEN_TYPE_ASSIGN, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (prop);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return NULL;
				} else {
					_vala_code_node_unref0 (prop);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp10_ = vala_parser_parse_expression (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (prop);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return NULL;
				} else {
					_vala_code_node_unref0 (prop);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			vala_property_set_initializer (prop, _tmp11_ = _tmp10_);
			_vala_code_node_unref0 (_tmp11_);
			vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (prop);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return NULL;
				} else {
					_vala_code_node_unref0 (prop);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		} else {
			ValaComment* _tmp12_;
			ValaSourceLocation _tmp13_ = {0};
			ValaSourceLocation accessor_begin;
			ValaList* accessor_attrs;
			ValaSymbolAccessibility accessor_access;
			ValaDataType* value_type;
			gboolean _tmp14_ = FALSE;
			self->priv->comment = (_tmp12_ = vala_scanner_pop_comment (self->priv->scanner), _vala_comment_unref0 (self->priv->comment), _tmp12_);
			accessor_begin = (vala_parser_get_location (self, &_tmp13_), _tmp13_);
			accessor_attrs = vala_parser_parse_attributes (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (prop);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return NULL;
				} else {
					_vala_code_node_unref0 (prop);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			accessor_access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PUBLIC);
			value_type = vala_data_type_copy (type);
			if (vala_code_context_get_profile (self->priv->context) != VALA_PROFILE_DOVA) {
				_tmp14_ = vala_parser_accept (self, VALA_TOKEN_TYPE_OWNED);
			} else {
				_tmp14_ = FALSE;
			}
			vala_data_type_set_value_owned (value_type, _tmp14_);
			if (vala_parser_accept (self, VALA_TOKEN_TYPE_GET)) {
				ValaBlock* block;
				ValaSourceReference* _tmp19_;
				ValaPropertyAccessor* _tmp20_;
				if (vala_property_get_get_accessor (prop) != NULL) {
					char* _tmp15_;
					GError* _tmp16_;
					_inner_error_ = (_tmp16_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp15_ = vala_parser_get_error (self, "property get accessor already defined")), _g_free0 (_tmp15_), _tmp16_);
					{
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (accessor_attrs);
							_vala_code_node_unref0 (prop);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (accessor_attrs);
							_vala_code_node_unref0 (prop);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				if (getter_owned) {
					vala_data_type_set_value_owned (value_type, TRUE);
				}
				block = NULL;
				if (!vala_parser_accept (self, VALA_TOKEN_TYPE_SEMICOLON)) {
					ValaBlock* _tmp17_;
					ValaBlock* _tmp18_;
					_tmp17_ = vala_parser_parse_block (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (block);
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (accessor_attrs);
							_vala_code_node_unref0 (prop);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (block);
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (accessor_attrs);
							_vala_code_node_unref0 (prop);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					block = (_tmp18_ = _tmp17_, _vala_code_node_unref0 (block), _tmp18_);
					vala_symbol_set_external ((ValaSymbol*) prop, FALSE);
				}
				vala_property_set_get_accessor (prop, _tmp20_ = vala_property_accessor_new (TRUE, FALSE, FALSE, value_type, block, _tmp19_ = vala_parser_get_src (self, &accessor_begin), self->priv->comment));
				_vala_code_node_unref0 (_tmp20_);
				_vala_source_reference_unref0 (_tmp19_);
				vala_parser_set_attributes (self, (ValaCodeNode*) vala_property_get_get_accessor (prop), accessor_attrs);
				vala_symbol_set_access ((ValaSymbol*) vala_property_get_get_accessor (prop), accessor_access);
				_vala_code_node_unref0 (block);
			} else {
				gboolean writable = FALSE;
				gboolean _construct = FALSE;
				ValaBlock* block;
				ValaSourceReference* _tmp29_;
				ValaPropertyAccessor* _tmp30_;
				if (vala_parser_accept (self, VALA_TOKEN_TYPE_SET)) {
					gboolean _tmp21_ = FALSE;
					writable = TRUE;
					if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_GOBJECT) {
						_tmp21_ = vala_parser_accept (self, VALA_TOKEN_TYPE_CONSTRUCT);
					} else {
						_tmp21_ = FALSE;
					}
					_construct = _tmp21_;
				} else {
					gboolean _tmp22_ = FALSE;
					if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_GOBJECT) {
						_tmp22_ = vala_parser_accept (self, VALA_TOKEN_TYPE_CONSTRUCT);
					} else {
						_tmp22_ = FALSE;
					}
					if (_tmp22_) {
						_construct = TRUE;
						writable = vala_parser_accept (self, VALA_TOKEN_TYPE_SET);
					} else {
						char* _tmp23_;
						GError* _tmp24_;
						_inner_error_ = (_tmp24_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp23_ = vala_parser_get_error (self, "expected get, set, or construct")), _g_free0 (_tmp23_), _tmp24_);
						{
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_code_node_unref0 (value_type);
								_vala_collection_object_unref0 (accessor_attrs);
								_vala_code_node_unref0 (prop);
								_g_free0 (id);
								_vala_code_node_unref0 (type);
								return NULL;
							} else {
								_vala_code_node_unref0 (value_type);
								_vala_collection_object_unref0 (accessor_attrs);
								_vala_code_node_unref0 (prop);
								_g_free0 (id);
								_vala_code_node_unref0 (type);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
					}
				}
				if (vala_property_get_set_accessor (prop) != NULL) {
					char* _tmp25_;
					GError* _tmp26_;
					_inner_error_ = (_tmp26_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp25_ = vala_parser_get_error (self, "property set accessor already defined")), _g_free0 (_tmp25_), _tmp26_);
					{
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (accessor_attrs);
							_vala_code_node_unref0 (prop);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (accessor_attrs);
							_vala_code_node_unref0 (prop);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
				block = NULL;
				if (!vala_parser_accept (self, VALA_TOKEN_TYPE_SEMICOLON)) {
					ValaBlock* _tmp27_;
					ValaBlock* _tmp28_;
					_tmp27_ = vala_parser_parse_block (self, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (block);
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (accessor_attrs);
							_vala_code_node_unref0 (prop);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (block);
							_vala_code_node_unref0 (value_type);
							_vala_collection_object_unref0 (accessor_attrs);
							_vala_code_node_unref0 (prop);
							_g_free0 (id);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					block = (_tmp28_ = _tmp27_, _vala_code_node_unref0 (block), _tmp28_);
					vala_symbol_set_external ((ValaSymbol*) prop, FALSE);
				}
				vala_property_set_set_accessor (prop, _tmp30_ = vala_property_accessor_new (FALSE, writable, _construct, value_type, block, _tmp29_ = vala_parser_get_src (self, &accessor_begin), self->priv->comment));
				_vala_code_node_unref0 (_tmp30_);
				_vala_source_reference_unref0 (_tmp29_);
				vala_parser_set_attributes (self, (ValaCodeNode*) vala_property_get_set_accessor (prop), accessor_attrs);
				vala_symbol_set_access ((ValaSymbol*) vala_property_get_set_accessor (prop), accessor_access);
				_vala_code_node_unref0 (block);
			}
			_vala_code_node_unref0 (value_type);
			_vala_collection_object_unref0 (accessor_attrs);
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (prop);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (prop);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (!vala_property_get_is_abstract (prop)) {
		_tmp31_ = !vala_symbol_get_external ((ValaSymbol*) prop);
	} else {
		_tmp31_ = FALSE;
	}
	if (_tmp31_) {
		gboolean _tmp32_ = FALSE;
		gboolean empty_get;
		gboolean _tmp33_ = FALSE;
		gboolean empty_set;
		gboolean _tmp34_ = FALSE;
		if (vala_property_get_get_accessor (prop) != NULL) {
			_tmp32_ = vala_property_accessor_get_body (vala_property_get_get_accessor (prop)) == NULL;
		} else {
			_tmp32_ = FALSE;
		}
		empty_get = _tmp32_;
		if (vala_property_get_set_accessor (prop) != NULL) {
			_tmp33_ = vala_property_accessor_get_body (vala_property_get_set_accessor (prop)) == NULL;
		} else {
			_tmp33_ = FALSE;
		}
		empty_set = _tmp33_;
		if (empty_get != empty_set) {
			if (empty_get) {
				vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) prop), "property getter must have a body");
			} else {
				if (empty_set) {
					vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) prop), "property setter must have a body");
				}
			}
			vala_code_node_set_error ((ValaCodeNode*) prop, TRUE);
		}
		if (empty_get) {
			_tmp34_ = empty_set;
		} else {
			_tmp34_ = FALSE;
		}
		if (_tmp34_) {
			ValaDataType* variable_type;
			char* _tmp35_;
			ValaField* _tmp36_;
			variable_type = vala_data_type_copy (vala_property_get_property_type (prop));
			vala_property_set_field (prop, _tmp36_ = vala_field_new (_tmp35_ = g_strdup_printf ("_%s", vala_symbol_get_name ((ValaSymbol*) prop)), variable_type, vala_property_get_initializer (prop), vala_code_node_get_source_reference ((ValaCodeNode*) prop), NULL));
			_vala_code_node_unref0 (_tmp36_);
			_g_free0 (_tmp35_);
			vala_symbol_set_access ((ValaSymbol*) vala_property_get_field (prop), VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
			vala_field_set_binding (vala_property_get_field (prop), vala_property_get_binding (prop));
			_vala_code_node_unref0 (variable_type);
		} else {
			if (vala_property_get_initializer (prop) != NULL) {
				vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) vala_property_get_initializer (prop)), "only automatic properties can have default values");
			}
		}
	}
	result = prop;
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaSignal* vala_parser_parse_signal_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaSignal* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSymbolAccessibility access;
	ValaParserModifierFlags flags;
	ValaDataType* type;
	char* id;
	ValaSourceReference* _tmp1_;
	ValaSignal* _tmp2_;
	ValaSignal* sig;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	flags = vala_parser_parse_member_declaration_modifiers (self);
	vala_parser_expect (self, VALA_TOKEN_TYPE_SIGNAL, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	id = vala_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	sig = (_tmp2_ = vala_signal_new (id, type, _tmp1_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	vala_symbol_set_access ((ValaSymbol*) sig, access);
	vala_parser_set_attributes (self, (ValaCodeNode*) sig, attrs);
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_STATIC) == VALA_PARSER_MODIFIER_FLAGS_STATIC) {
		char* _tmp3_;
		GError* _tmp4_;
		_inner_error_ = (_tmp4_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp3_ = vala_parser_get_error (self, "`static' modifier not allowed on signals")), _g_free0 (_tmp3_), _tmp4_);
		{
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sig);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (sig);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	} else {
		if ((flags & VALA_PARSER_MODIFIER_FLAGS_CLASS) == VALA_PARSER_MODIFIER_FLAGS_CLASS) {
			char* _tmp5_;
			GError* _tmp6_;
			_inner_error_ = (_tmp6_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp5_ = vala_parser_get_error (self, "`class' modifier not allowed on signals")), _g_free0 (_tmp5_), _tmp6_);
			{
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (sig);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					return NULL;
				} else {
					_vala_code_node_unref0 (sig);
					_g_free0 (id);
					_vala_code_node_unref0 (type);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
		}
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_PARSER_MODIFIER_FLAGS_VIRTUAL) {
		vala_signal_set_is_virtual (sig, TRUE);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_NEW) == VALA_PARSER_MODIFIER_FLAGS_NEW) {
		vala_symbol_set_hides ((ValaSymbol*) sig, TRUE);
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sig);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (sig);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp7_;
			_tmp7_ = TRUE;
			while (TRUE) {
				ValaFormalParameter* param;
				if (!_tmp7_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp7_ = FALSE;
				param = vala_parser_parse_parameter (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (sig);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (sig);
						_g_free0 (id);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_signal_add_parameter (sig, param);
				_vala_code_node_unref0 (param);
			}
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sig);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (sig);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (!vala_parser_accept (self, VALA_TOKEN_TYPE_SEMICOLON)) {
		ValaBlock* _tmp8_;
		ValaBlock* _tmp9_;
		_tmp8_ = vala_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sig);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				return NULL;
			} else {
				_vala_code_node_unref0 (sig);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_signal_set_body (sig, _tmp9_ = _tmp8_);
		_vala_code_node_unref0 (_tmp9_);
	}
	result = sig;
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaConstructor* vala_parser_parse_constructor_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaConstructor* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaParserModifierFlags flags;
	ValaSourceReference* _tmp3_;
	ValaConstructor* _tmp4_;
	ValaConstructor* c;
	ValaBlock* _tmp5_;
	ValaBlock* _tmp6_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	flags = vala_parser_parse_member_declaration_modifiers (self);
	vala_parser_expect (self, VALA_TOKEN_TYPE_CONSTRUCT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_NEW) == VALA_PARSER_MODIFIER_FLAGS_NEW) {
		char* _tmp1_;
		GError* _tmp2_;
		_inner_error_ = (_tmp2_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp1_ = vala_parser_get_error (self, "`new' modifier not allowed on constructor")), _g_free0 (_tmp1_), _tmp2_);
		{
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	c = (_tmp4_ = vala_constructor_new (_tmp3_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_STATIC) == VALA_PARSER_MODIFIER_FLAGS_STATIC) {
		vala_constructor_set_binding (c, MEMBER_BINDING_STATIC);
	} else {
		if ((flags & VALA_PARSER_MODIFIER_FLAGS_CLASS) == VALA_PARSER_MODIFIER_FLAGS_CLASS) {
			vala_constructor_set_binding (c, MEMBER_BINDING_CLASS);
		}
	}
	_tmp5_ = vala_parser_parse_block (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (c);
			return NULL;
		} else {
			_vala_code_node_unref0 (c);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_constructor_set_body (c, _tmp6_ = _tmp5_);
	_vala_code_node_unref0 (_tmp6_);
	result = c;
	return result;
}


static ValaDestructor* vala_parser_parse_destructor_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaDestructor* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaParserModifierFlags flags;
	char* _tmp1_;
	ValaSourceReference* _tmp4_;
	ValaDestructor* _tmp5_;
	ValaDestructor* d;
	ValaBlock* _tmp6_;
	ValaBlock* _tmp7_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	flags = vala_parser_parse_member_declaration_modifiers (self);
	vala_parser_expect (self, VALA_TOKEN_TYPE_TILDE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp1_ = vala_parser_parse_identifier (self, &_inner_error_);
	_g_free0 (_tmp1_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_NEW) == VALA_PARSER_MODIFIER_FLAGS_NEW) {
		char* _tmp2_;
		GError* _tmp3_;
		_inner_error_ = (_tmp3_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp2_ = vala_parser_get_error (self, "`new' modifier not allowed on destructor")), _g_free0 (_tmp2_), _tmp3_);
		{
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	d = (_tmp5_ = vala_destructor_new (_tmp4_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp4_), _tmp5_);
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_STATIC) == VALA_PARSER_MODIFIER_FLAGS_STATIC) {
		vala_destructor_set_binding (d, MEMBER_BINDING_STATIC);
	} else {
		if ((flags & VALA_PARSER_MODIFIER_FLAGS_CLASS) == VALA_PARSER_MODIFIER_FLAGS_CLASS) {
			vala_destructor_set_binding (d, MEMBER_BINDING_CLASS);
		}
	}
	_tmp6_ = vala_parser_parse_block (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (d);
			return NULL;
		} else {
			_vala_code_node_unref0 (d);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	vala_destructor_set_body (d, _tmp7_ = _tmp6_);
	_vala_code_node_unref0 (_tmp7_);
	result = d;
	return result;
}


static ValaSymbol* vala_parser_parse_struct_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSymbolAccessibility access;
	ValaParserModifierFlags flags;
	ValaUnresolvedSymbol* sym;
	ValaList* type_param_list;
	ValaDataType* base_type;
	ValaSourceReference* _tmp3_;
	ValaStruct* _tmp4_;
	ValaStruct* st;
	gboolean _tmp5_ = FALSE;
	ValaSymbol* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	flags = vala_parser_parse_type_declaration_modifiers (self);
	vala_parser_expect (self, VALA_TOKEN_TYPE_STRUCT, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	sym = vala_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_param_list = vala_parser_parse_type_parameter_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	base_type = NULL;
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_COLON)) {
		ValaDataType* _tmp1_;
		ValaDataType* _tmp2_;
		_tmp1_ = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (base_type);
				_vala_collection_object_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (base_type);
				_vala_collection_object_unref0 (type_param_list);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		base_type = (_tmp2_ = _tmp1_, _vala_code_node_unref0 (base_type), _tmp2_);
	}
	st = (_tmp4_ = vala_struct_new (vala_symbol_get_name ((ValaSymbol*) sym), _tmp3_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	vala_symbol_set_access ((ValaSymbol*) st, access);
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp5_ = TRUE;
	} else {
		_tmp5_ = vala_source_file_get_external_package (vala_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp5_) {
		vala_symbol_set_external ((ValaSymbol*) st, TRUE);
	}
	vala_parser_set_attributes (self, (ValaCodeNode*) st, attrs);
	{
		ValaIterator* _type_param_it;
		_type_param_it = vala_iterable_iterator ((ValaIterable*) type_param_list);
		while (TRUE) {
			ValaTypeParameter* type_param;
			if (!vala_iterator_next (_type_param_it)) {
				break;
			}
			type_param = (ValaTypeParameter*) vala_iterator_get (_type_param_it);
			vala_struct_add_type_parameter (st, type_param);
			_vala_code_node_unref0 (type_param);
		}
		_vala_collection_object_unref0 (_type_param_it);
	}
	if (base_type != NULL) {
		vala_struct_set_base_type (st, base_type);
	}
	vala_parser_parse_declarations (self, (ValaSymbol*) st, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (st);
			_vala_code_node_unref0 (base_type);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (st);
			_vala_code_node_unref0 (base_type);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_result_ = _vala_code_node_ref0 ((ValaSymbol*) st);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp6_;
		ValaNamespace* ns;
		ValaSymbol* _tmp7_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp6_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp6_);
		ns = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) st));
		if (VALA_IS_NAMESPACE (_result_)) {
			vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		} else {
			vala_namespace_add_struct (ns, VALA_STRUCT (_result_));
			vala_source_file_add_node (vala_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) _result_);
		}
		_result_ = (_tmp7_ = _vala_code_node_ref0 ((ValaSymbol*) ns), _vala_code_node_unref0 (_result_), _tmp7_);
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (st);
	_vala_code_node_unref0 (base_type);
	_vala_collection_object_unref0 (type_param_list);
	_vala_code_node_unref0 (sym);
	return result;
}


static void vala_parser_parse_struct_member (ValaParser* self, ValaStruct* st, GError** error) {
	ValaSymbol* sym;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (st != NULL);
	sym = vala_parser_parse_declaration (self, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (VALA_IS_METHOD (sym)) {
		vala_struct_add_method (st, VALA_METHOD (sym));
	} else {
		if (VALA_IS_FIELD (sym)) {
			vala_struct_add_field (st, VALA_FIELD (sym));
		} else {
			if (VALA_IS_CONSTANT (sym)) {
				vala_struct_add_constant (st, VALA_CONSTANT (sym));
			} else {
				if (VALA_IS_PROPERTY (sym)) {
					vala_struct_add_property (st, VALA_PROPERTY (sym));
				} else {
					vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) sym), "unexpected declaration in struct");
				}
			}
		}
	}
	_vala_code_node_unref0 (sym);
}


static ValaSymbol* vala_parser_parse_interface_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSymbolAccessibility access;
	ValaParserModifierFlags flags;
	ValaUnresolvedSymbol* sym;
	ValaList* type_param_list;
	ValaArrayList* base_types;
	ValaSourceReference* _tmp2_;
	ValaInterface* _tmp3_;
	ValaInterface* iface;
	gboolean _tmp4_ = FALSE;
	ValaSymbol* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	flags = vala_parser_parse_type_declaration_modifiers (self);
	vala_parser_expect (self, VALA_TOKEN_TYPE_INTERFACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	sym = vala_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_param_list = vala_parser_parse_type_parameter_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	base_types = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_COLON)) {
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				ValaDataType* type;
				if (!_tmp1_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp1_ = FALSE;
				type = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (base_types);
						_vala_collection_object_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						return NULL;
					} else {
						_vala_collection_object_unref0 (base_types);
						_vala_collection_object_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) base_types, type);
				_vala_code_node_unref0 (type);
			}
		}
	}
	iface = (_tmp3_ = vala_interface_new (vala_symbol_get_name ((ValaSymbol*) sym), _tmp2_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp2_), _tmp3_);
	vala_symbol_set_access ((ValaSymbol*) iface, access);
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp4_ = TRUE;
	} else {
		_tmp4_ = vala_source_file_get_external_package (vala_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp4_) {
		vala_symbol_set_external ((ValaSymbol*) iface, TRUE);
	}
	vala_parser_set_attributes (self, (ValaCodeNode*) iface, attrs);
	{
		ValaIterator* _type_param_it;
		_type_param_it = vala_iterable_iterator ((ValaIterable*) type_param_list);
		while (TRUE) {
			ValaTypeParameter* type_param;
			if (!vala_iterator_next (_type_param_it)) {
				break;
			}
			type_param = (ValaTypeParameter*) vala_iterator_get (_type_param_it);
			vala_object_type_symbol_add_type_parameter ((ValaObjectTypeSymbol*) iface, type_param);
			_vala_code_node_unref0 (type_param);
		}
		_vala_collection_object_unref0 (_type_param_it);
	}
	{
		ValaIterator* _base_type_it;
		_base_type_it = vala_iterable_iterator ((ValaIterable*) base_types);
		while (TRUE) {
			ValaDataType* base_type;
			if (!vala_iterator_next (_base_type_it)) {
				break;
			}
			base_type = (ValaDataType*) vala_iterator_get (_base_type_it);
			vala_interface_add_prerequisite (iface, base_type);
			_vala_code_node_unref0 (base_type);
		}
		_vala_collection_object_unref0 (_base_type_it);
	}
	vala_parser_parse_declarations (self, (ValaSymbol*) iface, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (iface);
			_vala_collection_object_unref0 (base_types);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (iface);
			_vala_collection_object_unref0 (base_types);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_result_ = _vala_code_node_ref0 ((ValaSymbol*) iface);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp5_;
		ValaNamespace* ns;
		ValaSymbol* _tmp6_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp5_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp5_);
		ns = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) iface));
		if (VALA_IS_NAMESPACE (_result_)) {
			vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		} else {
			vala_namespace_add_interface (ns, VALA_INTERFACE (_result_));
			vala_source_file_add_node (vala_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) _result_);
		}
		_result_ = (_tmp6_ = _vala_code_node_ref0 ((ValaSymbol*) ns), _vala_code_node_unref0 (_result_), _tmp6_);
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (iface);
	_vala_collection_object_unref0 (base_types);
	_vala_collection_object_unref0 (type_param_list);
	_vala_code_node_unref0 (sym);
	return result;
}


static void vala_parser_parse_interface_member (ValaParser* self, ValaInterface* iface, GError** error) {
	ValaSymbol* sym;
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (iface != NULL);
	sym = vala_parser_parse_declaration (self, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return;
		}
	}
	if (VALA_IS_CLASS (sym)) {
		vala_interface_add_class (iface, VALA_CLASS (sym));
	} else {
		if (VALA_IS_STRUCT (sym)) {
			vala_interface_add_struct (iface, VALA_STRUCT (sym));
		} else {
			if (VALA_IS_ENUM (sym)) {
				vala_interface_add_enum (iface, VALA_ENUM (sym));
			} else {
				if (VALA_IS_DELEGATE (sym)) {
					vala_interface_add_delegate (iface, VALA_DELEGATE (sym));
				} else {
					if (VALA_IS_METHOD (sym)) {
						vala_interface_add_method (iface, VALA_METHOD (sym));
					} else {
						if (VALA_IS_SIGNAL (sym)) {
							vala_interface_add_signal (iface, VALA_SIGNAL (sym));
						} else {
							if (VALA_IS_FIELD (sym)) {
								vala_interface_add_field (iface, VALA_FIELD (sym));
							} else {
								if (VALA_IS_CONSTANT (sym)) {
									vala_interface_add_constant (iface, VALA_CONSTANT (sym));
								} else {
									if (VALA_IS_PROPERTY (sym)) {
										vala_interface_add_property (iface, VALA_PROPERTY (sym));
									} else {
										vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) sym), "unexpected declaration in interface");
									}
								}
							}
						}
					}
				}
			}
		}
	}
	_vala_code_node_unref0 (sym);
}


static ValaSymbol* vala_parser_parse_enum_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSymbolAccessibility access;
	ValaParserModifierFlags flags;
	ValaUnresolvedSymbol* sym;
	ValaSourceReference* _tmp1_;
	ValaEnum* _tmp2_;
	ValaEnum* en;
	gboolean _tmp3_ = FALSE;
	ValaSymbol* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	flags = vala_parser_parse_type_declaration_modifiers (self);
	vala_parser_expect (self, VALA_TOKEN_TYPE_ENUM, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	sym = vala_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	en = (_tmp2_ = vala_enum_new (vala_symbol_get_name ((ValaSymbol*) sym), _tmp1_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	vala_symbol_set_access ((ValaSymbol*) en, access);
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = vala_source_file_get_external_package (vala_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp3_) {
		vala_symbol_set_external ((ValaSymbol*) en, TRUE);
	}
	vala_parser_set_attributes (self, (ValaCodeNode*) en, attrs);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	{
		gboolean _tmp4_;
		_tmp4_ = TRUE;
		while (TRUE) {
			gboolean _tmp5_ = FALSE;
			ValaList* value_attrs;
			ValaSourceLocation _tmp7_ = {0};
			ValaSourceLocation value_begin;
			char* id;
			ValaComment* _tmp8_;
			ValaExpression* value;
			ValaSourceReference* _tmp11_;
			ValaEnumValue* _tmp12_;
			ValaEnumValue* ev;
			if (!_tmp4_) {
				if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
					break;
				}
			}
			_tmp4_ = FALSE;
			if (vala_parser_current (self) == VALA_TOKEN_TYPE_CLOSE_BRACE) {
				ValaList* _tmp6_;
				_tmp5_ = vala_collection_get_size ((ValaCollection*) (_tmp6_ = vala_enum_get_values (en))) > 0;
				_vala_collection_object_unref0 (_tmp6_);
			} else {
				_tmp5_ = FALSE;
			}
			if (_tmp5_) {
				break;
			}
			value_attrs = vala_parser_parse_attributes (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (en);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_code_node_unref0 (en);
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			value_begin = (vala_parser_get_location (self, &_tmp7_), _tmp7_);
			id = vala_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (value_attrs);
					_vala_code_node_unref0 (en);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_collection_object_unref0 (value_attrs);
					_vala_code_node_unref0 (en);
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			self->priv->comment = (_tmp8_ = vala_scanner_pop_comment (self->priv->scanner), _vala_comment_unref0 (self->priv->comment), _tmp8_);
			value = NULL;
			if (vala_parser_accept (self, VALA_TOKEN_TYPE_ASSIGN)) {
				ValaExpression* _tmp9_;
				ValaExpression* _tmp10_;
				_tmp9_ = vala_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (value);
						_g_free0 (id);
						_vala_collection_object_unref0 (value_attrs);
						_vala_code_node_unref0 (en);
						_vala_code_node_unref0 (sym);
						return NULL;
					} else {
						_vala_code_node_unref0 (value);
						_g_free0 (id);
						_vala_collection_object_unref0 (value_attrs);
						_vala_code_node_unref0 (en);
						_vala_code_node_unref0 (sym);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				value = (_tmp10_ = _tmp9_, _vala_code_node_unref0 (value), _tmp10_);
			}
			ev = (_tmp12_ = vala_enum_value_new (id, value, _tmp11_ = vala_parser_get_src (self, &value_begin), self->priv->comment), _vala_source_reference_unref0 (_tmp11_), _tmp12_);
			vala_parser_set_attributes (self, (ValaCodeNode*) ev, value_attrs);
			vala_enum_add_value (en, ev);
			_vala_code_node_unref0 (ev);
			_vala_code_node_unref0 (value);
			_g_free0 (id);
			_vala_collection_object_unref0 (value_attrs);
		}
	}
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_SEMICOLON)) {
		while (TRUE) {
			ValaSymbol* member_sym;
			if (!(vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACE)) {
				break;
			}
			member_sym = vala_parser_parse_declaration (self, FALSE, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (en);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_code_node_unref0 (en);
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			if (VALA_IS_METHOD (member_sym)) {
				vala_enum_add_method (en, VALA_METHOD (member_sym));
			} else {
				if (VALA_IS_CONSTANT (member_sym)) {
					vala_enum_add_constant (en, VALA_CONSTANT (member_sym));
				} else {
					vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) member_sym), "unexpected declaration in enum");
				}
			}
			_vala_code_node_unref0 (member_sym);
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (en);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_result_ = _vala_code_node_ref0 ((ValaSymbol*) en);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp13_;
		ValaNamespace* ns;
		ValaSymbol* _tmp14_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp13_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp13_);
		ns = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) en));
		if (VALA_IS_NAMESPACE (_result_)) {
			vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		} else {
			vala_namespace_add_enum (ns, VALA_ENUM (_result_));
			vala_source_file_add_node (vala_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) _result_);
		}
		_result_ = (_tmp14_ = _vala_code_node_ref0 ((ValaSymbol*) ns), _vala_code_node_unref0 (_result_), _tmp14_);
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (en);
	_vala_code_node_unref0 (sym);
	return result;
}


static ValaSymbol* vala_parser_parse_errordomain_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSymbolAccessibility access;
	ValaParserModifierFlags flags;
	ValaUnresolvedSymbol* sym;
	ValaSourceReference* _tmp1_;
	ValaErrorDomain* _tmp2_;
	ValaErrorDomain* ed;
	gboolean _tmp3_ = FALSE;
	ValaSymbol* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	flags = vala_parser_parse_type_declaration_modifiers (self);
	vala_parser_expect (self, VALA_TOKEN_TYPE_ERRORDOMAIN, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	sym = vala_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	ed = (_tmp2_ = vala_error_domain_new (vala_symbol_get_name ((ValaSymbol*) sym), _tmp1_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
	vala_symbol_set_access ((ValaSymbol*) ed, access);
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp3_ = TRUE;
	} else {
		_tmp3_ = vala_source_file_get_external_package (vala_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp3_) {
		vala_symbol_set_external ((ValaSymbol*) ed, TRUE);
	}
	vala_parser_set_attributes (self, (ValaCodeNode*) ed, attrs);
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	{
		gboolean _tmp4_;
		_tmp4_ = TRUE;
		while (TRUE) {
			gboolean _tmp5_ = FALSE;
			ValaList* code_attrs;
			ValaSourceLocation _tmp7_ = {0};
			ValaSourceLocation code_begin;
			char* id;
			ValaComment* _tmp8_;
			ValaSourceReference* _tmp9_;
			ValaErrorCode* _tmp10_;
			ValaErrorCode* ec;
			if (!_tmp4_) {
				if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
					break;
				}
			}
			_tmp4_ = FALSE;
			if (vala_parser_current (self) == VALA_TOKEN_TYPE_CLOSE_BRACE) {
				ValaList* _tmp6_;
				_tmp5_ = vala_collection_get_size ((ValaCollection*) (_tmp6_ = vala_error_domain_get_codes (ed))) > 0;
				_vala_collection_object_unref0 (_tmp6_);
			} else {
				_tmp5_ = FALSE;
			}
			if (_tmp5_) {
				break;
			}
			code_attrs = vala_parser_parse_attributes (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (ed);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_code_node_unref0 (ed);
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			code_begin = (vala_parser_get_location (self, &_tmp7_), _tmp7_);
			id = vala_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_collection_object_unref0 (code_attrs);
					_vala_code_node_unref0 (ed);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_collection_object_unref0 (code_attrs);
					_vala_code_node_unref0 (ed);
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			self->priv->comment = (_tmp8_ = vala_scanner_pop_comment (self->priv->scanner), _vala_comment_unref0 (self->priv->comment), _tmp8_);
			ec = (_tmp10_ = vala_error_code_new (id, _tmp9_ = vala_parser_get_src (self, &code_begin), self->priv->comment), _vala_source_reference_unref0 (_tmp9_), _tmp10_);
			vala_parser_set_attributes (self, (ValaCodeNode*) ec, code_attrs);
			if (vala_parser_accept (self, VALA_TOKEN_TYPE_ASSIGN)) {
				ValaExpression* _tmp11_;
				ValaExpression* _tmp12_;
				_tmp11_ = vala_parser_parse_expression (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (ec);
						_g_free0 (id);
						_vala_collection_object_unref0 (code_attrs);
						_vala_code_node_unref0 (ed);
						_vala_code_node_unref0 (sym);
						return NULL;
					} else {
						_vala_code_node_unref0 (ec);
						_g_free0 (id);
						_vala_collection_object_unref0 (code_attrs);
						_vala_code_node_unref0 (ed);
						_vala_code_node_unref0 (sym);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_error_code_set_value (ec, _tmp12_ = _tmp11_);
				_vala_code_node_unref0 (_tmp12_);
			}
			vala_error_domain_add_code (ed, ec);
			_vala_code_node_unref0 (ec);
			_g_free0 (id);
			_vala_collection_object_unref0 (code_attrs);
		}
	}
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_SEMICOLON)) {
		while (TRUE) {
			ValaSymbol* member_sym;
			if (!(vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_BRACE)) {
				break;
			}
			member_sym = vala_parser_parse_declaration (self, FALSE, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (ed);
					_vala_code_node_unref0 (sym);
					return NULL;
				} else {
					_vala_code_node_unref0 (ed);
					_vala_code_node_unref0 (sym);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			if (VALA_IS_METHOD (member_sym)) {
				vala_error_domain_add_method (ed, VALA_METHOD (member_sym));
			} else {
				vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) member_sym), "unexpected declaration in errordomain");
			}
			_vala_code_node_unref0 (member_sym);
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_BRACE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (ed);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_result_ = _vala_code_node_ref0 ((ValaSymbol*) ed);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp13_;
		ValaNamespace* ns;
		ValaSymbol* _tmp14_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp13_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp13_);
		ns = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) ed));
		if (VALA_IS_NAMESPACE (_result_)) {
			vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		} else {
			vala_namespace_add_error_domain (ns, VALA_ERROR_DOMAIN (_result_));
			vala_source_file_add_node (vala_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) _result_);
		}
		_result_ = (_tmp14_ = _vala_code_node_ref0 ((ValaSymbol*) ns), _vala_code_node_unref0 (_result_), _tmp14_);
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (ed);
	_vala_code_node_unref0 (sym);
	return result;
}


static ValaSymbolAccessibility vala_parser_parse_access_modifier (ValaParser* self, ValaSymbolAccessibility default_access) {
	ValaSymbolAccessibility result = 0;
	g_return_val_if_fail (self != NULL, 0);
	switch (vala_parser_current (self)) {
		case VALA_TOKEN_TYPE_PRIVATE:
		{
			vala_parser_next (self);
			result = VALA_SYMBOL_ACCESSIBILITY_PRIVATE;
			return result;
		}
		case VALA_TOKEN_TYPE_PROTECTED:
		{
			vala_parser_next (self);
			result = VALA_SYMBOL_ACCESSIBILITY_PROTECTED;
			return result;
		}
		case VALA_TOKEN_TYPE_INTERNAL:
		{
			vala_parser_next (self);
			result = VALA_SYMBOL_ACCESSIBILITY_INTERNAL;
			return result;
		}
		case VALA_TOKEN_TYPE_PUBLIC:
		{
			vala_parser_next (self);
			result = VALA_SYMBOL_ACCESSIBILITY_PUBLIC;
			return result;
		}
		default:
		{
			result = default_access;
			return result;
		}
	}
}


static ValaParserModifierFlags vala_parser_parse_type_declaration_modifiers (ValaParser* self) {
	ValaParserModifierFlags result = 0;
	ValaParserModifierFlags flags;
	g_return_val_if_fail (self != NULL, 0);
	flags = 0;
	while (TRUE) {
		switch (vala_parser_current (self)) {
			case VALA_TOKEN_TYPE_ABSTRACT:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_ABSTRACT;
				break;
			}
			case VALA_TOKEN_TYPE_EXTERN:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_EXTERN;
				break;
			}
			case VALA_TOKEN_TYPE_SEALED:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_SEALED;
				break;
			}
			case VALA_TOKEN_TYPE_STATIC:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_STATIC;
				break;
			}
			default:
			{
				result = flags;
				return result;
			}
		}
	}
}


static ValaParserModifierFlags vala_parser_parse_member_declaration_modifiers (ValaParser* self) {
	ValaParserModifierFlags result = 0;
	ValaParserModifierFlags flags;
	g_return_val_if_fail (self != NULL, 0);
	flags = 0;
	while (TRUE) {
		switch (vala_parser_current (self)) {
			case VALA_TOKEN_TYPE_ABSTRACT:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_ABSTRACT;
				break;
			}
			case VALA_TOKEN_TYPE_ASYNC:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_ASYNC;
				break;
			}
			case VALA_TOKEN_TYPE_CLASS:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_CLASS;
				break;
			}
			case VALA_TOKEN_TYPE_EXTERN:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_EXTERN;
				break;
			}
			case VALA_TOKEN_TYPE_INLINE:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_INLINE;
				break;
			}
			case VALA_TOKEN_TYPE_NEW:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_NEW;
				break;
			}
			case VALA_TOKEN_TYPE_OVERRIDE:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_OVERRIDE;
				break;
			}
			case VALA_TOKEN_TYPE_SEALED:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_SEALED;
				break;
			}
			case VALA_TOKEN_TYPE_STATIC:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_STATIC;
				break;
			}
			case VALA_TOKEN_TYPE_VIRTUAL:
			{
				vala_parser_next (self);
				flags = flags | VALA_PARSER_MODIFIER_FLAGS_VIRTUAL;
				break;
			}
			default:
			{
				result = flags;
				return result;
			}
		}
	}
}


static ValaFormalParameter* vala_parser_parse_parameter (ValaParser* self, GError** error) {
	ValaFormalParameter* result = NULL;
	ValaList* attrs;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	gboolean params_array;
	ValaParameterDirection direction;
	ValaDataType* type;
	char* id;
	ValaDataType* _tmp9_;
	ValaDataType* _tmp10_;
	ValaSourceReference* _tmp11_;
	ValaFormalParameter* _tmp12_;
	ValaFormalParameter* param;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	attrs = vala_parser_parse_attributes (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_ELLIPSIS)) {
		ValaSourceReference* _tmp1_;
		ValaFormalParameter* _tmp2_;
		result = (_tmp2_ = vala_formal_parameter_new_with_ellipsis (_tmp1_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp1_), _tmp2_);
		_vala_collection_object_unref0 (attrs);
		return result;
	}
	params_array = vala_parser_accept (self, VALA_TOKEN_TYPE_PARAMS);
	direction = VALA_PARAMETER_DIRECTION_IN;
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_OUT)) {
		direction = VALA_PARAMETER_DIRECTION_OUT;
	} else {
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_REF)) {
			direction = VALA_PARAMETER_DIRECTION_REF;
		}
	}
	if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
		vala_parser_accept (self, VALA_TOKEN_TYPE_VOLATILE);
	}
	type = NULL;
	if (direction == VALA_PARAMETER_DIRECTION_IN) {
		ValaDataType* _tmp3_;
		ValaDataType* _tmp4_;
		_tmp3_ = vala_parser_parse_type (self, FALSE, FALSE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (type);
				_vala_collection_object_unref0 (attrs);
				return NULL;
			} else {
				_vala_code_node_unref0 (type);
				_vala_collection_object_unref0 (attrs);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		type = (_tmp4_ = _tmp3_, _vala_code_node_unref0 (type), _tmp4_);
	} else {
		if (direction == VALA_PARAMETER_DIRECTION_REF) {
			ValaDataType* _tmp5_;
			ValaDataType* _tmp6_;
			_tmp5_ = vala_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (type);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_code_node_unref0 (type);
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			type = (_tmp6_ = _tmp5_, _vala_code_node_unref0 (type), _tmp6_);
		} else {
			ValaDataType* _tmp7_;
			ValaDataType* _tmp8_;
			_tmp7_ = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (type);
					_vala_collection_object_unref0 (attrs);
					return NULL;
				} else {
					_vala_code_node_unref0 (type);
					_vala_collection_object_unref0 (attrs);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			type = (_tmp8_ = _tmp7_, _vala_code_node_unref0 (type), _tmp8_);
		}
	}
	id = vala_parser_parse_identifier (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			_vala_collection_object_unref0 (attrs);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			_vala_collection_object_unref0 (attrs);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_tmp9_ = vala_parser_parse_inline_array_type (self, type, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			_vala_collection_object_unref0 (attrs);
			return NULL;
		} else {
			_g_free0 (id);
			_vala_code_node_unref0 (type);
			_vala_collection_object_unref0 (attrs);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type = (_tmp10_ = _tmp9_, _vala_code_node_unref0 (type), _tmp10_);
	param = (_tmp12_ = vala_formal_parameter_new (id, type, _tmp11_ = vala_parser_get_src (self, &begin)), _vala_source_reference_unref0 (_tmp11_), _tmp12_);
	vala_parser_set_attributes (self, (ValaCodeNode*) param, attrs);
	vala_formal_parameter_set_direction (param, direction);
	vala_formal_parameter_set_params_array (param, params_array);
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_ASSIGN)) {
		ValaExpression* _tmp13_;
		ValaExpression* _tmp14_;
		_tmp13_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (param);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				_vala_collection_object_unref0 (attrs);
				return NULL;
			} else {
				_vala_code_node_unref0 (param);
				_g_free0 (id);
				_vala_code_node_unref0 (type);
				_vala_collection_object_unref0 (attrs);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_variable_set_initializer ((ValaVariable*) param, _tmp14_ = _tmp13_);
		_vala_code_node_unref0 (_tmp14_);
	}
	result = param;
	_g_free0 (id);
	_vala_code_node_unref0 (type);
	_vala_collection_object_unref0 (attrs);
	return result;
}


static ValaCreationMethod* vala_parser_parse_creation_method_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaCreationMethod* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSymbolAccessibility access;
	ValaParserModifierFlags flags;
	ValaUnresolvedSymbol* sym;
	ValaCreationMethod* method;
	gboolean _tmp7_ = FALSE;
	gboolean _tmp8_ = FALSE;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	flags = vala_parser_parse_member_declaration_modifiers (self);
	sym = vala_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_NEW) == VALA_PARSER_MODIFIER_FLAGS_NEW) {
		char* _tmp1_;
		GError* _tmp2_;
		_inner_error_ = (_tmp2_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp1_ = vala_parser_get_error (self, "`new' modifier not allowed on creation method")), _g_free0 (_tmp1_), _tmp2_);
		{
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	method = NULL;
	if (vala_unresolved_symbol_get_inner (sym) == NULL) {
		ValaSourceReference* _tmp3_;
		ValaCreationMethod* _tmp4_;
		method = (_tmp4_ = vala_creation_method_new (vala_symbol_get_name ((ValaSymbol*) sym), NULL, _tmp3_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_code_node_unref0 (method), _tmp4_);
		_vala_source_reference_unref0 (_tmp3_);
	} else {
		ValaSourceReference* _tmp5_;
		ValaCreationMethod* _tmp6_;
		method = (_tmp6_ = vala_creation_method_new (vala_symbol_get_name ((ValaSymbol*) vala_unresolved_symbol_get_inner (sym)), vala_symbol_get_name ((ValaSymbol*) sym), _tmp5_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_code_node_unref0 (method), _tmp6_);
		_vala_source_reference_unref0 (_tmp5_);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_PARSER_MODIFIER_FLAGS_EXTERN) {
		vala_symbol_set_external ((ValaSymbol*) method, TRUE);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_ABSTRACT) == VALA_PARSER_MODIFIER_FLAGS_ABSTRACT) {
		_tmp8_ = TRUE;
	} else {
		_tmp8_ = (flags & VALA_PARSER_MODIFIER_FLAGS_VIRTUAL) == VALA_PARSER_MODIFIER_FLAGS_VIRTUAL;
	}
	if (_tmp8_) {
		_tmp7_ = TRUE;
	} else {
		_tmp7_ = (flags & VALA_PARSER_MODIFIER_FLAGS_OVERRIDE) == VALA_PARSER_MODIFIER_FLAGS_OVERRIDE;
	}
	if (_tmp7_) {
		vala_report_error (vala_code_node_get_source_reference ((ValaCodeNode*) method), "abstract, virtual, and override modifiers are not applicable to creati" \
"on methods");
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_ASYNC) == VALA_PARSER_MODIFIER_FLAGS_ASYNC) {
		vala_method_set_coroutine ((ValaMethod*) method, TRUE);
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (method);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (method);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp9_;
			_tmp9_ = TRUE;
			while (TRUE) {
				ValaFormalParameter* param;
				if (!_tmp9_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp9_ = FALSE;
				param = vala_parser_parse_parameter (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (method);
						_vala_code_node_unref0 (sym);
						return NULL;
					} else {
						_vala_code_node_unref0 (method);
						_vala_code_node_unref0 (sym);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_method_add_parameter ((ValaMethod*) method, param);
				_vala_code_node_unref0 (param);
			}
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (method);
			_vala_code_node_unref0 (sym);
			return NULL;
		} else {
			_vala_code_node_unref0 (method);
			_vala_code_node_unref0 (sym);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
		ValaUnresolvedSymbol* _tmp10_;
		ValaUnresolvedSymbol* _tmp11_;
		ValaUnresolvedType* _tmp12_;
		ValaUnresolvedType* error_type;
		error_type = (_tmp12_ = vala_unresolved_type_new_from_symbol (_tmp11_ = vala_unresolved_symbol_new (_tmp10_ = vala_unresolved_symbol_new (NULL, "Dova", NULL), "Error", NULL), vala_code_node_get_source_reference ((ValaCodeNode*) method)), _vala_code_node_unref0 (_tmp11_), _vala_code_node_unref0 (_tmp10_), _tmp12_);
		vala_code_node_add_error_type ((ValaCodeNode*) method, (ValaDataType*) error_type);
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_THROWS)) {
			{
				gboolean _tmp13_;
				_tmp13_ = TRUE;
				while (TRUE) {
					ValaDataType* _tmp14_;
					if (!_tmp13_) {
						if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp13_ = FALSE;
					_tmp14_ = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
					_vala_code_node_unref0 (_tmp14_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (error_type);
							_vala_code_node_unref0 (method);
							_vala_code_node_unref0 (sym);
							return NULL;
						} else {
							_vala_code_node_unref0 (error_type);
							_vala_code_node_unref0 (method);
							_vala_code_node_unref0 (sym);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
			}
			vala_report_warning (vala_code_node_get_source_reference ((ValaCodeNode*) method), "`throws' is ignored in the Dova profile");
		}
		_vala_code_node_unref0 (error_type);
	} else {
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_THROWS)) {
			{
				gboolean _tmp15_;
				_tmp15_ = TRUE;
				while (TRUE) {
					ValaDataType* _tmp16_;
					ValaDataType* _tmp17_;
					if (!_tmp15_) {
						if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp15_ = FALSE;
					_tmp16_ = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (method);
							_vala_code_node_unref0 (sym);
							return NULL;
						} else {
							_vala_code_node_unref0 (method);
							_vala_code_node_unref0 (sym);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_code_node_add_error_type ((ValaCodeNode*) method, _tmp17_ = _tmp16_);
					_vala_code_node_unref0 (_tmp17_);
				}
			}
		}
	}
	while (TRUE) {
		ValaExpression* _tmp18_;
		ValaExpression* _tmp19_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_REQUIRES)) {
			break;
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp18_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_method_add_precondition ((ValaMethod*) method, _tmp19_ = _tmp18_);
		_vala_code_node_unref0 (_tmp19_);
		vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	while (TRUE) {
		ValaExpression* _tmp20_;
		ValaExpression* _tmp21_;
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_ENSURES)) {
			break;
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		_tmp20_ = vala_parser_parse_expression (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_method_add_postcondition ((ValaMethod*) method, _tmp21_ = _tmp20_);
		_vala_code_node_unref0 (_tmp21_);
		vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	vala_symbol_set_access ((ValaSymbol*) method, access);
	vala_parser_set_attributes (self, (ValaCodeNode*) method, attrs);
	if (!vala_parser_accept (self, VALA_TOKEN_TYPE_SEMICOLON)) {
		ValaBlock* _tmp22_;
		ValaBlock* _tmp23_;
		_tmp22_ = vala_parser_parse_block (self, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				return NULL;
			} else {
				_vala_code_node_unref0 (method);
				_vala_code_node_unref0 (sym);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
		vala_method_set_body ((ValaMethod*) method, _tmp23_ = _tmp22_);
		_vala_code_node_unref0 (_tmp23_);
	} else {
		if (vala_source_file_get_external_package (vala_scanner_get_source_file (self->priv->scanner))) {
			vala_symbol_set_external ((ValaSymbol*) method, TRUE);
		}
	}
	result = method;
	_vala_code_node_unref0 (sym);
	return result;
}


static ValaSymbol* vala_parser_parse_delegate_declaration (ValaParser* self, ValaList* attrs, GError** error) {
	ValaSymbol* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaSymbolAccessibility access;
	ValaParserModifierFlags flags;
	ValaDataType* type;
	ValaUnresolvedSymbol* sym;
	ValaList* type_param_list;
	ValaSourceReference* _tmp3_;
	ValaDelegate* _tmp4_;
	ValaDelegate* d;
	gboolean _tmp6_ = FALSE;
	ValaSymbol* _result_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	access = vala_parser_parse_access_modifier (self, VALA_SYMBOL_ACCESSIBILITY_PRIVATE);
	flags = vala_parser_parse_member_declaration_modifiers (self);
	vala_parser_expect (self, VALA_TOKEN_TYPE_DELEGATE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_NEW) == VALA_PARSER_MODIFIER_FLAGS_NEW) {
		char* _tmp1_;
		GError* _tmp2_;
		_inner_error_ = (_tmp2_ = g_error_new_literal (VALA_PARSE_ERROR, VALA_PARSE_ERROR_SYNTAX, _tmp1_ = vala_parser_get_error (self, "`new' modifier not allowed on delegates")), _g_free0 (_tmp1_), _tmp2_);
		{
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	type = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	sym = vala_parser_parse_symbol_name (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	type_param_list = vala_parser_parse_type_parameter_list (self, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	d = (_tmp4_ = vala_delegate_new (vala_symbol_get_name ((ValaSymbol*) sym), type, _tmp3_ = vala_parser_get_src (self, &begin), self->priv->comment), _vala_source_reference_unref0 (_tmp3_), _tmp4_);
	vala_symbol_set_access ((ValaSymbol*) d, access);
	vala_parser_set_attributes (self, (ValaCodeNode*) d, attrs);
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_STATIC) == VALA_PARSER_MODIFIER_FLAGS_STATIC) {
		if (!vala_code_context_get_deprecated (self->priv->context)) {
			ValaSourceReference* _tmp5_;
			vala_report_warning (_tmp5_ = vala_parser_get_last_src (self), "deprecated syntax, use [CCode (has_target = false)]");
			_vala_source_reference_unref0 (_tmp5_);
		}
	} else {
		vala_delegate_set_has_target (d, TRUE);
	}
	if ((flags & VALA_PARSER_MODIFIER_FLAGS_EXTERN) == VALA_PARSER_MODIFIER_FLAGS_EXTERN) {
		_tmp6_ = TRUE;
	} else {
		_tmp6_ = vala_source_file_get_external_package (vala_scanner_get_source_file (self->priv->scanner));
	}
	if (_tmp6_) {
		vala_symbol_set_external ((ValaSymbol*) d, TRUE);
	}
	{
		ValaIterator* _type_param_it;
		_type_param_it = vala_iterable_iterator ((ValaIterable*) type_param_list);
		while (TRUE) {
			ValaTypeParameter* type_param;
			if (!vala_iterator_next (_type_param_it)) {
				break;
			}
			type_param = (ValaTypeParameter*) vala_iterator_get (_type_param_it);
			vala_delegate_add_type_parameter (d, type_param);
			_vala_code_node_unref0 (type_param);
		}
		_vala_collection_object_unref0 (_type_param_it);
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_OPEN_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (d);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (d);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_parser_current (self) != VALA_TOKEN_TYPE_CLOSE_PARENS) {
		{
			gboolean _tmp7_;
			_tmp7_ = TRUE;
			while (TRUE) {
				ValaFormalParameter* param;
				if (!_tmp7_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp7_ = FALSE;
				param = vala_parser_parse_parameter (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_code_node_unref0 (d);
						_vala_collection_object_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						_vala_code_node_unref0 (type);
						return NULL;
					} else {
						_vala_code_node_unref0 (d);
						_vala_collection_object_unref0 (type_param_list);
						_vala_code_node_unref0 (sym);
						_vala_code_node_unref0 (type);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_delegate_add_parameter (d, param);
				_vala_code_node_unref0 (param);
			}
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_CLOSE_PARENS, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (d);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (d);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	if (vala_code_context_get_profile (self->priv->context) == VALA_PROFILE_DOVA) {
		ValaUnresolvedSymbol* _tmp8_;
		ValaUnresolvedSymbol* _tmp9_;
		ValaUnresolvedType* _tmp10_;
		ValaUnresolvedType* error_type;
		error_type = (_tmp10_ = vala_unresolved_type_new_from_symbol (_tmp9_ = vala_unresolved_symbol_new (_tmp8_ = vala_unresolved_symbol_new (NULL, "Dova", NULL), "Error", NULL), vala_code_node_get_source_reference ((ValaCodeNode*) d)), _vala_code_node_unref0 (_tmp9_), _vala_code_node_unref0 (_tmp8_), _tmp10_);
		vala_code_node_add_error_type ((ValaCodeNode*) d, (ValaDataType*) error_type);
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_THROWS)) {
			{
				gboolean _tmp11_;
				_tmp11_ = TRUE;
				while (TRUE) {
					ValaDataType* _tmp12_;
					if (!_tmp11_) {
						if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp11_ = FALSE;
					_tmp12_ = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
					_vala_code_node_unref0 (_tmp12_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (error_type);
							_vala_code_node_unref0 (d);
							_vala_collection_object_unref0 (type_param_list);
							_vala_code_node_unref0 (sym);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (error_type);
							_vala_code_node_unref0 (d);
							_vala_collection_object_unref0 (type_param_list);
							_vala_code_node_unref0 (sym);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
				}
			}
			vala_report_warning (vala_code_node_get_source_reference ((ValaCodeNode*) d), "`throws' is ignored in the Dova profile");
		}
		_vala_code_node_unref0 (error_type);
	} else {
		if (vala_parser_accept (self, VALA_TOKEN_TYPE_THROWS)) {
			{
				gboolean _tmp13_;
				_tmp13_ = TRUE;
				while (TRUE) {
					ValaDataType* _tmp14_;
					ValaDataType* _tmp15_;
					if (!_tmp13_) {
						if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
							break;
						}
					}
					_tmp13_ = FALSE;
					_tmp14_ = vala_parser_parse_type (self, TRUE, FALSE, &_inner_error_);
					if (_inner_error_ != NULL) {
						if (_inner_error_->domain == VALA_PARSE_ERROR) {
							g_propagate_error (error, _inner_error_);
							_vala_code_node_unref0 (d);
							_vala_collection_object_unref0 (type_param_list);
							_vala_code_node_unref0 (sym);
							_vala_code_node_unref0 (type);
							return NULL;
						} else {
							_vala_code_node_unref0 (d);
							_vala_collection_object_unref0 (type_param_list);
							_vala_code_node_unref0 (sym);
							_vala_code_node_unref0 (type);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
							g_clear_error (&_inner_error_);
							return NULL;
						}
					}
					vala_code_node_add_error_type ((ValaCodeNode*) d, _tmp15_ = _tmp14_);
					_vala_code_node_unref0 (_tmp15_);
				}
			}
		}
	}
	vala_parser_expect (self, VALA_TOKEN_TYPE_SEMICOLON, &_inner_error_);
	if (_inner_error_ != NULL) {
		if (_inner_error_->domain == VALA_PARSE_ERROR) {
			g_propagate_error (error, _inner_error_);
			_vala_code_node_unref0 (d);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			return NULL;
		} else {
			_vala_code_node_unref0 (d);
			_vala_collection_object_unref0 (type_param_list);
			_vala_code_node_unref0 (sym);
			_vala_code_node_unref0 (type);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	_result_ = _vala_code_node_ref0 ((ValaSymbol*) d);
	while (TRUE) {
		ValaUnresolvedSymbol* _tmp16_;
		ValaNamespace* ns;
		ValaSymbol* _tmp17_;
		if (!(vala_unresolved_symbol_get_inner (sym) != NULL)) {
			break;
		}
		sym = (_tmp16_ = _vala_code_node_ref0 (vala_unresolved_symbol_get_inner (sym)), _vala_code_node_unref0 (sym), _tmp16_);
		ns = vala_namespace_new (vala_symbol_get_name ((ValaSymbol*) sym), vala_code_node_get_source_reference ((ValaCodeNode*) d));
		if (VALA_IS_NAMESPACE (_result_)) {
			vala_namespace_add_namespace (ns, VALA_NAMESPACE (_result_));
		} else {
			vala_namespace_add_delegate (ns, VALA_DELEGATE (_result_));
			vala_source_file_add_node (vala_scanner_get_source_file (self->priv->scanner), (ValaCodeNode*) _result_);
		}
		_result_ = (_tmp17_ = _vala_code_node_ref0 ((ValaSymbol*) ns), _vala_code_node_unref0 (_result_), _tmp17_);
		_vala_code_node_unref0 (ns);
	}
	result = _result_;
	_vala_code_node_unref0 (d);
	_vala_collection_object_unref0 (type_param_list);
	_vala_code_node_unref0 (sym);
	_vala_code_node_unref0 (type);
	return result;
}


static ValaList* vala_parser_parse_type_parameter_list (ValaParser* self, GError** error) {
	ValaList* result = NULL;
	ValaArrayList* list;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	list = vala_array_list_new (VALA_TYPE_TYPEPARAMETER, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_OP_LT)) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				ValaSourceLocation _tmp1_ = {0};
				ValaSourceLocation begin;
				char* id;
				ValaSourceReference* _tmp2_;
				ValaTypeParameter* _tmp3_;
				if (!_tmp0_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				begin = (vala_parser_get_location (self, &_tmp1_), _tmp1_);
				id = vala_parser_parse_identifier (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_vala_collection_object_unref0 (list);
						return NULL;
					} else {
						_vala_collection_object_unref0 (list);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				vala_collection_add ((ValaCollection*) list, _tmp3_ = vala_typeparameter_new (id, _tmp2_ = vala_parser_get_src (self, &begin)));
				_vala_code_node_unref0 (_tmp3_);
				_vala_source_reference_unref0 (_tmp2_);
				_g_free0 (id);
			}
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_OP_GT, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				_vala_collection_object_unref0 (list);
				return NULL;
			} else {
				_vala_collection_object_unref0 (list);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return NULL;
			}
		}
	}
	result = (ValaList*) list;
	return result;
}


static void vala_parser_skip_type_argument_list (ValaParser* self, GError** error) {
	GError * _inner_error_ = NULL;
	g_return_if_fail (self != NULL);
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_OP_LT)) {
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				if (!_tmp0_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp0_ = FALSE;
				vala_parser_skip_type (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						return;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return;
					}
				}
			}
		}
		vala_parser_expect (self, VALA_TOKEN_TYPE_OP_GT, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == VALA_PARSE_ERROR) {
				g_propagate_error (error, _inner_error_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
				g_clear_error (&_inner_error_);
				return;
			}
		}
	}
}


static ValaList* vala_parser_parse_type_argument_list (ValaParser* self, gboolean maybe_expression, GError** error) {
	ValaList* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	if (vala_parser_accept (self, VALA_TOKEN_TYPE_OP_LT)) {
		ValaArrayList* list;
		list = vala_array_list_new (VALA_TYPE_DATA_TYPE, (GBoxedCopyFunc) vala_code_node_ref, vala_code_node_unref, g_direct_equal);
		{
			gboolean _tmp1_;
			_tmp1_ = TRUE;
			while (TRUE) {
				if (!_tmp1_) {
					if (!vala_parser_accept (self, VALA_TOKEN_TYPE_COMMA)) {
						break;
					}
				}
				_tmp1_ = FALSE;
				switch (vala_parser_current (self)) {
					case VALA_TOKEN_TYPE_VOID:
					case VALA_TOKEN_TYPE_DYNAMIC:
					case VALA_TOKEN_TYPE_UNOWNED:
					case VALA_TOKEN_TYPE_WEAK:
					case VALA_TOKEN_TYPE_IDENTIFIER:
					{
						ValaDataType* type;
						type = vala_parser_parse_type (self, TRUE, TRUE, &_inner_error_);
						if (_inner_error_ != NULL) {
							if (_inner_error_->domain == VALA_PARSE_ERROR) {
								g_propagate_error (error, _inner_error_);
								_vala_collection_object_unref0 (list);
								return NULL;
							} else {
								_vala_collection_object_unref0 (list);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
								g_clear_error (&_inner_error_);
								return NULL;
							}
						}
						vala_collection_add ((ValaCollection*) list, type);
						_vala_code_node_unref0 (type);
						break;
					}
					default:
					{
						vala_parser_rollback (self, &begin);
						result = NULL;
						_vala_collection_object_unref0 (list);
						return result;
					}
				}
			}
		}
		if (!vala_parser_accept (self, VALA_TOKEN_TYPE_OP_GT)) {
			vala_parser_rollback (self, &begin);
			result = NULL;
			_vala_collection_object_unref0 (list);
			return result;
		}
		if (maybe_expression) {
			switch (vala_parser_current (self)) {
				case VALA_TOKEN_TYPE_OPEN_PARENS:
				case VALA_TOKEN_TYPE_CLOSE_PARENS:
				case VALA_TOKEN_TYPE_CLOSE_BRACKET:
				case VALA_TOKEN_TYPE_OPEN_BRACE:
				case VALA_TOKEN_TYPE_COLON:
				case VALA_TOKEN_TYPE_SEMICOLON:
				case VALA_TOKEN_TYPE_COMMA:
				case VALA_TOKEN_TYPE_DOT:
				case VALA_TOKEN_TYPE_INTERR:
				case VALA_TOKEN_TYPE_OP_EQ:
				case VALA_TOKEN_TYPE_OP_NE:
				{
					break;
				}
				default:
				{
					vala_parser_rollback (self, &begin);
					result = NULL;
					_vala_collection_object_unref0 (list);
					return result;
				}
			}
		}
		result = (ValaList*) list;
		return result;
	}
	result = NULL;
	return result;
}


static ValaMemberAccess* vala_parser_parse_member_name (ValaParser* self, ValaExpression* base_expr, GError** error) {
	ValaMemberAccess* result = NULL;
	ValaSourceLocation _tmp0_ = {0};
	ValaSourceLocation begin;
	ValaMemberAccess* expr;
	gboolean first;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	begin = (vala_parser_get_location (self, &_tmp0_), _tmp0_);
	expr = NULL;
	first = TRUE;
	{
		gboolean _tmp1_;
		_tmp1_ = TRUE;
		while (TRUE) {
			char* id;
			gboolean qualified;
			gboolean _tmp2_ = FALSE;
			gboolean _tmp3_ = FALSE;
			ValaList* type_arg_list;
			ValaExpression* _tmp6_;
			ValaSourceReference* _tmp7_;
			ValaMemberAccess* _tmp8_;
			if (!_tmp1_) {
				if (!vala_parser_accept (self, VALA_TOKEN_TYPE_DOT)) {
					break;
				}
			}
			_tmp1_ = FALSE;
			id = vala_parser_parse_identifier (self, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			qualified = FALSE;
			if (first) {
				_tmp3_ = _vala_strcmp0 (id, "global") == 0;
			} else {
				_tmp3_ = FALSE;
			}
			if (_tmp3_) {
				_tmp2_ = vala_parser_accept (self, VALA_TOKEN_TYPE_DOUBLE_COLON);
			} else {
				_tmp2_ = FALSE;
			}
			if (_tmp2_) {
				char* _tmp4_;
				char* _tmp5_;
				_tmp4_ = vala_parser_parse_identifier (self, &_inner_error_);
				if (_inner_error_ != NULL) {
					if (_inner_error_->domain == VALA_PARSE_ERROR) {
						g_propagate_error (error, _inner_error_);
						_g_free0 (id);
						_vala_code_node_unref0 (expr);
						return NULL;
					} else {
						_g_free0 (id);
						_vala_code_node_unref0 (expr);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
						g_clear_error (&_inner_error_);
						return NULL;
					}
				}
				id = (_tmp5_ = _tmp4_, _g_free0 (id), _tmp5_);
				qualified = TRUE;
			}
			type_arg_list = vala_parser_parse_type_argument_list (self, FALSE, &_inner_error_);
			if (_inner_error_ != NULL) {
				if (_inner_error_->domain == VALA_PARSE_ERROR) {
					g_propagate_error (error, _inner_error_);
					_g_free0 (id);
					_vala_code_node_unref0 (expr);
					return NULL;
				} else {
					_g_free0 (id);
					_vala_code_node_unref0 (expr);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
					g_clear_error (&_inner_error_);
					return NULL;
				}
			}
			_tmp6_ = NULL;
			if (expr != NULL) {
				_tmp6_ = (ValaExpression*) expr;
			} else {
				_tmp6_ = base_expr;
			}
			expr = (_tmp8_ = vala_member_access_new (_tmp6_, id, _tmp7_ = vala_parser_get_src (self, &begin)), _vala_code_node_unref0 (expr), _tmp8_);
			_vala_source_reference_unref0 (_tmp7_);
			vala_member_access_set_qualified (expr, qualified);
			if (type_arg_list != NULL) {
				{
					ValaIterator* _type_arg_it;
					_type_arg_it = vala_iterable_iterator ((ValaIterable*) type_arg_list);
					while (TRUE) {
						ValaDataType* type_arg;
						if (!vala_iterator_next (_type_arg_it)) {
							break;
						}
						type_arg = (ValaDataType*) vala_iterator_get (_type_arg_it);
						vala_member_access_add_type_argument (expr, type_arg);
						_vala_code_node_unref0 (type_arg);
					}
					_vala_collection_object_unref0 (_type_arg_it);
				}
			}
			first = FALSE;
			_vala_collection_object_unref0 (type_arg_list);
			_g_free0 (id);
		}
	}
	result = expr;
	return result;
}


static gboolean vala_parser_is_declaration_keyword (ValaParser* self, ValaTokenType type) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	switch (type) {
		case VALA_TOKEN_TYPE_ABSTRACT:
		case VALA_TOKEN_TYPE_ASYNC:
		case VALA_TOKEN_TYPE_CLASS:
		case VALA_TOKEN_TYPE_CONST:
		case VALA_TOKEN_TYPE_DELEGATE:
		case VALA_TOKEN_TYPE_ENUM:
		case VALA_TOKEN_TYPE_ERRORDOMAIN:
		case VALA_TOKEN_TYPE_EXTERN:
		case VALA_TOKEN_TYPE_INLINE:
		case VALA_TOKEN_TYPE_INTERFACE:
		case VALA_TOKEN_TYPE_INTERNAL:
		case VALA_TOKEN_TYPE_NAMESPACE:
		case VALA_TOKEN_TYPE_NEW:
		case VALA_TOKEN_TYPE_OVERRIDE:
		case VALA_TOKEN_TYPE_PRIVATE:
		case VALA_TOKEN_TYPE_PROTECTED:
		case VALA_TOKEN_TYPE_PUBLIC:
		case VALA_TOKEN_TYPE_SEALED:
		case VALA_TOKEN_TYPE_SIGNAL:
		case VALA_TOKEN_TYPE_STATIC:
		case VALA_TOKEN_TYPE_STRUCT:
		case VALA_TOKEN_TYPE_VIRTUAL:
		case VALA_TOKEN_TYPE_VOLATILE:
		{
			result = TRUE;
			return result;
		}
		default:
		{
			result = FALSE;
			return result;
		}
	}
}


static ValaParserTokenInfo* vala_parser_token_info_dup (const ValaParserTokenInfo* self) {
	ValaParserTokenInfo* dup;
	dup = g_new0 (ValaParserTokenInfo, 1);
	memcpy (dup, self, sizeof (ValaParserTokenInfo));
	return dup;
}


static void vala_parser_token_info_free (ValaParserTokenInfo* self) {
	g_free (self);
}


static GType vala_parser_token_info_get_type (void) {
	static volatile gsize vala_parser_token_info_type_id__volatile = 0;
	if (g_once_init_enter (&vala_parser_token_info_type_id__volatile)) {
		GType vala_parser_token_info_type_id;
		vala_parser_token_info_type_id = g_boxed_type_register_static ("ValaParserTokenInfo", (GBoxedCopyFunc) vala_parser_token_info_dup, (GBoxedFreeFunc) vala_parser_token_info_free);
		g_once_init_leave (&vala_parser_token_info_type_id__volatile, vala_parser_token_info_type_id);
	}
	return vala_parser_token_info_type_id__volatile;
}


static void vala_parser_class_init (ValaParserClass * klass) {
	vala_parser_parent_class = g_type_class_peek_parent (klass);
	VALA_CODE_VISITOR_CLASS (klass)->finalize = vala_parser_finalize;
	g_type_class_add_private (klass, sizeof (ValaParserPrivate));
	VALA_CODE_VISITOR_CLASS (klass)->visit_source_file = vala_parser_real_visit_source_file;
}


static void vala_parser_instance_init (ValaParser * self) {
	self->priv = VALA_PARSER_GET_PRIVATE (self);
}


static void vala_parser_finalize (ValaCodeVisitor* obj) {
	ValaParser * self;
	self = VALA_PARSER (obj);
	_vala_scanner_unref0 (self->priv->scanner);
	_vala_code_context_unref0 (self->priv->context);
	self->priv->tokens = (g_free (self->priv->tokens), NULL);
	_vala_comment_unref0 (self->priv->comment);
	VALA_CODE_VISITOR_CLASS (vala_parser_parent_class)->finalize (obj);
}


/**
 * Code visitor parsing all Vala source files.
 */
GType vala_parser_get_type (void) {
	static volatile gsize vala_parser_type_id__volatile = 0;
	if (g_once_init_enter (&vala_parser_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ValaParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) vala_parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ValaParser), 0, (GInstanceInitFunc) vala_parser_instance_init, NULL };
		GType vala_parser_type_id;
		vala_parser_type_id = g_type_register_static (VALA_TYPE_CODE_VISITOR, "ValaParser", &g_define_type_info, 0);
		g_once_init_leave (&vala_parser_type_id__volatile, vala_parser_type_id);
	}
	return vala_parser_type_id__volatile;
}


GQuark vala_parse_error_quark (void) {
	return g_quark_from_static_string ("vala_parse_error-quark");
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




